import{l as W,aY as F}from"./index.f5fb6b4d.js";import{F as L,v as P,t as Y}from"./rasterProjectionHelper.9c2f5670.js";class q{constructor(n=15e3,e=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=n,this._interval=Math.min(n,e)}decreaseRefCount(n,e){const t=n+"/"+e,o=this._cachedBlocks;if(o.has(t)){const r=o.get(t);return r.refCount--,r.refCount<=0&&(o.delete(t),r.controller&&r.controller.abort()),r.refCount}return 0}getBlock(n,e){const t=n+"/"+e,o=this._cachedBlocks;if(o.has(t)){const r=o.get(t);return r.ts=Date.now(),r.refCount++,o.delete(t),o.set(t,r),r.block}return null}putBlock(n,e,t,o=null){const r=this._cachedBlocks,c=n+"/"+e;if(r.has(c)){const u=r.get(c);u.ts=Date.now(),u.refCount++}else r.set(c,{block:t,ts:Date.now(),refCount:1,controller:o});this._trim(),this._updateTimer()}deleteBlock(n,e){const t=this._cachedBlocks,o=n+"/"+e;t.has(o)&&t.delete(o)}updateMaxSize(n){this._size=n,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const n=this._cachedBlocks;this._timer=setInterval(()=>{const e=Array.from(n),t=Date.now();for(let o=0;o<e.length&&e[o][1].ts<=t-this._duration;o++)n.delete(e[o][0]);n.size===0&&this._clearTimer()},this._interval)}_trim(){const n=this._cachedBlocks;if(this._size===-1||this._size>=n.size)return;const e=Array.from(n);for(let t=0;t<e.length-this._size;t++)n.delete(e[t][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}}const s=new Map,h=new q;function N(l,n){return n==null?l:`${l}?sliceId=${n}`}function O(l,n){const e={extent:null,rasterInfo:n,cache:new Map};if(s.has(l)){const t=s.get(l);return t.push(e),t.length-1}return s.set(l,[e]),0}function Q(l,n){if(s.has(l)){const e=s.get(l);e[n]=null,e.some(t=>t!=null)||s.delete(l)}}function U(l,n,e){if(!s.has(l))return n==null?h.decreaseRefCount(l,e):0;const t=s.get(l);if(t[n]==null)return h.decreaseRefCount(l,e);const o=t[n].cache;if(o.has(e)){const r=o.get(e);if(r.refCount--,r.refCount===0){o.delete(e);for(let c=0;c<t.length;c++)t[c]&&t[c].cache.has(e)&&t[c].cache.delete(e);r.controller&&r.controller.abort()}return r.refCount}return 0}function V(l,n,e){if(!s.has(l))return n==null?h.getBlock(l,e):null;const t=s.get(l);if(t[n]==null){for(let r=0;r<t.length;r++)if(t[r]&&t[r].cache.has(e)){const c=t[r].cache.get(e);return c.refCount++,c.block}return h.getBlock(l,e)}const o=t[n].cache;if(o.has(e)){const r=o.get(e);return r.refCount++,r.block}for(let r=0;r<t.length;r++)if(r!==n&&t[r]&&t[r]&&t[r].cache.has(e)){const c=t[r].cache.get(e);return c.refCount++,o.set(e,c),c.block}return null}function X(l,n,e,t,o=null){if(!s.has(l))return void(n==null&&h.putBlock(l,e,t,o));const r=s.get(l);if(r[n]==null)return void h.putBlock(l,e,t,o);const c={refCount:1,block:t,isResolved:!1,isRejected:!1,controller:o};t.then(()=>c.isResolved=!0).catch(()=>c.isRejected=!0),r[n].cache.set(e,c)}function Z(l,n,e){if(!s.has(l))return void(n==null&&h.deleteBlock(l,e));const t=s.get(l);t[n]!=null?t[n].cache.delete(e):h.deleteBlock(l,e)}function G(l,n){if(!s.has(l))return null;const e=s.get(l);return e[n]==null?null:e[n]}function ee(l,n,e,t,o,r,c=null){const u=G(l,n),f=u.extent,{cache:k,rasterInfo:y}=u;if(f&&f.xmin===e.xmin&&f.xmax===e.xmax&&f.ymin===e.ymin&&f.ymax===e.ymax)return;const M=e.clone().normalize(),{spatialReference:v,transform:R}=y,b=new Set;for(let d=0;d<M.length;d++){const a=M[d];if(a.xmax-a.xmin<=t||a.ymax-a.ymin<=t)continue;let i=L(a,v,c);W(R)&&(i=R.inverseTransform(i));const I=new F({x:t,y:t,spatialReference:a.spatialReference});if(o==null&&!(o=P(I,v,a,c)))return;const{pyramidLevel:p,pyramidResolution:x,excessiveReading:T}=Y(o,y,r||"closest");if(T)return;const{storageInfo:m}=y,{origin:w}=m,g={x:Math.max(0,Math.floor((i.xmin-w.x)/x.x)),y:Math.max(0,Math.floor((w.y-i.ymax)/x.y))},j=Math.ceil((i.xmax-i.xmin)/x.x-.1),D=Math.ceil((i.ymax-i.ymin)/x.y-.1),z=p>0?m.pyramidBlockWidth:m.blockWidth,$=p>0?m.pyramidBlockHeight:m.blockHeight,_=1,H=Math.max(0,Math.floor(g.x/z)-_),S=Math.max(0,Math.floor(g.y/$)-_),A=Math.floor((g.x+j-1)/z)+_,E=Math.floor((g.y+D-1)/$)+_;for(let B=S;B<=E;B++)for(let C=H;C<=A;C++)b.add(`${p}/${B}/${C}`)}k.forEach((d,a)=>{if(!b.has(a)){const i=k.get(a);(i==null||i.isResolved||i.isRejected)&&k.delete(a)}}),u.extent={xmin:e.xmin,ymin:e.ymin,xmax:e.xmax,ymax:e.ymax}}export{Z as d,ee as g,U as h,N as i,V as m,O as s,Q as u,X as x};
