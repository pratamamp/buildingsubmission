import{s as tn,J as S,A as I,gp as _,g4 as u,a6 as f,g0 as p,C as P,ga as an,a5 as h,g7 as cn,g6 as un,g5 as $,g9 as L,gn as E,gg as gn,l4 as bn,gh as m,hH as ln,g1 as Z,hD as B}from"./index.52935b46.js";import{s as j,c as t}from"./vectorStacks.a7af424f.js";import{e as k}from"./mat4f64.84d5c445.js";import{h as fn,f as N,n as O}from"./sphere.fe54e1ae.js";import{v as pn,A as H,b as dn}from"./lineSegment.42c0099b.js";import{p as v,E as mn,A as $n,O as F,F as hn,q as In,x as Pn,U as Nn,z as D,J as An,Z as A,L as Mn}from"./plane.1ed71234.js";const V=tn.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class vn{constructor(){this.plane=v(),this.origin=I(),this.basis1=I(),this.basis2=I()}}function w(n=rn){return{plane:v(n.plane),origin:_(n.origin),basis1:_(n.basis1),basis2:_(n.basis2)}}function wn(n,o,i){const s=Cn.get();return s.origin=n,s.basis1=o,s.basis2=i,s.plane=mn(0,0,0,0),x(s),s}function T(n,o=w()){return G(n.origin,n.basis1,n.basis2,o)}function Tn(n,o){u(o.origin,n.origin),u(o.basis1,n.basis1),u(o.basis2,n.basis2),$n(o.plane,n.plane)}function G(n,o,i,s=w()){return u(s.origin,n),u(s.basis1,o),u(s.basis2,i),x(s),zn(s,"fromValues()"),s}function x(n){F(n.basis2,n.basis1,n.origin,n.plane)}function W(n,o,i){n!==i&&T(n,i);const s=f(t.get(),l(n),o);return p(i.origin,i.origin,s),i.plane[3]-=o,i}function xn(n,o,i){return X(o,i),W(i,C(n,n.origin),i),i}function X(n,o=w()){const i=(n[2]-n[0])/2,s=(n[3]-n[1])/2;return P(o.origin,n[0]+i,n[1]+s,0),P(o.basis1,i,0,0),P(o.basis2,0,s,0),hn(0,0,1,0,o.plane),o}function z(n,o,i){return!!In(n.plane,o,i)&&sn(n,i)}function yn(n,o,i){if(z(n,o,i))return i;const s=K(n,o,t.get());return p(i,o.origin,f(t.get(),o.direction,an(o.origin,s)/h(o.direction))),i}function K(n,o,i){const s=M.get();en(n,o,s,M.get());let e=Number.POSITIVE_INFINITY;for(const r of U){const a=J(n,r,y.get()),g=t.get();if(Pn(s,a,g)){const c=cn(t.get(),o.origin,g),b=Math.abs(un($(o.direction,c)));b<e&&(e=b,u(i,g))}}return e===Number.POSITIVE_INFINITY?Q(n,o,i):i}function Q(n,o,i){if(z(n,o,i))return i;const s=M.get(),e=M.get();en(n,o,s,e);let r=Number.POSITIVE_INFINITY;for(const a of U){const g=J(n,a,y.get()),c=t.get();if(Nn(s,g,c)){const b=fn(o,c);if(!D(e,c))continue;b<r&&(r=b,u(i,c))}}return Y(n,o.origin)<r&&nn(n,o.origin,i),i}function nn(n,o,i){const s=An(n.plane,o,t.get()),e=H(R(n,n.basis1),s,-1,1,t.get()),r=H(R(n,n.basis2),s,-1,1,t.get());return L(i,p(t.get(),e,r),n.origin),i}function on(n,o,i){const{origin:s,basis1:e,basis2:r}=n,a=L(t.get(),o,s),g=N(e,a),c=N(r,a),b=N(l(n),a);return P(i,g,c,b)}function Y(n,o){const i=on(n,o,t.get()),{basis1:s,basis2:e}=n,r=h(s),a=h(e),g=Math.max(Math.abs(i[0])-r,0),c=Math.max(Math.abs(i[1])-a,0),b=i[2];return g*g+c*c+b*b}function Sn(n,o){return Math.sqrt(Y(n,o))}function _n(n,o){let i=Number.NEGATIVE_INFINITY;for(const s of U){const e=J(n,s,y.get()),r=dn(e,o);r>i&&(i=r)}return Math.sqrt(i)}function En(n,o){return D(n.plane,o)&&sn(n,o)}function On(n,o,i,s){return jn(n,i,s)}function C(n,o){const i=-n.plane[3];return N(l(n),o)-i}function Vn(n,o,i,s){const e=C(n,o),r=f(Yn,l(n),i-e);return p(s,o,r),s}function qn(n,o){return E(n.basis1,o.basis1)&&E(n.basis2,o.basis2)&&E(n.origin,o.origin)}function Fn(n,o,i){return n!==i&&T(n,i),gn(d,o),bn(d,d),m(i.basis1,n.basis1,d),m(i.basis2,n.basis2,d),m(A(i.plane),A(n.plane),d),m(i.origin,n.origin,o),Mn(i.plane,i.plane,i.origin),i}function Ln(n,o,i,s){return n!==s&&T(n,s),ln(q,o,i),m(s.basis1,n.basis1,q),m(s.basis2,n.basis2,q),x(s),s}function l(n){return A(n.plane)}function jn(n,o,i){switch(o){case O.X:u(i,n.basis1),Z(i,i);break;case O.Y:u(i,n.basis2),Z(i,i);break;case O.Z:u(i,l(n))}return i}function sn(n,o){const i=L(t.get(),o,n.origin),s=B(n.basis1),e=B(n.basis2),r=$(n.basis1,i),a=$(n.basis2,i);return-r-s<0&&r-s<0&&-a-e<0&&a-e<0}function R(n,o){const i=y.get();return u(i.origin,n.origin),u(i.vector,o),i}function J(n,o,i){const{basis1:s,basis2:e,origin:r}=n,a=f(t.get(),s,o.origin[0]),g=f(t.get(),e,o.origin[1]);p(i.origin,a,g),p(i.origin,i.origin,r);const c=f(t.get(),s,o.direction[0]),b=f(t.get(),e,o.direction[1]);return f(i.vector,p(c,c,b),2),i}function zn(n,o){Math.abs($(n.basis1,n.basis2)/(h(n.basis1)*h(n.basis2)))>1e-6&&V.warn(o,"Provided basis vectors are not perpendicular"),Math.abs($(n.basis1,l(n)))>1e-6&&V.warn(o,"Basis vectors and plane normal are not perpendicular"),Math.abs(-$(l(n),n.origin)-n.plane[3])>1e-6&&V.warn(o,"Plane offset is not consistent with plane origin")}function en(n,o,i,s){const e=l(n);F(e,o.direction,o.origin,i),F(A(i),e,o.origin,s)}const rn={plane:v(),origin:S(0,0,0),basis1:S(1,0,0),basis2:S(0,1,0)},M=new j(v),y=new j(pn),Yn=I(),Cn=new j(()=>({origin:null,basis1:null,basis2:null,plane:null})),U=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=k(),q=k();Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:vn,create:w,wrap:wn,copy:T,copyWithoutVerify:Tn,fromValues:G,updateUnboundedPlane:x,elevate:W,setExtent:xn,fromAABoundingRect:X,intersectRay:z,intersectRayClosestSilhouette:yn,closestPointOnSilhouette:K,closestPoint:Q,projectPoint:nn,projectPointLocal:on,distance2:Y,distance:Sn,distanceToSilhouette:_n,extrusionContainsPoint:En,axisAt:On,altitudeAt:C,setAltitudeAt:Vn,equals:qn,transform:Fn,rotate:Ln,normal:l,UP:rn},Symbol.toStringTag,{value:"Module"}));export{w as G,x as H,X as Q,T as X,Sn as e};
