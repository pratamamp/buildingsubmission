import{cy as O,cG as N,cH as $,U as H,cJ as V,cO as G,l6 as A,lq as F,ex as D,H as B,E as C,lr as E,ls as K,lt as Y,l as W,fo as j,w as L,lu as q}from"./index.586dfff9.js";import{t as w}from"./BidiEngine.ec67919b.js";import{e as X}from"./CIMSymbolHelper.10273350.js";import{n as Q,l as P,r as Z}from"./StyleDefinition.5774ff26.js";class v{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new w(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new w;let e=null,i=-1;for(let r=0;r<this._free.length;++r){const l=this._free[r];t<=l.width&&s<=l.height&&(e===null||l.y<=e.y&&l.x<=e.x)&&(e=l,i=r)}return e===null?new w:(this._free.splice(i,1),e.width<e.height?(e.width>t&&this._free.push(new w(e.x+t,e.y,e.width-t,s)),e.height>s&&this._free.push(new w(e.x,e.y+s,e.width,e.height-s))):(e.width>t&&this._free.push(new w(e.x+t,e.y,e.width-t,e.height)),e.height>s&&this._free.push(new w(e.x,e.y+s,t,e.height-s))),new w(e.x,e.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const e=this._free[s];if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)e.width+=t.width;else if(e.x===t.x&&e.width===t.width&&e.y+e.height===t.y)e.height+=t.height;else if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)e.x=t.x,e.width+=t.width;else{if(t.x!==e.x||t.width!==e.width||t.y+t.height!==e.y)continue;e.y=t.y,e.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}class U{constructor(t,s,e){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=e,this._binPack=new v(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const e=[],i=this._glyphSource,r=new Set,l=1/256;for(const o of s){const a=Math.floor(o*l);r.add(a)}const n=[];return r.forEach(o=>{if(o<=256){const a=t+o;if(this._rangePromises.has(a))n.push(this._rangePromises.get(a));else{const c=i.getRange(t,o).then(()=>{this._rangePromises.delete(a)},()=>{this._rangePromises.delete(a)});this._rangePromises.set(a,c),n.push(c)}}}),Promise.all(n).then(()=>{let o=this._glyphIndex[t];o||(o={},this._glyphIndex[t]=o);for(const a of s){const c=o[a];if(c){e[a]={sdf:!0,rect:c.rect,metrics:c.metrics,page:c.page,code:a};continue}const g=i.getGlyph(t,a);if(!g||!g.metrics)continue;const _=g.metrics;let h;if(_.width===0)h=new w(0,0,0,0);else{const y=_.width+6,p=_.height+2*3;let d=y%4?4-y%4:4,m=p%4?4-p%4:4;d===1&&(d=5),m===1&&(m=5),h=this._binPack.allocate(y+d,p+m),h.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new v(this.width-4,this.height-4),h=this._binPack.allocate(y+d,p+m));const b=this._glyphData[this._currentPage],S=g.bitmap;let R,I;if(S)for(let x=0;x<p;x++){R=y*x,I=this.width*(h.y+x+1)+h.x;for(let k=0;k<y;k++)b[I+k+1]=S[R+k]}}o[a]={rect:h,metrics:_,tileIDs:null,page:this._currentPage},e[a]={sdf:!0,rect:h,metrics:_,page:this._currentPage,code:a},this._dirties[this._currentPage]=!0}return e})}removeGlyphs(t){for(const s in this._glyphIndex){const e=this._glyphIndex[s];if(!e)continue;let i;for(const r in e)if(i=e[r],i.tileIDs.delete(t),i.tileIDs.size===0){const l=this._glyphData[i.page],n=i.rect;let o,a;for(let c=0;c<n.height;c++)for(o=this.width*(n.y+c)+n.x,a=0;a<n.width;a++)l[o+a]=0;delete e[r],this._dirties[i.page]=!0}}}bind(t,s,e,i=0){this._textures[e]||(this._textures[e]=new O(t,{pixelFormat:N.ALPHA,dataType:$.UNSIGNED_BYTE,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(this._glyphData[e]),t.bindTexture(r,i),this._dirties[e]=!1}dispose(){this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}}class M{constructor(t){if(this._metrics=[],this._bitmaps=[],t)for(;t.next();)switch(t.tag()){case 1:{const s=t.getMessage();for(;s.next();)switch(s.tag()){case 3:{const e=s.getMessage();let i,r,l,n,o,a,c;for(;e.next();)switch(e.tag()){case 1:i=e.getUInt32();break;case 2:r=e.getBytes();break;case 3:l=e.getUInt32();break;case 4:n=e.getUInt32();break;case 5:o=e.getSInt32();break;case 6:a=e.getSInt32();break;case 7:c=e.getUInt32();break;default:e.skip()}e.release(),i&&(this._metrics[i]={width:l,height:n,left:o,top:a,advance:c},this._bitmaps[i]=r);break}default:s.skip()}s.release();break}default:t.skip()}}getMetrics(t){return this._metrics[t]}getBitmap(t){return this._bitmaps[t]}}class tt{constructor(){this._ranges=[]}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}class J{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,s){const e=this._getFontStack(t);if(e.getRange(s))return Promise.resolve();const i=256*s,r=i+255;if(this._baseURL){const l=this._baseURL.replace("{fontstack}",t).replace("{range}",i+"-"+r);return H(l,{responseType:"array-buffer"}).then(n=>{e.addRange(s,new M(new V(new Uint8Array(n.data),new DataView(n.data))))}).catch(()=>{e.addRange(s,new M)})}return e.addRange(s,new M),Promise.resolve()}getGlyph(t,s){const e=this._getFontStack(t);if(!e)return;const i=Math.floor(s/256);if(i>256)return;const r=e.getRange(i);return r?{metrics:r.getMetrics(s),bitmap:r.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new tt),s}}const et="dasharray-";class T{constructor(t,s,e=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(t<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,e>0&&(this._maxItemSize=e),this._binPack=new v(t-4,s-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new v(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),e=Math.floor(this._pageHeight),i=new Uint32Array(s*e);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let e,i,r=this._mosaicRects[t];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(t&&t.startsWith(et)?([e,i]=this._rasterizeDash(t),s=!0):e=this._sprites.getSpriteInfo(t),!e||!e.width||!e.height||e.width<0||e.height<0))return null;const l=e.width,n=e.height,[o,a,c]=this._allocateImage(l,n);return o.width<=0?null:(this._copy(o,e,a,c,s,i),r={rect:o,width:l,height:n,sdf:e.sdf,simplePattern:!1,pixelRatio:e.pixelRatio,page:a},this._mosaicRects[t]=r,r)}getSpriteItems(t){const s={};for(const e of t)s[e.name]=this.getSpriteItem(e.name,e.repeat);return s}getMosaicItemPosition(t,s){const e=this.getSpriteItem(t,s),i=e&&e.rect;if(!i)return null;i.width=e.width,i.height=e.height;const r=e.width,l=e.height,n=2;return{tl:[i.x+n,i.y+n],br:[i.x+n+r,i.y+n+l],page:e.page}}bind(t,s,e=0,i=0){this._textures[e]||(this._textures[e]=new O(t,{pixelFormat:N.RGBA,dataType:$.UNSIGNED_BYTE,wrapMode:G.CLAMP_TO_EDGE,width:this._size[e][0],height:this._size[e][1]},new Uint8Array(this._mosaicsData[e].buffer)));const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(new Uint8Array(this._mosaicsData[e].buffer)),t.bindTexture(r,i),this._dirties[e]=!1}static _copyBits(t,s,e,i,r,l,n,o,a,c,g){let _=i*s+e,h=o*l+n;if(g){h-=l;for(let f=-1;f<=c;f++,_=((f+c)%c+i)*s+e,h+=l)for(let y=-1;y<=a;y++)r[h+y]=t[_+(y+a)%a]}else for(let f=0;f<c;f++){for(let y=0;y<a;y++)r[h+y]=t[_+y];_+=s,h+=l}}_copy(t,s,e,i,r,l){if(!this._sprites||this._sprites.loadStatus!=="loaded"||e>=this._mosaicsData.length)return;const n=new Uint32Array(l?l.buffer:this._sprites.image.buffer),o=this._mosaicsData[e];o&&n||console.error("Source or target images are uninitialized!");const a=2,c=l?s.width:this._sprites.width;T._copyBits(n,c,s.x,s.y,o,i[0],t.x+a,t.y+a,s.width,s.height,r),this._dirties[e]=!0}_allocateImage(t,s){t+=2,s+=2;const e=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<e){const n=new w(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[n,this._mosaicsData.length-1,[t,s]]}let i=t%4?4-t%4:4,r=s%4?4-s%4:4;i===1&&(i=5),r===1&&(r=5);const l=this._binPack.allocate(t+i,s+r);return l.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new v(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[l,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,e=t.match(s);if(!e)return null;const i=e[1].split(",").map(Number),r=t.slice(t.lastIndexOf("-")+1),[l,n,o]=X.rasterizeDash(i,r);return[{x:0,y:0,width:n,height:o,sdf:!0,pixelRatio:1},new Uint8Array(l.buffer)]}}function z(u,t,s,e,i,r){u.fillStyle=t,u.fillRect(s,e,i,r)}function st(u,t,s,e,i,r){u.strokeStyle=t,u.strokeRect(s,e,i,r)}function gt(u,t){const s=window.COLLISION_XRAY;for(let e=0;e<t.length;++e){const i=!t[e].unique.show;if(s||!i)for(const r of t[e].colliders){if(!r.enabled)continue;const l=!t[e].unique.parts[r.partIndex].show;if(!s&&l)continue;const n=r.xScreen,o=r.yScreen,a=r.dxScreen,c=r.dyScreen;u.globalAlpha=i||l?.2:1,z(u,"green",n-1,o-1,3,3),st(u,"red",n+a,o+c,r.width,r.height),z(u,"blue",n+a-1,o+c-1,3,3),u.globalAlpha=1}}}function it(u,t,s){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const e=window.PERFORMANCE_RECORDING_STORAGE;e.perf=e.perf||{};const i=e.perf;i[u]=i[u]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:s},i[u].time+=t,i[u].samples.push(t),(i[u].min==null||t<i[u].min)&&(i[u].min=t),(i[u].max==null||t>i[u].max)&&(i[u].max=t)}class ft{constructor(t,s,e){this._layer=t,this._styleRepository=s,this.devicePixelRatio=e,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(t){this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,t),this._spriteSourcePromise.then(e=>{this._spriteMosaic=new T(1024,1024,250),this._spriteMosaic.setSpriteSource(e)});const s=new J(this._layer.currentStyleInfo.glyphsUrl?A(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new U(1024,1024,s),this._broadcastPromise=F("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then(e=>{this._connection=e,this._connection.broadcast("setStyle",this._layer.currentStyleInfo.style,t)})}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(t){const s=new T(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),s}async setStyle(t,s){await this._broadcastPromise,this._styleRepository=t,this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then(i=>{this._spriteMosaic=new T(1024,1024,250),this._spriteMosaic.setSpriteSource(i)});const e=new J(this._layer.currentStyleInfo.glyphsUrl?A(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new U(1024,1024,e),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",s)),this._broadcastPromise}fetchTileData(t,s){return this._getRefKeys(t,s).then(e=>{const i=this._layer.sourceNameToSource,r=[];for(const l in i)r.push(l);return this._getSourcesData(r,e,s)})}parseTileData(t,s){const e=t&&t.data;if(!e)return Promise.resolve(null);const{sourceName2DataAndRefKey:i,transferList:r}=e;return Object.keys(i).length===0?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:r}))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}perfReport({key:t,milliseconds:s}){it(t,s,"ms")}async _getTilePayload(t,s,e){const i=D.pool.acquire(t.id),r=this._layer.sourceNameToSource[s],{level:l,row:n,col:o}=i;D.pool.release(i);try{return{protobuff:await r.requestTile(l,n,o,e),sourceName:s}}catch(a){if(B(a))throw a;return{protobuff:null,sourceName:s}}}_getRefKeys(t,s){const e=this._layer.sourceNameToSource,i=new Array;for(const r in e){const l=e[r].getRefKey(t,s);i.push(l)}return C(i)}_getSourcesData(t,s,e){const i=[];for(let r=0;r<s.length;r++)if(s[r].value==null||t[r]==null)i.push(null);else{const l=this._getTilePayload(s[r].value,t[r],e);i.push(l)}return C(i).then(r=>{const l={},n=[];for(let o=0;o<r.length;o++)if(r[o].value&&r[o].value&&r[o].value.protobuff&&r[o].value.protobuff.byteLength>0){const a=s[o].value.id;l[r[o].value.sourceName]={refKey:a,protobuff:r[o].value.protobuff},n.push(r[o].value.protobuff)}return{sourceName2DataAndRefKey:l,transferList:n}})}}function rt(u,t,s,e,i,r){const{iconRotationAlignment:l,textRotationAlignment:n,iconTranslate:o,iconTranslateAnchor:a,textTranslate:c,textTranslateAnchor:g}=e;let _=0;for(const h of u.colliders){const[f,y]=h.partIndex===0?o:c,p=h.partIndex===0?a:g,d=h.minLod<=r&&r<=h.maxLod;_+=d?0:1,h.enabled=d,h.xScreen=h.xTile*i[0]+h.yTile*i[3]+i[6],h.yScreen=h.xTile*i[1]+h.yTile*i[4]+i[7],p===Z.MAP?(h.xScreen+=s*f-t*y,h.yScreen+=t*f+s*y):(h.xScreen+=f,h.yScreen+=y),P.VIEWPORT===(h.partIndex===0?l:n)?(h.dxScreen=h.dxPixels,h.dyScreen=h.dyPixels):(h.dxScreen=s*(h.dxPixels+h.width/2)-t*(h.dyPixels+h.height/2)-h.width/2,h.dyScreen=t*(h.dxPixels+h.width/2)+s*(h.dyPixels+h.height/2)-h.height/2)}u.colliders.length>0&&_===u.colliders.length&&(u.unique.show=!1)}class dt{constructor(t,s,e,i,r,l){this._symbols=t,this._styleRepository=i,this._zoom=r,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new E(s,e,K),this._si=Math.sin(Math.PI*l/180),this._co=Math.cos(Math.PI*l/180);for(const n of t)for(const o of n.symbols)this._allNeededMatrices.has(o.tile)||this._allNeededMatrices.set(o.tile,Y(o.tile.transforms.tileUnitsToPixels))}work(t){const s=this._gridIndex;function e(r){const l=r.xScreen+r.dxScreen,n=r.yScreen+r.dyScreen,o=l+r.width,a=n+r.height,[c,g,_,h]=s.getCellSpan(l,n,o,a);for(let f=g;f<=h;f++)for(let y=c;y<=_;y++){const p=s.cells[f][y];for(const d of p){const m=d.xScreen+d.dxScreen,b=d.yScreen+d.dyScreen,S=m+d.width,R=b+d.height;if(!(o<m||l>S||a<b||n>R))return!0}}return!1}const i=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const r=this._symbols[this._currentLayerCursor],l=this._getProperties(r.styleLayerUID);for(;this._currentSymbolCursor<r.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-i>t)return!1;const n=r.symbols[this._currentSymbolCursor];if(!n.unique.show)continue;rt(n,this._si,this._co,l,this._allNeededMatrices.get(n.tile),this._zoom);const o=n.unique;if(!o.show)continue;const{iconAllowOverlap:a,iconIgnorePlacement:c,textAllowOverlap:g,textIgnorePlacement:_}=l;for(const h of n.colliders){if(!h.enabled)continue;const f=o.parts[h.partIndex];!f.show||!(h.partIndex?g:a)&&e(h)&&(h.hard?o.show=!1:f.show=!1)}if(o.show)for(const h of n.colliders){if(!h.enabled||(h.partIndex?_:c)||!o.parts[h.partIndex].show)continue;const f=h.xScreen+h.dxScreen,y=h.yScreen+h.dyScreen,p=f+h.width,d=y+h.height,[m,b,S,R]=this._gridIndex.getCellSpan(f,y,p,d);for(let I=b;I<=R;I++)for(let x=m;x<=S;x++)this._gridIndex.cells[I][x].push(h)}}}return!0}_getProperties(t){const s=this._styleProps.get(t);if(s)return s;const e=this._zoom,i=this._styleRepository.getStyleLayerByUID(t),r=i.getLayoutValue("symbol-placement",e)!==Q.POINT;let l=i.getLayoutValue("icon-rotation-alignment",e);l===P.AUTO&&(l=r?P.MAP:P.VIEWPORT);let n=i.getLayoutValue("text-rotation-alignment",e);n===P.AUTO&&(n=r?P.MAP:P.VIEWPORT);const o=i.getPaintValue("icon-translate",e),a=i.getPaintValue("icon-translate-anchor",e),c=i.getPaintValue("text-translate",e),g=i.getPaintValue("text-translate-anchor",e),_={iconAllowOverlap:i.getLayoutValue("icon-allow-overlap",e),iconIgnorePlacement:i.getLayoutValue("icon-ignore-placement",e),textAllowOverlap:i.getLayoutValue("text-allow-overlap",e),textIgnorePlacement:i.getLayoutValue("text-ignore-placement",e),iconRotationAlignment:l,textRotationAlignment:n,iconTranslateAnchor:a,iconTranslate:o,textTranslateAnchor:g,textTranslate:c};return this._styleProps.set(t,_),_}}function ot(u,t){if(u.priority-t.priority)return u.priority-t.priority;const s=u.tile.key,e=t.tile.key;return s.world-e.world?s.world-e.world:s.level-e.level?s.level-e.level:s.row-e.row?s.row-e.row:s.col-e.col?s.col-e.col:u.xTile-t.xTile?u.xTile-t.xTile:u.yTile-t.yTile}class pt{constructor(t,s,e,i,r,l){this._visibleTiles=t,this._symbolRepository=s,this._createCollisionJob=e,this._assignTileSymbolsOpacity=i,this._symbolLayerSorter=r,this._isLayerVisible=l,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(t,s){this._screenWidth===t&&this._screenHeight===s||this.restart(),this._screenWidth=t,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(t){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(t)||(this._selectionJobCompleted=!0,(t=Math.max(0,t-(performance.now()-s)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(t)||(this._collisionJobCompleted=!0,(t=Math.max(0,t-(performance.now()-s)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(t)||(this._opacityJobCompleted=!0,(t=Math.max(0,t-(performance.now()-s)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const t=this._symbolRepository.uniqueSymbols;for(let o=0;o<t.length;o++){const a=t[o];for(let c=0;c<a.uniqueSymbols.length;c++){const g=a.uniqueSymbols[c];for(const _ of g.tileSymbols)_.selectedForRendering=!1}}const s=[];let e=0,i=0;const r=this._isLayerVisible;function l(o){let a;const c=performance.now();for(;i<t.length;i++,e=0){const g=t[i],_=g.styleLayerUID;if(!r(_)){s[i]||(s[i]={styleLayerUID:_,symbols:[]});continue}s[i]=s[i]||{styleLayerUID:_,symbols:[]};const h=s[i];for(;e<g.uniqueSymbols.length;e++){if(a=g.uniqueSymbols[e],e%100==99&&performance.now()-c>o)return!1;let f=null,y=!1,p=!1;for(const d of a.tileSymbols)if(!p||!y){const m=d.tile;(!f||m.isCoverage||m.neededForCoverage&&!y)&&(f=d,(m.neededForCoverage||m.isCoverage)&&(p=!0),m.isCoverage&&(y=!0))}if(f.selectedForRendering=!0,p){h.symbols.push(f),a.show=!0;for(const d of a.parts)d.show=!0}else a.show=!1}}for(const g of s)g.symbols.sort(ot);return!0}const n=this._symbolLayerSorter;return{work:l,get sortedSymbols(){return s.sort(n)}}}_createOpacityJob(){const t=this._assignTileSymbolsOpacity,s=this._visibleTiles;let e=0;function i(r,l){const n=r.symbols;for(const[o,a]of n)nt(a,l);t(r,l);for(const o of r.childrenTiles)i(o,l)}return{work(r){const l=performance.now();for(;e<s.length;e++){if(performance.now()-l>r)return!1;const n=s[e];W(n.parentTile)||i(n,performance.now())}return!0}}}}function nt(u,t){for(const s of u){const e=s.unique;for(const i of e.parts){const r=i.targetOpacity>.5?1:-1;i.startOpacity+=r*((t-i.startTime)/j),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=t,i.targetOpacity=e.show&&i.show?1:0}}}const lt=32,ht=8,at=64;class mt{constructor(t,s,e){this.tileCoordRange=t,this._visibleTiles=s,this._createUnique=e,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return L(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(t,s){this._uniqueSymbolLayerArray=null;let e=this._tiles.get(t.id);e||(e={symbols:new Map},this._tiles.set(t.id,e));const i=new Map;if(s)for(const n of s)e.symbols.has(n)&&(i.set(n,e.symbols.get(n)),e.symbols.delete(n));else for(const[n,o]of t.layerData)e.symbols.has(n)&&(i.set(n,e.symbols.get(n)),e.symbols.delete(n));this._removeSymbols(i);const r=t.symbols,l=new Map;for(const[n,o]of r){let a=o.length;if(a>=lt){let c=this.tileCoordRange;do c/=2,a/=4;while(a>ht&&c>at);const g=new E(this.tileCoordRange,this.tileCoordRange,c);l.set(n,{flat:o,index:g}),e.symbols.set(n,{flat:o,index:g});for(const _ of o)g.getCell(_.xTile,_.yTile).push(_)}else l.set(n,{flat:o}),e.symbols.set(n,{flat:o})}this._addSymbols(t.key,r)}deleteStyleLayers(t){this._uniqueSymbolLayerArray=null;for(const[s,e]of this._tiles){const i=new Map;for(const r of t)e.symbols.has(r)&&(i.set(r,e.symbols.get(r)),e.symbols.delete(r));this._removeSymbols(i),e.symbols.size===0&&this._tiles.delete(s)}}removeTile(t){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(t.id);if(!s)return;const e=new Map;for(const[i,r]of t.symbols)s.symbols.has(i)&&(e.set(i,s.symbols.get(i)),s.symbols.delete(i));this._removeSymbols(e),s.symbols.size===0&&this._tiles.delete(t.id)}_removeSymbols(t){for(const[s,{flat:e}]of t)for(const i of e){const r=i.unique,l=r.tileSymbols,n=l.length-1;for(let o=0;o<n;o++)if(l[o]===i){l[o]=l[n];break}if(l.length=n,n===0){const o=this._uniqueSymbolsReferences.get(s);o.delete(r),o.size===0&&this._uniqueSymbolsReferences.delete(s)}i.unique=null}}_addSymbols(t,s){if(s.size===0)return;const e=this._visibleTiles;for(const i of e)i.parentTile||i.key.world!==t.world||i.key.level===t.level&&!i.key.equals(t)||this._matchSymbols(i,t,s);for(const[i,r]of s)for(const l of r)if(L(l.unique)){const n=this._createUnique();l.unique=n,n.tileSymbols.push(l);let o=this._uniqueSymbolsReferences.get(i);o||(o=new Set,this._uniqueSymbolsReferences.set(i,o)),o.add(n)}}_matchSymbols(t,s,e){if(t.key.level>s.level){const r=t.key.level-s.level;if(t.key.row>>r!==s.row||t.key.col>>r!==s.col)return}if(s.level>t.key.level){const r=s.level-t.key.level;if(s.row>>r!==t.key.row||s.col>>r!==t.key.col)return}if(s.equals(t.key)){for(const r of t.childrenTiles)this._matchSymbols(r,s,e);return}const i=new Map;for(const[r,l]of e){const n=[];for(const g of l){const _=q(this.tileCoordRange,g.xTile,s.level,s.col,t.key.level,t.key.col),h=q(this.tileCoordRange,g.yTile,s.level,s.row,t.key.level,t.key.row);_>=0&&_<this.tileCoordRange&&h>=0&&h<this.tileCoordRange&&n.push({symbol:g,xTransformed:_,yTransformed:h})}const o=[],a=t.key.level<s.level?1:1<<t.key.level-s.level,c=this._tiles.get(t.id).symbols.get(r);if(c){const g=c.flat;for(const _ of n){let h,f=!1;const y=_.xTransformed,p=_.yTransformed;h=W(c.index)?c.index.getCell(y,p):g;const d=_.symbol,m=d.hash;for(const b of h)if(m===b.hash&&Math.abs(y-b.xTile)<=a&&Math.abs(p-b.yTile)<=a){const S=b.unique;d.unique=S,S.tileSymbols.push(d),f=!0;break}f||o.push(d)}}o.length>0&&i.set(r,o)}for(const r of t.childrenTiles)this._matchSymbols(r,s,i)}_createUniqueSymbolLayerArray(){const t=this._uniqueSymbolsReferences,s=new Array(t.size);let e,i=0;for(const[r,l]of t){const n=new Array(l.size);e=0;for(const o of l)n[e++]=o;s[i]={styleLayerUID:r,uniqueSymbols:n},i++}return s}}export{ft as c,pt as i,dt as l,gt as o,mt as r};
