import{gc as nr,hF as ot,x as yt,af as fe,ba as Jn,h9 as ni,r as x,gh as ue,kg as ft,gk as lr,L as ne,hK as _a,t as K,ga as Ct,gp as Ii,g4 as te,J as Mr,C as ae,A as j,I as No,fa as wt,am as zo,fE as Qn,g9 as xe,g8 as ut,g1 as Re,a6 as ce,g0 as _e,g5 as At,l5 as qi,$ as v,al as kt,s as li,W as jt,aj as Fr,a5 as Ot,l6 as ki,ku as tt,bO as Yn,l7 as Kn,l8 as el,l9 as tl,cs as rl,b0 as ya,la as Uo,lb as Vo,lc as il,kz as sl,aq as br,ld as al,le as ol,lf as nl,jZ as ll,lg as cl,l3 as dl,kO as hl,lh as ul,cu as pl,gl as Mi,gj as fl,dL as ml,li as gl,lj as vl,k_ as _l,jd as Bt,gu as Sa,gg as Er,gw as yl,G as ea,a2 as ta,a0 as ie,a1 as ra,lk as Ta,ll as Sl,z as Tl,c as Fe,hG as $i,gE as vi,lm as xl,l4 as jo,gn as Zr,gM as xa,ln as Ol,lo as Oa,lp as wa,lq as wl,lr as Ra,ab as Rl,hJ as Cr,ls as rr,g7 as Cl,lt as Ho,gf as Ca,j$ as Al,lu as Bo,g6 as bl,ad as Zt,ke as Or,jW as Vr,kc as Aa,j1 as wr,k3 as Le,lv as El,k2 as ba,lw as Pl,l as Dl,bZ as Il,hp as Ml,lx as $l,ly as Ll,lz as Fl,lA as Lt,h as Nl,K as cs,jf as zl,R as ds,dy as Ea,dz as Ul,je as Vl,f3 as jl,lB as hs,fK as Hl,ki as Bl,hP as Gl,kD as Wl,lC as ql,lD as kl,kK as Fs,lE as Zl}from"./index.52935b46.js";import{r as we,n as ge,t as Pa}from"./vec3f32.0772c8d8.js";import{l as Ns,p as bt,_ as Xl,q as Jl,j as Ft,W as Ce,Z as Li}from"./plane.1ed71234.js";import{_ as Ql,O as Yl,j as Kl,d as $t,f as ec,p as tc,l as zs}from"./sphere.fe54e1ae.js";import{u as Us,o as Vs,g as Xr,j as Go,O as Oe,W as at,b as Jr,E as Zi,e as ia,d as $r,S as Wo,c as vt,f as rc,s as ic,h as sc,i as qo,n as sa,_ as ko,k as Da,a as ac,l as Zo}from"./requestImageUtils.16628477.js";import{z as We,b as qe,n as p,k as ci,R as Xo,p as Jo,T as js,U as Hs,q as Ve,V as ye,s as w,o as pe,e as mt,W as bi,X as Qr,Y as Qo,Z as aa,r as oa,h as R,D as di,i as pr,_ as oc,$ as Yo,y as hi,d as ar,A as na,w as Nt,x as Xi,C as rt,f as fr,g as mr,N as Fi,O as Ni,P as la,l as se,t as gr,a0 as Ia,a1 as nc,a2 as lc,a3 as cc,a4 as Ko,F as ui,m as Ht,a5 as Ji,H as Qi,a6 as dc,L as hc,a7 as en,c as Lr,a8 as uc,a9 as tn,a as ti,aa as pc,ab as fc,M as Ma,ac as Yi,E as Nr,ad as mc,ae as gc,af as $a,ag as vc,Q as _c,ah as yc,K as Sc,ai as Tc,aj as xc,ak as La,J as rn,v as ca,al as sn,G as an,I as da,am as Oc,an as wc,ao as Rc,ap as Fa,aq as Cc,ar as Ac,as as bc,at as Ec,au as Pc,av as Dc,aw as Ic,ax as on,ay as Mc,az as $c,aA as Lc,aB as Fc,j as ha,u as nn,aC as Nc,aD as zc,aE as Uc,aF as Vc}from"./Matrix4Uniform.9e24b035.js";import{l as jc,h as ln,g as Hc,u as Bc}from"./geometryDataUtils.8151b70d.js";import{e as Pe,M as cn,g as Gc,l as Wc,k as qc,m as kc,f as Zc,s as vr,u as _i,h as Xc}from"./Util.221caaac.js";import{O as d}from"./VertexAttribute.5551e0d8.js";import{e as ua}from"./quatf64.b60d4974.js";import{e as le,r as Jc,o as cr}from"./mat4f64.84d5c445.js";import{T as pi}from"./InterleavedLayout.b5350ce1.js";import{o as dn}from"./floatRGBA.5328f61e.js";import{E as Rt,D as dr,R as gt,I as Qc,Y as pa,V as fa,M as or,P as Gt,G as hr,L as ri,_ as zi,F as Yc}from"./enums.de935fa5.js";import{c as Ui,l as hn}from"./triangulationUtils.b0bb3487.js";import{D as Yr,u as Kc,f as ed,c as td,n as Ei}from"./VertexArrayObject.b7add78f.js";import{t as un}from"./NestedMap.21c7ee53.js";import{G as rd,k as zt,H as id,i as sd,a as ad}from"./Octree.74aeccc1.js";import{v as Ki,b as pn,l as Pr,k as fn}from"./lineSegment.42c0099b.js";import{u as ir}from"./Texture.7634927e.js";import"./boundedPlane.d7d86859.js";import{o as od}from"./glUtil.345a77b1.js";import{v as zr}from"./dehydratedFeatures.5573332f.js";import{i as nd,u as ld}from"./BufferView.43fc091d.js";function cd(t){t.fragment.uniforms.add(new We("projInfo",(e,r)=>dd(r))),t.fragment.uniforms.add(new qe("zScale",(e,r)=>mn(r))),t.fragment.code.add(p`vec3 reconstructPosition(vec2 fragCoord, float depth) {
return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);
}`)}function dd(t){const e=t.camera.projectionMatrix;return e[11]===0?nr(Na,2/(t.camera.fullWidth*e[0]),2/(t.camera.fullHeight*e[5]),(1+e[12])/e[0],(1+e[13])/e[5]):nr(Na,-2/(t.camera.fullWidth*e[0]),-2/(t.camera.fullHeight*e[5]),(1-e[8])/e[0],(1-e[9])/e[5])}const Na=ot();function mn(t){return t.camera.projectionMatrix[11]===0?yt(za,0,1):yt(za,1,0)}const za=fe();class pt extends ci{constructor(e){super(e,"sampler2D")}}function gn(t,e=!0){t.attributes.add(d.POSITION,"vec2"),e&&t.varyings.add("uv","vec2"),t.vertex.code.add(p`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      ${e?p`uv = position * 0.5 + vec2(0.5);`:""}
    }
  `)}class Pi extends ci{constructor(e){super(e,"vec4")}}class Ut extends ci{constructor(e){super(e,"float")}}class Vi{constructor(){this._disposed=!1}get disposed(){return this._disposed}get shaderTransformation(){return this._shaderTransformation}acquire(e,r,i,s,a,o){this.id=ni(),this.geometry=e,this.material=r,this.transformation=i,this.instanceParameters=s,this.origin=a,this._shaderTransformation=o,this._disposed=!1}release(){this._disposed=!1}dispose(){this._disposed=!0}getStaticTransformation(){return this.transformation}getShaderTransformation(){return x(this._shaderTransformation)?this._shaderTransformation(this.transformation):this.transformation}computeAttachmentOrigin(e){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,e):this.geometry.computeAttachmentOrigin(e))&&(ue(e,e,this.getStaticTransformation()),!0)}}Vi.pool=new Jn(Vi);class Bs{constructor(e){this.channel=e,this.id=ni()}}class vn extends Xo{constructor(e={}){super(),this.type=Jo.Object,this._geometryRecords=new Array,this._geometries=new Array,this._objectTransformation=le(),this._bvObjectSpace=new Ua,this._bvWorldSpace=new Ua,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=e.castShadow==null||e.castShadow,this.metadata=e.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new _n),this.transformation=le();const{geometries:r,materials:i,transformations:s,origins:a}=e;if(Array.isArray(r)){Pe(i.length===r.length,"Object3D: materials don't match geometries"),Pe(s.length===r.length,"Object3D: transformations don't match geometries"),this._geometryRecords.length=r.length,this._geometries.length=r.length;for(let o=0;o<r.length;o++)this._geometries[o]=r[o],this._geometryRecords[o]=Vi.pool.acquire(r[o],i[o],Jc(s[o]),{highlights:null,occludees:null,visible:this._visible},a&&a[o])}}get geometryRecords(){return this._geometryRecords}get geometries(){return this._geometries}get transformation(){return this._objectTransformation}set transformation(e){ft(this._objectTransformation,e),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}dispose(){this._geometryRecords.length=0,this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(e){Pe(this._parentLayer==null||e==null,"Object3D can only be added to a single Layer"),this._parentLayer=e}addGeometry(e,r,i,s,a){i=i||cr,this._geometries.push(e);const o=Vi.pool.acquire(e,r,i,{highlights:null,occludees:null,visible:this._visible},s,a);return this._geometryRecords.push(o),this._hasVolatileTransformation=this._hasVolatileTransformation||x(o.shaderTransformation),this._emit("objectGeometryAdded",{object:this,record:o}),this._invalidateBoundingVolume(),o}removeGeometry(e){const r=this._geometryRecords.splice(e,1)[0];return this._hasVolatileTransformation=x(r.shaderTransformation)?this._geometryRecords.some(i=>x(i.shaderTransformation)):this._hasVolatileTransformation,r.dispose(),this._geometries.splice(e,1),this._emit("objectGeometryRemoved",{object:this,record:r}),this._invalidateBoundingVolume(),r}removeAllGeometries(){for(;this.geometryRecords.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(e){this._emit("vertexAttrsUpdated",{object:this,record:e}),this._invalidateBoundingVolume()}get isVisible(){return this._visible}setVisible(e){if(this._visible!==e){this._visible=e;for(const r of this._geometryRecords)r.instanceParameters.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const e=new Bs(Us.MaskOccludee);for(const r of this._geometryRecords)r.instanceParameters.occludees=js(r.instanceParameters.occludees,e);return this._emit("occlusionChanged",this),e}removeOcclude(e){for(const r of this._geometryRecords)r.instanceParameters.occludees=Hs(r.instanceParameters.occludees,e);this._emit("occlusionChanged",this)}highlight(){const e=new Bs(Us.Highlight);for(const r of this._geometryRecords)r.instanceParameters.highlights=js(r.instanceParameters.highlights,e);return this._emit("highlightChanged",this),e}removeHighlight(e){for(const r of this._geometryRecords)r.instanceParameters.highlights=Hs(r.instanceParameters.highlights,e);this._emit("highlightChanged",this)}getCombinedStaticTransformation(e,r){return lr(ne(r,le()),this.transformation,e.getStaticTransformation())}_getCombinedShaderTransformation(e,r){return r=r||le(),lr(r,this.transformation,e.getShaderTransformation()),r}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(let s=0;s<this._geometryRecords.length;++s){const a=this._geometries[s],o=this._geometryRecords[s],n=a.boundingInfo;x(n)&&(this._calculateTransformedBoundingVolume(n,this._bvObjectSpace,o.getShaderTransformation()),this._calculateTransformedBoundingVolume(n,this._bvWorldSpace,this._getCombinedShaderTransformation(o)))}_a(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),_a(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const e=j(),r=j(),i=Ns(this.transformation);for(let s=0;s<this._geometryRecords.length;++s){const a=this._geometries[s].boundingInfo;if(K(a))continue;const o=this._geometryRecords[s].getShaderTransformation(),n=Ns(o);ue(e,a.getCenter(),o);const c=Ct(e,this._bvObjectSpace.bounds),l=a.getBSRadius()*n;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],c+l),ue(r,e,this.transformation);const h=Ct(r,this._bvWorldSpace.bounds),u=l*i;this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],h+u)}this._bvDirty=!1}_calculateTransformedBoundingVolume(e,r,i){const s=e.getBBMin(),a=e.getBBMax(),o=Ii(s),n=Ii(a);ue(o,o,i),ue(n,n,i);for(let c=0;c<3;++c)r.min[c]=Math.min(r.min[c],o[c],n[c]),r.max[c]=Math.max(r.max[c],o[c],n[c]);for(let c=0;c<3;++c){te(o,s),te(n,a),o[c]=a[c],n[c]=s[c],ue(o,o,i),ue(n,n,i);for(let l=0;l<3;++l)r.min[l]=Math.min(r.min[l],o[l],n[l]),r.max[l]=Math.max(r.max[l],o[l],n[l])}}_invalidateBoundingVolume(){this._bvDirty=!0,x(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(e,r){x(this._parentLayer)&&this._parentLayer.events.emit(e,r)}get test(){const e=this;return{hasGeometry:r=>e._geometries.includes(r),getGeometryIndex:r=>e._geometries.indexOf(r)}}}class _n{constructor(){this.min=Mr(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=Mr(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class Ua extends _n{constructor(){super(...arguments),this.bounds=Ql()}init(){ae(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),ae(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),Yl(this.bounds)}}const hd=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","vertexAttrsUpdated"];class ud extends Xo{constructor(e,r=""){var i,s,a;super(),this.apiLayerUid=r,this.type=Jo.Layer,this.events=new No,this.isSliceable=!1,this._objects=new wt,this._stageHandles=new zo,this.apiLayerUid=r,this.isVisible=(i=e==null?void 0:e.isVisible)!=null?i:!0,this.isPickable=(s=e==null?void 0:e.isPickable)!=null?s:!0,this.updatePolicy=(a=e==null?void 0:e.updatePolicy)!=null?a:Vs.ASYNC}get objects(){return this._objects}destroy(){this.detachStage(),this._stage=null}attachStage(e){this.detachStage(),this._stage=e;for(const r of hd)this._stageHandles.add(this.events.on(r,i=>e.handleEvent(r,i)))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),x(this._octree)&&this._octree.add([e])}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),x(this._octree)&&this._octree.remove([e]))}addMany(e){this._objects.pushArray(e);for(const r of e)r.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),x(this._octree)&&this._octree.add(e)}removeMany(e){const r=new Array;if(this._objects.removeUnorderedMany(e,e.length,r),r.length!==0){for(const i of r)i.parentLayer=null;this.events.emit("layerObjectsRemoved",{layer:this,objects:r}),x(this._octree)&&this._octree.remove(r)}}sync(){x(this._stage)&&this.updatePolicy!==Vs.SYNC&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(e,r){x(this._octree)&&this._octree.update(e,r)}getSpatialQueryAccelerator(){return K(this._octree)&&this._objects.length>50&&this._createOctree(),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=Qn(this._octree)}_createOctree(){this._octree=new rd(e=>e.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)}}var Gs;(function(t){function e(o,n){const c=o[n],l=o[n+1],h=o[n+2];return Math.sqrt(c*c+l*l+h*h)}function r(o,n){const c=o[n],l=o[n+1],h=o[n+2],u=1/Math.sqrt(c*c+l*l+h*h);o[n]*=u,o[n+1]*=u,o[n+2]*=u}function i(o,n,c){o[n]*=c,o[n+1]*=c,o[n+2]*=c}function s(o,n,c,l,h,u=n){(h=h||o)[u]=o[n]+c[l],h[u+1]=o[n+1]+c[l+1],h[u+2]=o[n+2]+c[l+2]}function a(o,n,c,l,h,u=n){(h=h||o)[u]=o[n]-c[l],h[u+1]=o[n+1]-c[l+1],h[u+2]=o[n+2]-c[l+2]}t.length=e,t.normalize=r,t.scale=i,t.add=s,t.subtract=a})(Gs||(Gs={}));const _r=Gs;var us,ps,fs,Ws;(function(t){const r=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],i=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],s=[0,0,1,0,1,1,0,1],a=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),o=new Uint16Array(36);for(let l=0;l<6;l++)for(let h=0;h<6;h++)o[6*l+h]=l;const n=new Uint16Array(36);for(let l=0;l<6;l++)n[6*l+0]=0,n[6*l+1]=1,n[6*l+2]=2,n[6*l+3]=2,n[6*l+4]=3,n[6*l+5]=0;function c(l){Array.isArray(l)||(l=[l,l,l]);const h=new Array(24);for(let u=0;u<8;u++)h[3*u]=r[u][0]*l[0],h[3*u+1]=r[u][1]*l[1],h[3*u+2]=r[u][2]*l[2];return new Ve([[d.POSITION,{size:3,data:h,exclusive:!0}],[d.NORMAL,{size:3,data:i}],[d.UV0,{size:2,data:s}]],[[d.POSITION,a],[d.NORMAL,o],[d.UV0,n]])}t.createGeometry=c})(us||(us={})),function(t){const r=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],i=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],s=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),a=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);function o(n){Array.isArray(n)||(n=[n,n,n]);const c=new Array(18);for(let l=0;l<6;l++)c[3*l]=r[l][0]*n[0],c[3*l+1]=r[l][1]*n[1],c[3*l+2]=r[l][2]*n[2];return new Ve([[d.POSITION,{size:3,data:c,exclusive:!0}],[d.NORMAL,{size:3,data:i}]],[[d.POSITION,s],[d.NORMAL,a]])}t.createGeometry=o}(ps||(ps={})),function(t){const i=we(-.5,0,-.5),s=we(.5,0,-.5),a=we(0,0,.5),o=we(0,0+.5,0),n=ge(),c=ge(),l=ge(),h=ge(),u=ge();xe(n,i,o),xe(c,i,s),ut(l,n,c),Re(l,l),xe(n,s,o),xe(c,s,a),ut(h,n,c),Re(h,h),xe(n,a,o),xe(c,a,i),ut(u,n,c),Re(u,u);const f=[i,s,a,o],S=[0,-1,0,l[0],l[1],l[2],h[0],h[1],h[2],u[0],u[1],u[2]],O=[0,1,2,3,1,0,3,2,1,3,0,2],b=[0,0,0,1,1,1,2,2,2,3,3,3];function U(C){Array.isArray(C)||(C=[C,C,C]);const P=new Array(12);for(let y=0;y<4;y++)P[3*y]=f[y][0]*C[0],P[3*y+1]=f[y][1]*C[1],P[3*y+2]=f[y][2]*C[2];return new Ve([[d.POSITION,{size:3,data:P,exclusive:!0}],[d.NORMAL,{size:3,data:S}]],[[d.POSITION,new Uint16Array(O)],[d.NORMAL,new Uint16Array(b)]])}t.createGeometry=U}(fs||(fs={})),function(t){function e(y,_,m,g={uv:!0}){const A=-Math.PI,E=2*Math.PI,D=-Math.PI/2,$=Math.PI,T=Math.max(3,Math.floor(_)),N=Math.max(2,Math.floor(m)),L=(T+1)*(N+1),M=new Float32Array(3*L),W=new Float32Array(3*L),F=new Float32Array(2*L),H=[];let V=0;for(let re=0;re<=N;re++){const q=[],z=re/N,oe=D+z*$,de=Math.cos(oe);for(let je=0;je<=T;je++){const k=je/T,B=A+k*E,Ae=Math.cos(B)*de,De=Math.sin(oe),Ur=-Math.sin(B)*de;M[3*V]=Ae*y,M[3*V+1]=De*y,M[3*V+2]=Ur*y,W[3*V]=Ae,W[3*V+1]=De,W[3*V+2]=Ur,F[2*V]=k,F[2*V+1]=z,q.push(V),++V}H.push(q)}const J=new Uint32Array(2*T*(N-1)*3);V=0;for(let re=0;re<N;re++)for(let q=0;q<T;q++){const z=H[re][q],oe=H[re][q+1],de=H[re+1][q+1],je=H[re+1][q];re===0?(J[V++]=z,J[V++]=de,J[V++]=je):re===N-1?(J[V++]=z,J[V++]=oe,J[V++]=de):(J[V++]=z,J[V++]=oe,J[V++]=de,J[V++]=de,J[V++]=je,J[V++]=z)}const G=[[d.POSITION,J],[d.NORMAL,J]],ee=[[d.POSITION,{size:3,data:M,exclusive:!0}],[d.NORMAL,{size:3,data:W,exclusive:!0}]];return g.uv&&(ee.push([d.UV0,{size:2,data:F,exclusive:!0}]),G.push([d.UV0,J])),g.offset&&(G[0][0]=d.OFFSET,ee[0][0]=d.OFFSET,G.push([d.POSITION,new Uint32Array(J.length)]),ee.push([d.POSITION,{size:3,data:Float64Array.from(g.offset),exclusive:!0}])),new Ve(ee,G)}function r(y,_,m){const g=y;let A,E;if(m)A=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],E=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const M=g*(1+Math.sqrt(5))/2;A=[-g,M,0,g,M,0,-g,-M,0,g,-M,0,0,-g,M,0,g,M,0,-g,-M,0,g,-M,M,0,-g,M,0,g,-M,0,-g,-M,0,g],E=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let M=0;M<A.length;M+=3)_r.scale(A,M,y/_r.length(A,M));let D={};function $(M,W){M>W&&([M,W]=[W,M]);const F=M.toString()+"."+W.toString();if(D[F])return D[F];let H=A.length;return A.length+=3,_r.add(A,3*M,A,3*W,A,H),_r.scale(A,H,y/_r.length(A,H)),H/=3,D[F]=H,H}for(let M=0;M<_;M++){const W=E.length,F=new Uint32Array(4*W);for(let H=0;H<W;H+=3){const V=E[H],J=E[H+1],G=E[H+2],ee=$(V,J),re=$(J,G),q=$(G,V),z=4*H;F[z]=V,F[z+1]=ee,F[z+2]=q,F[z+3]=J,F[z+4]=re,F[z+5]=ee,F[z+6]=G,F[z+7]=q,F[z+8]=re,F[z+9]=ee,F[z+10]=re,F[z+11]=q}E=F,D={}}const T=new Float32Array(A);for(let M=0;M<T.length;M+=3)_r.normalize(T,M);const N=[[d.POSITION,E],[d.NORMAL,E]],L=[[d.POSITION,{size:3,data:new Float32Array(A),exclusive:!0}],[d.NORMAL,{size:3,data:T,exclusive:!0}]];return new Ve(L,N)}function i(y,_,m,g,A,E,D){const $=_?[_[0],_[1],_[2]]:[0,0,0],T=y?[y[0],y[1],y[2]]:[0,0,1];E=E||[0,0];const N=m?[255*m[0],255*m[1],255*m[2],m.length>3?255*m[3]:255]:[255,255,255,255],L=g!=null&&g.length===2?g:[1,1],M=[[d.POSITION,{size:3,data:$,exclusive:!0}],[d.NORMAL,{size:3,data:T,exclusive:!0}],[d.UV0,{size:E.length,data:E}],[d.COLOR,{size:4,data:N,exclusive:!0}],[d.SIZE,{size:2,data:L}]];if(A!=null){const W=new Float32Array([A[0],A[1],A[2],A[3]]);M.push([d.AUXPOS1,{size:4,data:W}])}if(D!=null){const W=new Float32Array([D[0],D[1],D[2],D[3]]);M.push([d.AUXPOS2,{size:4,data:W}])}return new Ve(M,null,Xr.Point)}function s(y,_,m,g,A,E,D,$){if(y!=null){const{data:T}=$.getMutableAttribute(d.NORMAL);T[0]=y[0],T[1]=y[1],T[2]=y[2]}if(_!=null){const{data:T}=$.getMutableAttribute(d.POSITION);T[0]=_[0],T[1]=_[1],T[2]=_[2]}if(m!=null){const{data:T}=$.getMutableAttribute(d.COLOR);T[0]=m[0],T[1]=m[1],T[2]=m[2],T[3]=m[3]}if(g!=null){const{data:T}=$.getMutableAttribute(d.SIZE);T[0]=g[0],T[1]=g[1]}if(A!=null){const{data:T}=$.getMutableAttribute(d.AUXPOS1);T[0]=A[0],T[1]=A[1],T[2]=A[2],T[3]=A[3]}if(E!=null){const{data:T}=$.getMutableAttribute(d.UV0);T[0]=E[0],T[1]=E[1]}if(D!=null){const{data:T}=$.getMutableAttribute(d.AUXPOS2);T[0]=D[0],T[1]=D[1],T[2]=D[2],T[3]=D[3]}}function a(y,_){const m=new Float32Array(3*y.length),g=new Float32Array(_?3*y.length:3),A=new Uint32Array(y.length),E=new Uint32Array(y.length);for(let N=0;N<y.length;N++)m[3*N]=y[N][0],m[3*N+1]=y[N][1],m[3*N+2]=y[N][2],_&&(g[3*N]=_[N][0],g[3*N+1]=_[N][1],g[3*N+2]=_[N][2]),A[N]=N,E[N]=0;_||(g[0]=0,g[1]=1,g[2]=0);const D=[0,0],$=[[d.POSITION,A],[d.NORMAL,_?A:E],[d.UV0,E]],T=[[d.POSITION,{size:3,data:m,exclusive:!0}],[d.NORMAL,{size:3,data:g,exclusive:!0}],[d.UV0,{size:2,data:D,exclusive:!0}]];return new Ve(T,$,Xr.Point)}function o(){const y=[0,0,0,0,0,100,100,0,0],_=new Uint16Array([0,1,2]),m=[0,1,0],g=new Uint16Array([0,0,0]),A=[0,0],E=new Uint16Array([0,0,0]),D=[[d.POSITION,_],[d.NORMAL,g],[d.UV0,E]],$=[[d.POSITION,{size:3,data:y,exclusive:!0}],[d.NORMAL,{size:3,data:m,exclusive:!0}],[d.UV0,{size:2,data:A,exclusive:!0}]];return new Ve($,D)}t.createBoxGeometry=us.createGeometry,t.createDiamondGeometry=ps.createGeometry,t.createTetrahedronGeometry=fs.createGeometry,t.createSphereGeometry=e,t.createPolySphereGeometry=r,t.createPointGeometry=i,t.updatePointGeometry=s,t.createPointArrayGeometry=a,t.createTriangleGeometry=o;const n=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function c(y=n){const _=new Array(12);for(let N=0;N<4;N++)for(let L=0;L<3;L++)_[3*N+L]=y[N][L];const m=new Uint32Array([0,1,2,2,3,0]),g=[0,0,1],A=new Uint32Array([0,0,0,0,0,0]),E=[0,0,1,0,1,1,0,1],D=[255,255,255,255],$=[[d.POSITION,m],[d.NORMAL,A],[d.UV0,m],[d.COLOR,A]],T=[[d.POSITION,{size:3,data:_,exclusive:!0}],[d.NORMAL,{size:3,data:g,exclusive:!0}],[d.UV0,{size:2,data:E,exclusive:!0}],[d.COLOR,{size:4,data:D,exclusive:!0}]];return new Ve(T,$)}function l(y,_,m,g,A=!0,E=!0){let D=0;const $=_,T=y;let N=we(0,D,0),L=we(0,D+T,0),M=we(0,-1,0),W=we(0,1,0);g&&(D=T,L=we(0,0,0),N=we(0,D,0),M=we(0,1,0),W=we(0,-1,0));const F=[L,N],H=[M,W],V=m+2,J=Math.sqrt(T*T+$*$);if(g)for(let k=m-1;k>=0;k--){const B=k*(2*Math.PI/m),Ae=we(Math.cos(B)*$,D,Math.sin(B)*$);F.push(Ae);const De=we(T*Math.cos(B)/J,-$/J,T*Math.sin(B)/J);H.push(De)}else for(let k=0;k<m;k++){const B=k*(2*Math.PI/m),Ae=we(Math.cos(B)*$,D,Math.sin(B)*$);F.push(Ae);const De=we(T*Math.cos(B)/J,$/J,T*Math.sin(B)/J);H.push(De)}const G=new Uint32Array(2*(m+2)*3),ee=new Uint32Array(2*(m+2)*3);let re=0,q=0;if(A){for(let k=3;k<F.length;k++)G[re++]=1,G[re++]=k-1,G[re++]=k,ee[q++]=0,ee[q++]=0,ee[q++]=0;G[re++]=F.length-1,G[re++]=2,G[re++]=1,ee[q++]=0,ee[q++]=0,ee[q++]=0}if(E){for(let k=3;k<F.length;k++)G[re++]=k,G[re++]=k-1,G[re++]=0,ee[q++]=k,ee[q++]=k-1,ee[q++]=1;G[re++]=0,G[re++]=2,G[re++]=F.length-1,ee[q++]=1,ee[q++]=2,ee[q++]=H.length-1}const z=new Float32Array(3*V);for(let k=0;k<V;k++)z[3*k]=F[k][0],z[3*k+1]=F[k][1],z[3*k+2]=F[k][2];const oe=new Float32Array(3*V);for(let k=0;k<V;k++)oe[3*k]=H[k][0],oe[3*k+1]=H[k][1],oe[3*k+2]=H[k][2];const de=[[d.POSITION,G],[d.NORMAL,ee]],je=[[d.POSITION,{size:3,data:z,exclusive:!0}],[d.NORMAL,{size:3,data:oe,exclusive:!0}]];return new Ve(je,de)}function h(y,_,m,g,A,E){const D=g?Pa(g):we(1,0,0),$=A?Pa(A):we(0,0,0);E=E==null||E;const T=ge();Re(T,D);const N=ge();ce(N,T,Math.abs(y));const L=ge();ce(L,N,-.5),_e(L,L,$);const M=we(0,1,0);Math.abs(1-At(T,M))<.2&&ae(M,0,0,1);const W=ge();ut(W,T,M),Re(W,W),ut(M,W,T);const F=2*m+(E?2:0),H=m+(E?2:0),V=new Float32Array(3*F),J=new Float32Array(3*H),G=new Float32Array(2*F),ee=new Uint32Array(3*m*(E?4:2)),re=new Uint32Array(3*m*(E?4:2));E&&(V[3*(F-2)+0]=L[0],V[3*(F-2)+1]=L[1],V[3*(F-2)+2]=L[2],G[2*(F-2)]=0,G[2*(F-2)+1]=0,V[3*(F-1)+0]=V[3*(F-2)+0]+N[0],V[3*(F-1)+1]=V[3*(F-2)+1]+N[1],V[3*(F-1)+2]=V[3*(F-2)+2]+N[2],G[2*(F-1)]=1,G[2*(F-1)+1]=1,J[3*(H-2)+0]=-T[0],J[3*(H-2)+1]=-T[1],J[3*(H-2)+2]=-T[2],J[3*(H-1)+0]=T[0],J[3*(H-1)+1]=T[1],J[3*(H-1)+2]=T[2]);const q=(B,Ae,De)=>{ee[B]=Ae,re[B]=De};let z=0;const oe=ge(),de=ge();for(let B=0;B<m;B++){const Ae=B*(2*Math.PI/m);ce(oe,M,Math.sin(Ae)),ce(de,W,Math.cos(Ae)),_e(oe,oe,de),J[3*B+0]=oe[0],J[3*B+1]=oe[1],J[3*B+2]=oe[2],ce(oe,oe,_),_e(oe,oe,L),V[3*B+0]=oe[0],V[3*B+1]=oe[1],V[3*B+2]=oe[2],G[2*B+0]=B/m,G[2*B+1]=0,V[3*(B+m)+0]=V[3*B+0]+N[0],V[3*(B+m)+1]=V[3*B+1]+N[1],V[3*(B+m)+2]=V[3*B+2]+N[2],G[2*(B+m)+0]=B/m,G[2*B+1]=1;const De=(B+1)%m;q(z++,B,B),q(z++,B+m,B),q(z++,De,De),q(z++,De,De),q(z++,B+m,B),q(z++,De+m,De)}if(E){for(let B=0;B<m;B++){const Ae=(B+1)%m;q(z++,F-2,H-2),q(z++,B,H-2),q(z++,Ae,H-2)}for(let B=0;B<m;B++){const Ae=(B+1)%m;q(z++,B+m,H-1),q(z++,F-1,H-1),q(z++,Ae+m,H-1)}}const je=[[d.POSITION,ee],[d.NORMAL,re],[d.UV0,ee]],k=[[d.POSITION,{size:3,data:V,exclusive:!0}],[d.NORMAL,{size:3,data:J,exclusive:!0}],[d.UV0,{size:2,data:G,exclusive:!0}]];return new Ve(k,je)}function u(y,_,m,g,A){m=m||10,g=g==null||g,Pe(y.length>1);const E=[[0,0,0]],D=[],$=[];for(let T=0;T<m;T++){D.push([0,-T-1,-(T+1)%m-1]);const N=T/m*2*Math.PI;$.push([Math.cos(N)*_,Math.sin(N)*_])}return t.createPathExtrusionGeometry($,y,E,D,g,A)}function f(y,_,m,g,A,E=we(0,0,0)){const D=y.length,$=new Float32Array(_.length*D*3+(6*m.length||0)),T=new Float32Array(_.length*D*3+(m?6:0)),N=(_.length-1)*D*6+3*g.length*2,L=new Uint32Array(N),M=new Uint32Array(N);let W=0,F=0,H=0,V=0;const J=ge(),G=ge(),ee=ge(),re=ge(),q=ge(),z=ge(),oe=ge(),de=j(),je=ge(),k=ge(),B=ge(),Ae=ge(),De=ge(),Ur=bt();ae(je,0,1,0),xe(G,_[1],_[0]),Re(G,G),A?(_e(de,_[0],E),Re(ee,de)):ae(ee,0,0,1),P(G,ee,je,je,q,ee,Va),te(re,ee),te(Ae,q);for(let X=0;X<m.length;X++)ce(z,q,m[X][0]),ce(de,ee,m[X][2]),_e(z,z,de),_e(z,z,_[0]),$[W++]=z[0],$[W++]=z[1],$[W++]=z[2];T[F++]=-G[0],T[F++]=-G[1],T[F++]=-G[2];for(let X=0;X<g.length;X++)L[H++]=g[X][0]>0?g[X][0]:-g[X][0]-1+m.length,L[H++]=g[X][1]>0?g[X][1]:-g[X][1]-1+m.length,L[H++]=g[X][2]>0?g[X][2]:-g[X][2]-1+m.length,M[V++]=0,M[V++]=0,M[V++]=0;let it=m.length;const qn=m.length-1;for(let X=0;X<_.length;X++){let va=!1;X>0&&(te(J,G),X<_.length-1?(xe(G,_[X+1],_[X]),Re(G,G)):va=!0,_e(k,J,G),Re(k,k),_e(B,_[X-1],re),Xl(_[X],k,Ur),Jl(Ur,Kl(B,J),de)?(xe(de,de,_[X]),Re(ee,de),ut(q,k,ee),Re(q,q)):P(k,re,Ae,je,q,ee,Va),te(re,ee),te(Ae,q)),A&&(_e(de,_[X],E),Re(De,de));for(let Et=0;Et<D;Et++)if(ce(z,q,y[Et][0]),ce(de,ee,y[Et][1]),_e(z,z,de),Re(oe,z),T[F++]=oe[0],T[F++]=oe[1],T[F++]=oe[2],_e(z,z,_[X]),$[W++]=z[0],$[W++]=z[1],$[W++]=z[2],!va){const ns=(Et+1)%D;L[H++]=it+Et,L[H++]=it+D+Et,L[H++]=it+ns,L[H++]=it+ns,L[H++]=it+D+Et,L[H++]=it+D+ns;for(let ls=0;ls<6;ls++)M[V++]=L[H-6+ls]-qn}it+=D}const kn=_[_.length-1];for(let X=0;X<m.length;X++)ce(z,q,m[X][0]),ce(de,ee,m[X][1]),_e(z,z,de),_e(z,z,kn),$[W++]=z[0],$[W++]=z[1],$[W++]=z[2];const as=F/3;T[F++]=G[0],T[F++]=G[1],T[F++]=G[2];const os=it-D;for(let X=0;X<g.length;X++)L[H++]=g[X][0]>=0?it+g[X][0]:-g[X][0]-1+os,L[H++]=g[X][2]>=0?it+g[X][2]:-g[X][2]-1+os,L[H++]=g[X][1]>=0?it+g[X][1]:-g[X][1]-1+os,M[V++]=as,M[V++]=as,M[V++]=as;const Zn=[[d.POSITION,L],[d.NORMAL,M]],Xn=[[d.POSITION,{size:3,data:$,exclusive:!0}],[d.NORMAL,{size:3,data:T,exclusive:!0}]];return new Ve(Xn,Zn)}function S(y,_,m){Pe(y.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),Pe(y[0].length===3,"createPolylineGeometry(): malformed vertex"),Pe(_==null||_.length===y.length,"createPolylineGeometry: need same number of points and normals"),Pe(_==null||_[0].length===3,"createPolylineGeometry(): malformed normal");const g=new Float64Array(3*y.length),A=new Uint32Array(2*(y.length-1));let E=0,D=0;for(let N=0;N<y.length;N++){for(let L=0;L<3;L++)g[E++]=y[N][L];N>0&&(A[D++]=N-1,A[D++]=N)}const $=[],T=[];if($.push([d.POSITION,A]),T.push([d.POSITION,{size:3,data:g,exclusive:!0}]),_){const N=new Float32Array(3*_.length);let L=0;for(let M=0;M<y.length;M++)for(let W=0;W<3;W++)N[L++]=_[M][W];$.push([d.NORMAL,A]),T.push([d.NORMAL,{size:3,data:N,exclusive:!0}])}return m&&(T.push([d.COLOR,{size:4,data:m}]),$.push([d.COLOR,jc(m.length/4)])),new Ve(T,$,Xr.Line)}function O(y,_,m,g,A=0){const E=new Array(18),D=[[-_,A,g/2],[m,A,g/2],[0,y+A,g/2],[-_,A,-g/2],[m,A,-g/2],[0,y+A,-g/2]],$=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let T=0;T<6;T++)E[3*T]=D[T][0],E[3*T+1]=D[T][1],E[3*T+2]=D[T][2];return new Ve([[d.POSITION,{size:3,data:E,exclusive:!0}]],[[d.POSITION,$]])}function b(y,_){const m=y.getMutableAttribute(d.POSITION).data;for(let g=0;g<m.length;g+=3){const A=m[g],E=m[g+1],D=m[g+2];ae(yr,A,E,D),ue(yr,yr,_),m[g]=yr[0],m[g+1]=yr[1],m[g+2]=yr[2]}}function U(y,_=y){const m=y.vertexAttributes,g=m.get(d.POSITION).data,A=m.get(d.NORMAL).data;if(A){const E=_.getMutableAttribute(d.NORMAL).data;for(let D=0;D<A.length;D+=3){const $=A[D+1];E[D+1]=-A[D+2],E[D+2]=$}}if(g){const E=_.getMutableAttribute(d.POSITION).data;for(let D=0;D<g.length;D+=3){const $=g[D+1];E[D+1]=-g[D+2],E[D+2]=$}}return _}function C(y,_,m,g,A){return!(Math.abs(At(_,y))>A)&&(ut(m,y,_),Re(m,m),ut(g,m,y),Re(g,g),!0)}function P(y,_,m,g,A,E,D){return C(y,_,A,E,D)||C(y,m,A,E,D)||C(y,g,A,E,D)}t.createSquareGeometry=c,t.createConeGeometry=l,t.createCylinderGeometry=h,t.createTubeGeometry=u,t.createPathExtrusionGeometry=f,t.createPolylineGeometry=S,t.createExtrudedTriangle=O,t.transformInPlace=b,t.cgToGIS=U,t.makeOrthoBasisDirUp=C,t.makeOrthoBasisDirUpFallback=P}(Ws||(Ws={}));const Va=.99619469809,yr=ge(),of=Ws;class pd{constructor(e,r){this._material=e,this._repository=r,this._map=new Map}destroy(){this._map.forEach((e,r)=>{x(e)&&this._repository.release(this._material,ii(r))})}load(e,r){this._map.has(r)||this._map.set(r,this._repository.acquire(this._material,ii(r)));const i=this._map.get(r);if(x(i)){if(i.ensureResources(e)===Go.LOADED)return i;this._repository.requestRender()}return null}}function ii(t){switch(t){case ye.MATERIAL:return w.Color;case ye.MATERIAL_ALPHA:return w.Alpha;case ye.MATERIAL_DEPTH:return w.Depth;case ye.MATERIAL_NORMAL:return w.Normal;case ye.MATERIAL_DEPTH_SHADOWMAP_ALL:return w.Shadow;case ye.MATERIAL_HIGHLIGHT:return w.Highlight;case ye.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT:case ye.MATERIAL_DEPTH_SHADOWMAP_DEFAULT:return w.Shadow}}const ja=8;function fd(t,e){const r=t.vertex;r.uniforms.add(new pe("intrinsicWidth",i=>i.width)),e.vvSize?(t.attributes.add(d.SIZEFEATUREATTRIBUTE,"float"),r.uniforms.add(new mt("vvSizeMinSize",i=>i.vvSizeMinSize)),r.uniforms.add(new mt("vvSizeMaxSize",i=>i.vvSizeMaxSize)),r.uniforms.add(new mt("vvSizeOffset",i=>i.vvSizeOffset)),r.uniforms.add(new mt("vvSizeFactor",i=>i.vvSizeFactor)),r.code.add(p`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(t.attributes.add(d.SIZE,"float"),r.code.add(p`float getSize(){
return intrinsicWidth * size;
}`)),e.vvOpacity?(t.attributes.add(d.OPACITYFEATUREATTRIBUTE,"float"),r.constants.add("vvOpacityNumber","int",8),r.uniforms.add([new bi("vvOpacityValues",i=>i.vvOpacityValues,ja),new bi("vvOpacityOpacities",i=>i.vvOpacityOpacities,ja)]),r.code.add(p`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):r.code.add(p`vec4 applyOpacity( vec4 color ){
return color;
}`),e.vvColor?(t.attributes.add(d.COLORFEATUREATTRIBUTE,"float"),r.constants.add("vvColorNumber","int",Qr),r.uniforms.add(new bi("vvColorValues",i=>i.vvColorValues,Qr)),r.uniforms.add(new Qo("vvColorColors",i=>i.vvColorColors,Qr)),r.code.add(p`vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)):(t.attributes.add(d.COLOR,"vec4"),r.code.add(p`vec4 getColor(){
return applyOpacity(color);
}`))}function md(t){return K(t)?qi:t.length===4?t:nr(gd,t[0],t[1],t[2],1)}const gd=ot();function yn(t,e){t.constants.add("stippleAlphaColorDiscard","float",.001),t.constants.add("stippleAlphaHighlightDiscard","float",.5),e.stippleEnabled?vd(t,e):_d(t)}function vd(t,e){const r=!(e.draped&&e.stipplePreferContinuous),{vertex:i,fragment:s}=t;s.include(aa),i.uniforms.add(new Ut("stipplePatternPixelSize")),e.draped||(oa(i,e),i.uniforms.add(new pe("worldToScreenPerDistanceRatio",(a,o)=>1/o.camera.perScreenPixelRatio)),i.code.add(p`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),t.varyings.add("vStippleDistance","float"),e.stippleRequiresClamp&&t.varyings.add("vStippleDistanceLimits","vec2"),e.stippleRequiresStretchMeasure&&t.varyings.add("vStipplePatternStretch","float"),i.code.add(p`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${yd};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),i.code.add(p`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),i.code.add(p`
    if (segmentLengthPseudoScreen >= ${r?"patternLength":"1e4"}) {
  `),i.uniforms.add(new pe("pixelRatio",(a,o)=>o.camera.pixelRatio)),i.code.add(p`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${e.stippleRequiresStretchMeasure?p`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);`:""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `),s.uniforms.add(new pt("stipplePatternTexture")),s.uniforms.add(new Ut("stipplePatternSDFNormalizer")),s.uniforms.add(new Ut("stipplePatternTextureSize")),s.uniforms.add(new Ut("stipplePatternPixelSizeInv")),s.code.add(p`float padTexture(float u) {
return (u * stipplePatternTextureSize + 1.0)/(stipplePatternTextureSize + 2.0);
}`),s.code.add(p`
    float getStippleSDF(out bool isClamped) {
      ${e.stippleRequiresClamp?p`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:p`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${e.stippleScaleWithLineWidth?p`u *= vLineSizeInv;`:""}
      u = padTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${e.stippleRequiresStretchMeasure?p`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:p`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${e.stippleScaleWithLineWidth?p`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:p`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `),e.stippleOffColorEnabled?(s.uniforms.add(new We("stippleOffColor",a=>md(a.stippleOffColor))),s.code.add(p`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):s.code.add(p`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function _d(t){t.fragment.code.add(p`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}const yd=p.float(.4);var _t;(function(t){t[t.BUTT=0]="BUTT",t[t.SQUARE=1]="SQUARE",t[t.ROUND=2]="ROUND",t[t.COUNT=3]="COUNT"})(_t||(_t={}));class he extends di{constructor(){super(...arguments),this.output=w.Color,this.capType=_t.BUTT,this.transparencyPassType=Oe.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.wireframe=!1}}v([R({count:w.COUNT})],he.prototype,"output",void 0),v([R({count:_t.COUNT})],he.prototype,"capType",void 0),v([R({count:Oe.COUNT})],he.prototype,"transparencyPassType",void 0),v([R()],he.prototype,"occluder",void 0),v([R()],he.prototype,"hasSlicePlane",void 0),v([R()],he.prototype,"hasPolygonOffset",void 0),v([R()],he.prototype,"writeDepth",void 0),v([R()],he.prototype,"draped",void 0),v([R()],he.prototype,"stippleEnabled",void 0),v([R()],he.prototype,"stippleOffColorEnabled",void 0),v([R()],he.prototype,"stippleScaleWithLineWidth",void 0),v([R()],he.prototype,"stipplePreferContinuous",void 0),v([R()],he.prototype,"roundJoins",void 0),v([R()],he.prototype,"vvSize",void 0),v([R()],he.prototype,"vvColor",void 0),v([R()],he.prototype,"vvOpacity",void 0),v([R()],he.prototype,"falloffEnabled",void 0),v([R()],he.prototype,"innerColorEnabled",void 0),v([R()],he.prototype,"hasOccludees",void 0),v([R()],he.prototype,"hasMultipassTerrain",void 0),v([R()],he.prototype,"cullAboveGround",void 0),v([R()],he.prototype,"wireframe",void 0),v([R({constValue:!0})],he.prototype,"stippleRequiresClamp",void 0),v([R({constValue:!0})],he.prototype,"stippleRequiresStretchMeasure",void 0),v([R({constValue:!0})],he.prototype,"hasVvInstancing",void 0),v([R({constValue:!0})],he.prototype,"hasSliceTranslatedView",void 0);const ji=1;function Sd(t){const e=new pr,r=t.hasMultipassTerrain&&(t.output===w.Color||t.output===w.Alpha);e.include(oc),e.include(fd,t),e.include(yn,t),t.output===w.Depth&&e.include(Yo,t),hi(e,t);const{vertex:i,fragment:s}=e;i.uniforms.add([new ar("inverseProjectionMatrix",(f,S)=>S.camera.inverseProjectionMatrix),new qe("nearFar",(f,S)=>S.camera.nearFar),new pe("miterLimit",f=>f.join!=="miter"?0:f.miterLimit),new We("viewport",(f,S)=>S.camera.fullViewport)]),i.constants.add("LARGE_HALF_FLOAT","float",65500),e.attributes.add(d.POSITION,"vec3"),e.attributes.add(d.SUBDIVISIONFACTOR,"float"),e.attributes.add(d.UV0,"vec2"),e.attributes.add(d.AUXPOS1,"vec3"),e.attributes.add(d.AUXPOS2,"vec3"),e.varyings.add("vColor","vec4"),e.varyings.add("vpos","vec3"),e.varyings.add("linearDepth","float"),r&&e.varyings.add("depth","float");const a=t.capType===_t.ROUND,o=t.stippleEnabled&&t.stippleScaleWithLineWidth||a;o&&e.varyings.add("vLineWidth","float");const n=t.stippleEnabled&&t.stippleScaleWithLineWidth;n&&e.varyings.add("vLineSizeInv","float");const c=t.innerColorEnabled||a;c&&e.varyings.add("vLineDistance","float");const l=t.stippleEnabled&&a,h=t.falloffEnabled||l;h&&e.varyings.add("vLineDistanceNorm","float"),a&&(e.varyings.add("vSegmentSDF","float"),e.varyings.add("vReverseSegmentSDF","float")),i.code.add(p`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),i.code.add(p`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),i.code.add(p`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${r?"depth = pos.z;":""}
      linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),i.uniforms.add(new pe("pixelRatio",(f,S)=>S.camera.pixelRatio)),i.code.add(p`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;

      ${o?p`vLineWidth = lineWidth;`:""}
      ${n?p`vLineSizeInv = 1.0 / lineSize;`:""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);

      clipAndTransform(pos, prev, next, isStartVertex);

      vec2 left = (pos.xy - prev.xy);
      vec2 right = (next.xy - pos.xy);

      float leftLen = length(left);
      float rightLen = length(right);
  `),(t.stippleEnabled||a)&&i.code.add(p`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${a?p`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),i.code.add(p`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),t.roundJoins?i.code.add(p`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${t.stippleEnabled?p`min(1.0, subdivisionFactor * ${p.float((ji+2)/(ji+1))})`:p`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):i.code.add(p`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const u=t.capType!==_t.BUTT;return i.code.add(p`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${u?p`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),i.code.add(p`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

    ${h||c?p`float lineDistNorm = sign(uv0.y) * pos.w;`:""}

    ${c?p`vLineDistance = lineWidth * lineDistNorm;`:""}
    ${h?p`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),a&&i.code.add(p`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),t.stippleEnabled&&(t.draped?i.uniforms.add(new pe("worldToScreenRatio",(f,S)=>1/S.screenToPCSRatio)):i.code.add(p`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),i.code.add(p`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),t.draped?i.code.add(p`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):i.code.add(p`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),i.code.add(p`
      float patternLength = ${t.stippleScaleWithLineWidth?"lineSize * ":""} stipplePatternPixelSize;

      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);

      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
      if (segmentLengthScreenDouble >= 0.001) {
        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
        // original vertex positions, and slightly outside of that range at the displaced positions
        vec2 stippleDisplacement = pos.xy - segmentOrigin;
        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);

        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
      }

      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
      vStippleDistanceLimits *= pos.w;
      vStippleDistance *= pos.w;

      // Disable stipple distance limits on caps
      vStippleDistanceLimits = isJoin ?
                                 vStippleDistanceLimits :
                                 isStartVertex ?
                                  vec2(-1e038, vStippleDistanceLimits.y) :
                                  vec2(vStippleDistanceLimits.x, 1e038);
    `)),i.code.add(p`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${t.wireframe&&!t.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
    }
  }
  `),r&&e.include(na,t),e.include(Nt,t),s.include(Xi),s.code.add(p`
  void main() {
    discardBySlice(vpos);
    ${r?"terrainDepthTest(gl_FragCoord, depth);":""}
  `),t.wireframe?s.code.add(p`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(a&&s.code.add(p`
      float sdf = min(vSegmentSDF, vReverseSegmentSDF);
      vec2 fragmentPosition = vec2(
        min(sdf, 0.0),
        vLineDistance
      ) * gl_FragCoord.w;

      float fragmentRadius = length(fragmentPosition);
      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

      if (capCoverage < ${p.float(rt)}) {
        discard;
      }
    `),l?s.code.add(p`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${p.float(rt)}, stippleCoverage);
      `):s.code.add(p`float stippleAlpha = getStippleAlpha();`),s.uniforms.add(new We("intrinsicColor",f=>f.color)),s.code.add(p`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);
vec4 color = intrinsicColor * vColor;`),t.innerColorEnabled&&(s.uniforms.add(new We("innerColor",f=>ne(f.innerColor,f.color))),s.uniforms.add(new pe("innerWidth",(f,S)=>f.innerWidth*S.camera.pixelRatio)),s.code.add(p`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),s.code.add(p`vec4 finalColor = blendStipple(color, stippleAlpha);`),t.falloffEnabled&&(s.uniforms.add(new pe("falloff",f=>f.falloff)),s.code.add(p`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),s.code.add(p`
    if (finalColor.a < ${p.float(rt)}) {
      discard;
    }

    ${t.output===w.Alpha?p`gl_FragColor = vec4(finalColor.a);`:""}
    ${t.output===w.Color?p`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===w.Color&&t.transparencyPassType===Oe.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    ${t.output===w.Highlight?p`gl_FragColor = vec4(1.0);`:""}
    ${t.output===w.Depth?p`outputDepth(linearDepth);`:""}
  }
  `),e}const Td=Object.freeze(Object.defineProperty({__proto__:null,NUM_ROUND_JOIN_SUBDIVISIONS:ji,build:Sd},Symbol.toStringTag,{value:"Module"})),Sn=new Map([[d.POSITION,0],[d.SUBDIVISIONFACTOR,1],[d.UV0,2],[d.AUXPOS1,3],[d.AUXPOS2,4],[d.COLOR,5],[d.COLORFEATUREATTRIBUTE,5],[d.SIZE,6],[d.SIZEFEATUREATTRIBUTE,6],[d.OPACITYFEATUREATTRIBUTE,7]]);class es extends fr{constructor(e,r,i){super(e,r,i),this.stippleTextureRepository=e.stippleTextureRepository}initializeProgram(e){const r=es.shader.get().build(this.configuration);return new mr(e.rctx,r,Sn)}destroy(){super.destroy(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,r){if(this.program.bindPass(e,r),this.stipplePattern!==e.stipplePattern){const i=e.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,i),this.stipplePattern=i}if(this.configuration.stippleEnabled){const{pixelSize:i,sdfNormalizer:s,pixels:a}=x(this.stippleTextureBind)?this.stippleTextureBind(this.program):{pixelSize:1,sdfNormalizer:1,pixels:1};this.program.setUniform1f("stipplePatternSDFNormalizer",s),this.program.setUniform1f("stipplePatternTextureSize",a),this.program.setUniform1f("stipplePatternPixelSize",i),this.program.setUniform1f("stipplePatternPixelSizeInv",1/i)}}_makePipelineState(e,r){const i=this.configuration,s=e===Oe.NONE,a=e===Oe.FrontFace;return at({blending:i.output===w.Color||i.output===w.Alpha?s?Jr:Zi(e):null,depthTest:{func:ia(e)},depthWrite:s?i.writeDepth&&$r:Wo(e),colorWrite:vt,stencilWrite:i.hasOccludees?Fi:null,stencilTest:i.hasOccludees?r?Ni:la:null,polygonOffset:s||a?i.hasPolygonOffset&&Ha:rc})}initializePipeline(){const e=this.configuration;if(e.occluder){const r=e.hasPolygonOffset&&Ha;this._occluderPipelineTransparent=at({blending:Jr,polygonOffset:r,depthTest:Ia,depthWrite:null,colorWrite:vt,stencilWrite:null,stencilTest:nc}),this._occluderPipelineOpaque=at({blending:Jr,polygonOffset:r,depthTest:Ia,depthWrite:null,colorWrite:vt,stencilWrite:lc,stencilTest:cc}),this._occluderPipelineMaskWrite=at({blending:null,polygonOffset:r,depthTest:Ko,depthWrite:null,colorWrite:null,stencilWrite:Fi,stencilTest:Ni})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?Rt.LINES:Rt.TRIANGLE_STRIP}getPipelineState(e,r){return r?this._occludeePipelineState:this.configuration.occluder?e===se.TRANSPARENT_OCCLUDER_MATERIAL?this._occluderPipelineTransparent:e===se.OCCLUDER_MATERIAL?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(e,r)}}es.shader=new gr(Td,()=>kt(()=>import("./RibbonLine.glsl.8b0033e1.js"),["assets/RibbonLine.glsl.8b0033e1.js","assets/Matrix4Uniform.9e24b035.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/floatRGBA.5328f61e.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));const Ha={factor:0,units:-4},xd=li.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial");var Xe;(function(t){t[t.LEFT_JOIN_START=-2]="LEFT_JOIN_START",t[t.LEFT_JOIN_END=-1]="LEFT_JOIN_END",t[t.LEFT_CAP_START=-4]="LEFT_CAP_START",t[t.LEFT_CAP_END=-5]="LEFT_CAP_END",t[t.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",t[t.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",t[t.RIGHT_CAP_START=4]="RIGHT_CAP_START",t[t.RIGHT_CAP_END=5]="RIGHT_CAP_END"})(Xe||(Xe={}));class Od extends ui{constructor(e){super(e,new Rd),this._vertexAttributeLocations=Sn,this.techniqueConfig=new he,this.layout=this.createLayout()}isClosed(e,r){return Tn(this.parameters,e,r)}getConfiguration(e,r){this.techniqueConfig.output=e,this.techniqueConfig.draped=r.slot===se.DRAPED_MATERIAL;const i=x(this.parameters.stipplePattern)&&e!==w.Highlight;return this.techniqueConfig.stippleEnabled=i,this.techniqueConfig.stippleOffColorEnabled=i&&x(this.parameters.stippleOffColor),this.techniqueConfig.stippleScaleWithLineWidth=i&&this.parameters.stippleScaleWithLineWidth,this.techniqueConfig.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this.techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this.techniqueConfig.hasOccludees=this.parameters.hasOccludees,this.techniqueConfig.roundJoins=this.parameters.join==="round",this.techniqueConfig.capType=this.parameters.cap,this.techniqueConfig.hasPolygonOffset=this.parameters.hasPolygonOffset,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.vvColor=this.parameters.vvColorEnabled,this.techniqueConfig.vvOpacity=this.parameters.vvOpacityEnabled,this.techniqueConfig.vvSize=this.parameters.vvSizeEnabled,this.techniqueConfig.innerColorEnabled=this.parameters.innerWidth>0&&x(this.parameters.innerColor),this.techniqueConfig.falloffEnabled=this.parameters.falloff>0,this.techniqueConfig.occluder=this.parameters.renderOccluded===Ht.OccludeAndTransparentStencil,this.techniqueConfig.transparencyPassType=r.transparencyPassType,this.techniqueConfig.hasMultipassTerrain=r.multipassTerrain.enabled,this.techniqueConfig.cullAboveGround=r.multipassTerrain.cullAboveGround,this.techniqueConfig.wireframe=this.parameters.wireframe,this.techniqueConfig}intersect(e,r,i,s,a,o,n,c,l){x(l)?this._intersectDrapedLineGeometry(e,s,l,o,n):this._intersectLineGeometry(e,r,i,s,n)}_intersectDrapedLineGeometry(e,r,i,s,a){if(!r.options.selectionMode)return;const o=e.vertexAttributes.get(d.POSITION).data,n=e.vertexAttributes.get(d.SIZE);let c=this.parameters.width;if(this.parameters.vvSizeEnabled){const O=e.vertexAttributes.get(d.SIZEFEATUREATTRIBUTE).data[0];c*=jt(this.parameters.vvSizeOffset[0]+O*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else n&&(c*=n.data[0]);const l=s[0],h=s[1],u=(c/2+4)*e.screenToWorldRatio;let f=Number.MAX_VALUE,S=0;for(let O=0;O<o.length-5;O+=3){const b=o[O],U=o[O+1],C=l-b,P=h-U,y=o[O+3]-b,_=o[O+4]-U,m=jt((y*C+_*P)/(y*y+_*_),0,1),g=y*m-C,A=_*m-P,E=g*g+A*A;E<f&&(f=E,S=O/3)}f<u*u&&a(i.dist,i.normal,S,!1)}_intersectLineGeometry(e,r,i,s,a){if(!s.options.selectionMode||Ji(r))return;if(!cn(i))return void xd.error("intersection assumes a translation-only matrix");const o=e.vertexAttributes,n=o.get(d.POSITION).data;let c=this.parameters.width;if(this.parameters.vvSizeEnabled){const C=o.get(d.SIZEFEATUREATTRIBUTE).data[0];c*=jt(this.parameters.vvSizeOffset[0]+C*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else o.has(d.SIZE)&&(c*=o.get(d.SIZE).data[0]);const l=s.camera,h=Ad;Fr(h,s.point);const u=c*l.pixelRatio/2+4*l.pixelRatio;ae(jr[0],h[0]-u,h[1]+u,0),ae(jr[1],h[0]+u,h[1]+u,0),ae(jr[2],h[0]+u,h[1]-u,0),ae(jr[3],h[0]-u,h[1]-u,0);for(let C=0;C<4;C++)if(!l.unprojectFromRenderScreen(jr[C],St[C]))return;Ft(l.eye,St[0],St[1],gs),Ft(l.eye,St[1],St[2],vs),Ft(l.eye,St[2],St[3],_s),Ft(l.eye,St[3],St[0],ys);let f=Number.MAX_VALUE,S=0;const O=qs(this.parameters,o,e.indices)?n.length-2:n.length-5;for(let C=0;C<O;C+=3){He[0]=n[C]+i[12],He[1]=n[C+1]+i[13],He[2]=n[C+2]+i[14];const P=(C+3)%n.length;if(Be[0]=n[P]+i[12],Be[1]=n[P+1]+i[13],Be[2]=n[P+2]+i[14],Ce(gs,He)<0&&Ce(gs,Be)<0||Ce(vs,He)<0&&Ce(vs,Be)<0||Ce(_s,He)<0&&Ce(_s,Be)<0||Ce(ys,He)<0&&Ce(ys,Be)<0)continue;if(l.projectToRenderScreen(He,Jt),l.projectToRenderScreen(Be,Qt),Jt[2]<0&&Qt[2]>0){xe(nt,He,Be);const _=l.frustum,m=-Ce(_[zt.NEAR],He)/At(nt,Li(_[zt.NEAR]));ce(nt,nt,m),_e(He,He,nt),l.projectToRenderScreen(He,Jt)}else if(Jt[2]>0&&Qt[2]<0){xe(nt,Be,He);const _=l.frustum,m=-Ce(_[zt.NEAR],Be)/At(nt,Li(_[zt.NEAR]));ce(nt,nt,m),_e(Be,Be,nt),l.projectToRenderScreen(Be,Qt)}else if(Jt[2]<0&&Qt[2]<0)continue;Jt[2]=0,Qt[2]=0;const y=pn(Pr(Jt,Qt,Wa),h);y<f&&(f=y,te(Ba,He),te(Ga,Be),S=C/3)}const b=s.rayBegin,U=s.rayEnd;if(f<u*u){let C=Number.MAX_VALUE;if(fn(Pr(Ba,Ga,Wa),Pr(b,U,bd),Xt)){xe(Xt,Xt,b);const P=Ot(Xt);ce(Xt,Xt,1/P),C=P/Ct(b,U)}a(C,Xt,S,!1)}}computeAttachmentOrigin(e,r){const i=e.vertexAttributes;if(!i)return null;const s=e.indices,a=i.get(d.POSITION);return ln(a,s?s.get(d.POSITION):null,s&&qs(this.parameters,i,s),r)}createLayout(){const e=pi().vec3f(d.POSITION).f32(d.SUBDIVISIONFACTOR).vec2f(d.UV0).vec3f(d.AUXPOS1).vec3f(d.AUXPOS2);return this.parameters.vvSizeEnabled?e.f32(d.SIZEFEATUREATTRIBUTE):e.f32(d.SIZE),this.parameters.vvColorEnabled?e.f32(d.COLORFEATUREATTRIBUTE):e.vec4f(d.COLOR),this.parameters.vvOpacityEnabled&&e.f32(d.OPACITYFEATUREATTRIBUTE),e}createBufferWriter(){return new Cd(this.layout,this.parameters)}requiresSlot(e,r){if(e===se.DRAPED_MATERIAL)return!0;if(this.parameters.renderOccluded===Ht.OccludeAndTransparentStencil)return e===se.OPAQUE_MATERIAL||e===se.OCCLUDER_MATERIAL||e===se.TRANSPARENT_OCCLUDER_MATERIAL;const i=ii(r);return i===w.Color||i===w.Alpha?e===(this.parameters.writeDepth?se.TRANSPARENT_MATERIAL:se.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL):e===se.OPAQUE_MATERIAL}createGLMaterial(e){return e.output===w.Color||e.output===w.Alpha||e.output===w.Highlight||e.output===w.Depth?new wd(e):null}validateParameters(e){e.join!=="miter"&&(e.miterLimit=0)}}class wd extends Qi{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output!==w.Color&&this._output!==w.Alpha||this._updateOccludeeState(e),this.ensureTechnique(es,e)}}class Rd extends dc{constructor(){super(...arguments),this.width=0,this.color=ki,this.join="miter",this.cap=_t.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class Cd{constructor(e,r){this.parameters=r,this.numJoinSubdivisions=0,this.vertexBufferLayout=e;const i=r.stipplePattern?1:0;switch(this.parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=i;break;case"round":this.numJoinSubdivisions=ji+i}}_isClosed(e){return qs(this.parameters,e.vertexAttributes,e.indices)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const i=e.indices.get(d.POSITION).length/2+1,s=this._isClosed(e);let a=s?2:2*2;return a+=((s?i:i-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),a+=2,this.parameters.wireframe&&(a=2+4*(a-2)),a}write(e,r,i,s){var N;const a=Ed,o=Pd,n=Dd,c=r.vertexAttributes.get(d.POSITION).data,l=r.indices&&r.indices.get(d.POSITION),h=(N=r.vertexAttributes.get(d.DISTANCETOSTART))==null?void 0:N.data;l&&l.length!==2*(c.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let u=1,f=0;this.parameters.vvSizeEnabled?f=r.vertexAttributes.get(d.SIZEFEATUREATTRIBUTE).data[0]:r.vertexAttributes.has(d.SIZE)&&(u=r.vertexAttributes.get(d.SIZE).data[0]);let S=[1,1,1,1],O=0;this.parameters.vvColorEnabled?O=r.vertexAttributes.get(d.COLORFEATUREATTRIBUTE).data[0]:r.vertexAttributes.has(d.COLOR)&&(S=r.vertexAttributes.get(d.COLOR).data);let b=0;this.parameters.vvOpacityEnabled&&(b=r.vertexAttributes.get(d.OPACITYFEATUREATTRIBUTE).data[0]);const U=c.length/3,C=e.transformation,P=new Float32Array(i.buffer),y=this.vertexBufferLayout.stride/4;let _=s*y;const m=_;let g=0;const A=h?(L,M,W)=>g=h[W]:(L,M,W)=>g+=Ct(L,M),E=(L,M,W,F,H,V,J)=>{if(P[_++]=M[0],P[_++]=M[1],P[_++]=M[2],P[_++]=F,P[_++]=J,P[_++]=H,P[_++]=L[0],P[_++]=L[1],P[_++]=L[2],P[_++]=W[0],P[_++]=W[1],P[_++]=W[2],this.parameters.vvSizeEnabled?P[_++]=f:P[_++]=u,this.parameters.vvColorEnabled)P[_++]=O;else{const G=Math.min(4*V,S.length-4);P[_++]=S[G+0],P[_++]=S[G+1],P[_++]=S[G+2],P[_++]=S[G+3]}this.parameters.vvOpacityEnabled&&(P[_++]=b)};_+=y,ae(o,c[0],c[1],c[2]),C&&ue(o,o,C);const D=this._isClosed(r);if(D){const L=c.length-3;ae(a,c[L],c[L+1],c[L+2]),C&&ue(a,a,C)}else ae(n,c[3],c[4],c[5]),C&&ue(n,n,C),E(o,o,n,1,Xe.LEFT_CAP_START,0,0),E(o,o,n,1,Xe.RIGHT_CAP_START,0,0),te(a,o),te(o,n);const $=D?0:1,T=D?U:U-1;for(let L=$;L<T;L++){const M=(L+1)%U*3;ae(n,c[M+0],c[M+1],c[M+2]),C&&ue(n,n,C),A(a,o,L),E(a,o,n,0,Xe.LEFT_JOIN_END,L,g),E(a,o,n,0,Xe.RIGHT_JOIN_END,L,g);const W=this.numJoinSubdivisions;for(let F=0;F<W;++F){const H=(F+1)/(W+1);E(a,o,n,H,Xe.LEFT_JOIN_END,L,g),E(a,o,n,H,Xe.RIGHT_JOIN_END,L,g)}E(a,o,n,1,Xe.LEFT_JOIN_START,L,g),E(a,o,n,1,Xe.RIGHT_JOIN_START,L,g),te(a,o),te(o,n)}D?(ae(n,c[3],c[4],c[5]),C&&ue(n,n,C),g=A(a,o,T),E(a,o,n,0,Xe.LEFT_JOIN_END,$,g),E(a,o,n,0,Xe.RIGHT_JOIN_END,$,g)):(g=A(a,o,T),E(a,o,o,0,Xe.LEFT_CAP_END,T,g),E(a,o,o,0,Xe.RIGHT_CAP_END,T,g)),ms(P,m+y,P,m,y),_=ms(P,_-y,P,_,y),this.parameters.wireframe&&this._addWireframeVertices(i,m,_,y)}_addWireframeVertices(e,r,i,s){const a=new Float32Array(e.buffer,i*Float32Array.BYTES_PER_ELEMENT),o=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT,i-r);let n=0;const c=l=>n=ms(o,l,a,n,s);for(let l=0;l<o.length-1;l+=2*s)c(l),c(l+2*s),c(l+1*s),c(l+2*s),c(l+1*s),c(l+3*s)}}function ms(t,e,r,i,s){for(let a=0;a<s;a++)r[i++]=t[e++];return i}function qs(t,e,r){return Tn(t,e.get(d.POSITION).data,r?r.get(d.POSITION):null)}function Tn(t,e,r){return!!t.isClosed&&(r?r.length>2:e.length>6)}const He=j(),Be=j(),nt=j(),Xt=j(),Ad=j(),Jt=tt(),Qt=tt(),Ba=j(),Ga=j(),Wa=Ki(),bd=Ki(),Ed=j(),Pd=j(),Dd=j(),jr=[tt(),tt(),tt(),tt()],St=[j(),j(),j(),j()],gs=bt(),vs=bt(),_s=bt(),ys=bt();function xn(t){return t.type==="point"}function On(t){return"declaredClass"in t}function qa(t){return"declaredClass"in t}function Id(t){return"declaredClass"in t}function nf(t,e){if(!t)return null;if(Id(t))return t;const r=new rl({layer:e,sourceLayer:e});return r.visible=t.visible,r.symbol=ya(t.symbol),r.attributes=ya(t.attributes),r.geometry=wn(t.geometry),r}function wn(t){return K(t)?null:On(t)?t:Yn(Md(t))}function Md(t){const e=t.spatialReference.toJSON();switch(t.type){case"point":{const{x:r,y:i,z:s,m:a}=t;return{x:r,y:i,z:s,m:a,spatialReference:e}}case"polygon":{const{rings:r,hasZ:i,hasM:s}=t;return{rings:ka(r),hasZ:i,hasM:s,spatialReference:e}}case"polyline":{const{paths:r,hasZ:i,hasM:s}=t;return{paths:ka(r),hasZ:i,hasM:s,spatialReference:e}}case"extent":{const{xmin:r,xmax:i,ymin:s,ymax:a,zmin:o,zmax:n,mmin:c,mmax:l,hasZ:h,hasM:u}=t;return{xmin:r,xmax:i,ymin:s,ymax:a,zmin:o,zmax:n,mmin:c,mmax:l,hasZ:h,hasM:u,spatialReference:e}}case"multipoint":{const{points:r,hasZ:i,hasM:s}=t;return{points:Cn(r)?Rn(r):r,hasZ:i,hasM:s,spatialReference:e}}default:return}}function ka(t){return $d(t)?t.map(e=>Rn(e)):t}function Rn(t){return t.map(e=>Kn(e))}function $d(t){for(const e of t)if(e.length!==0)return Cn(e);return!1}function Cn(t){return t.length&&(el(t[0])||tl(t[0]))}function Ld(t,e){if(!t)return null;let r;if(qa(t)){if(e==null)return t.clone();if(qa(e))return e.copy(t)}return e!=null?(r=e,r.x=t.x,r.y=t.y,r.spatialReference=t.spatialReference,t.hasZ?(r.z=t.z,r.hasZ=t.hasZ):(r.z=null,r.hasZ=!1),t.hasM?(r.m=t.m,r.hasM=!0):(r.m=null,r.hasM=!1)):(r=zr(t.x,t.y,t.z,t.spatialReference),t.hasM&&(r.m=t.m,r.hasM=!0)),r}function Fd(t,e){if(t.type==="point")return Pt(t,e,!1);if(On(t))switch(t.type){case"extent":return Pt(t.center,e,!1);case"polygon":return Pt(t.centroid,e,!1);case"polyline":return Pt(Za(t),e,!0);case"mesh":return Pt(t.origin,e,!1)}else switch(t.type){case"extent":return Pt(Nd(t),e,!0);case"polygon":return Pt(zd(t),e,!0);case"polyline":return Pt(Za(t),e,!0)}}function Za(t){const e=t.paths[0];if(!e||e.length===0)return null;const r=Uo(e,Vo(e)/2);return zr(r[0],r[1],r[2],t.spatialReference)}function Nd(t){const e=isFinite(t.zmin);return zr(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),e?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function zd(t){const e=t.rings[0];if(!e||e.length===0)return null;const r=il(t.rings,t.hasZ);return zr(r[0],r[1],r[2],t.spatialReference)}function Pt(t,e,r){const i=r?t:Ld(t);return e&&t?sl(t,i,e)?i:null:i}function lf(t,e,r,i=0){if(t){e||(e=br());const s=t;let a=.5*s.width*(r-1),o=.5*s.height*(r-1);return s.width<1e-7*s.height?a+=o/20:s.height<1e-7*s.width&&(o+=a/20),nr(e,s.xmin-a-i,s.ymin-o-i,s.xmax+a+i,s.ymax+o+i),e}return null}function Ud(t,e){for(let r=0;r<t.geometries.length;++r){const i=t.geometries[r].getMutableAttribute(d.AUXPOS1);i&&i.data[3]!==e&&(i.data[3]=e,t.geometryVertexAttrsUpdated(t.geometryRecords[r]))}}function cf(t,e){const r=al(ki);return x(t)&&(r[0]=t[0],r[1]=t[1],r[2]=t[2]),x(e)?r[3]=e:x(t)&&t.length>3&&(r[3]=t[3]),r}function df(t=cl,e,r,i=1){const s=new Array(3);if(K(e)||K(r))s[0]=1,s[1]=1,s[2]=1;else{let a,o=0;for(let n=2;n>=0;n--){const c=t[n];let l;const h=c!=null,u=n===0&&!a&&!h,f=r[n];c==="symbol-value"||u?l=f!==0?e[n]/f:1:h&&c!=="proportional"&&isFinite(c)&&(l=f!==0?c/f:1),l!=null&&(s[n]=l,a=l,o=Math.max(o,Math.abs(l)))}for(let n=2;n>=0;n--)s[n]==null?s[n]=a:s[n]===0&&(s[n]=.001*o)}for(let a=2;a>=0;a--)s[a]/=i;return ll(s)}function Vd(t){return t.isPrimitive!=null}function hf(t){return Vd(t)&&(t=[t.width,t.depth,t.height]),An(t)?null:"Symbol sizes may not be negative values"}function An(t){if(Array.isArray(t)){for(const e of t)if(!An(e))return!1;return!0}return t==null||t>=0}function uf(t,e,r,i=le()){const s=t||0,a=e||0,o=r||0;return s!==0&&dl(i,i,-s/180*Math.PI),a!==0&&hl(i,i,a/180*Math.PI),o!==0&&ul(i,i,o/180*Math.PI),i}function pf(t,e){return e.minDemResolution!=null?e.minDemResolution:ol(t)?e.minDemResolutionForPoints:.01*nl(t)}class ff{constructor(e,r=null,i=0){this.array=e,this.spatialReference=r,this.offset=i}}function bn(t){return"array"in t}function yi(t,e,r="ground"){if(xn(e))return t.getElevation(e.x,e.y,e.z||0,e.spatialReference,r);if(bn(e)){let i=e.offset;return t.getElevation(e.array[i++],e.array[i++],e.array[i]||0,ne(e.spatialReference,t.spatialReference),r)}return t.getElevation(e[0],e[1],e[2]||0,t.spatialReference,r)}function En(t,e,r,i,s,a,o,n,c,l,h){const u=Zd[h.mode];let f,S,O=0;if(Mi(t,e,r,i,c.spatialReference,s,n))return u.requiresAlignment(h)?(O=u.applyElevationAlignmentBuffer(i,s,a,o,n,c,l,h),f=a,S=o):(f=i,S=s),Mi(f,c.spatialReference,S,a,l.spatialReference,o,n)?O:void 0}function Pn(t,e,r,i,s){const a=(xn(t)?t.z:bn(t)?t.array[t.offset+2]:t[2])||0;switch(r.mode){case"on-the-ground":{const o=ne(yi(e,t,"ground"),0);return s.verticalDistanceToGround=0,s.sampledElevation=o,void(s.z=o)}case"relative-to-ground":{const o=ne(yi(e,t,"ground"),0),n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"relative-to-scene":{const o=ne(yi(e,t,"scene"),0),n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"absolute-height":{const o=r.geometryZWithOffset(a,i),n=ne(yi(e,t,"ground"),0);return s.verticalDistanceToGround=o-n,s.sampledElevation=n,void(s.z=o)}default:return pl(r.mode),void(s.z=0)}}function mf(t,e,r,i){return Pn(t,e,r,i,Ar),Ar.z}function gf(t,e,r){return e==null||r==null?t.definedChanged:e==="on-the-ground"&&r==="on-the-ground"?t.staysOnTheGround:e===r||e!=="on-the-ground"&&r!=="on-the-ground"?ks.UPDATE:t.onTheGroundChanged}function vf(t){return t==="relative-to-ground"||t==="relative-to-scene"}function _f(t){return t!=="absolute-height"}function jd(t,e,r,i,s){Pn(e,r,s,i,Ar),Ud(t,Ar.verticalDistanceToGround);const a=Ar.sampledElevation,o=ft(Xd,t.transformation);return Si[0]=e.x,Si[1]=e.y,Si[2]=Ar.z,fl(e.spatialReference,Si,o,i.spatialReference)?t.transformation=o:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function Hd(t,e,r,i,s,a){let o=0;const n=a.spatialReference;e*=3,i*=3;for(let c=0;c<s;++c){const l=t[e+0],h=t[e+1],u=t[e+2],f=ne(a.getElevation(l,h,u,n,"ground"),0);o+=f,r[i+0]=l,r[i+1]=h,r[i+2]=f,e+=3,i+=3}return o/s}function Bd(t,e,r,i,s,a,o,n){let c=0;const l=n.calculateOffsetRenderUnits(o),h=n.featureExpressionInfoContext,u=a.spatialReference;e*=3,i*=3;for(let f=0;f<s;++f){const S=t[e+0],O=t[e+1],b=t[e+2],U=ne(a.getElevation(S,O,b,u,"ground"),0);c+=U,r[i+0]=S,r[i+1]=O,r[i+2]=h==null?b+U+l:U+l,e+=3,i+=3}return c/s}function Gd(t,e,r,i,s,a,o,n){let c=0;const l=n.calculateOffsetRenderUnits(o),h=n.featureExpressionInfoContext,u=a.spatialReference;e*=3,i*=3;for(let f=0;f<s;++f){const S=t[e+0],O=t[e+1],b=t[e+2],U=ne(a.getElevation(S,O,b,u,"scene"),0);c+=U,r[i+0]=S,r[i+1]=O,r[i+2]=h==null?b+U+l:U+l,e+=3,i+=3}return c/s}function Wd(t){const e=t.meterUnitOffset,r=t.featureExpressionInfoContext;return e!==0||r!=null}function qd(t,e,r,i,s,a,o,n){const c=n.calculateOffsetRenderUnits(o),l=n.featureExpressionInfoContext;e*=3,i*=3;for(let h=0;h<s;++h){const u=t[e+0],f=t[e+1],S=t[e+2];r[i+0]=u,r[i+1]=f,r[i+2]=l==null?S+c:c,e+=3,i+=3}return 0}class kd{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var ks;(function(t){t[t.NONE=0]="NONE",t[t.UPDATE=1]="UPDATE",t[t.RECREATE=2]="RECREATE"})(ks||(ks={}));const Zd={"absolute-height":{applyElevationAlignmentBuffer:qd,requiresAlignment:Wd},"on-the-ground":{applyElevationAlignmentBuffer:Hd,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:Bd,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:Gd,requiresAlignment:()=>!0}},Xd=le(),Ar=new kd,Si=j(),Jd=li.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function Qd(t){return{cachedResult:t.cachedResult,arcade:t.arcade?{func:t.arcade.func,context:t.arcade.modules.arcadeUtils.createExecContext(null,{sr:t.arcade.context.spatialReference}),modules:t.arcade.modules}:null}}async function yf(t,e,r){const i=t&&t.expression;if(typeof i!="string")return null;const s=th(i);if(s!=null)return{cachedResult:s};const a=await ml(),o=a.arcadeUtils,n=o.createSyntaxTree(i);return o.dependsOnView(n)?(r!=null&&r.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:o.createFunction(n),context:o.createExecContext(null,{sr:e}),modules:a}}}function Yd(t,e,r){return t.arcadeUtils.createFeature(e.attributes,e.geometry,r)}function Kd(t,e){if(t!=null&&!Dn(t)){if(!e||!t.arcade)return void Jd.errorOncePerTick("Arcade support required but not provided");const r=e;r._geometry&&(r._geometry=wn(r._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function eh(t){if(t!=null){if(Dn(t))return t.cachedResult;const e=t.arcade;let r=t.arcade.modules.arcadeUtils.executeFunction(e.func,e.context);return typeof r!="number"&&(t.cachedResult=0,r=0),r}return 0}function Sf(t,e=!1){let r=t&&t.featureExpressionInfo;const i=r&&r.expression;return e||i==="0"||(r=null),r}const Tf={cachedResult:0};function Dn(t){return t.cachedResult!=null}function th(t){return t==="0"?0:null}class In{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=gl(e)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,r){const i=this.calculateOffsetRenderUnits(r);return this.featureExpressionInfoContext!=null?i:e+i}calculateOffsetRenderUnits(e){let r=this._meterUnitOffset;const i=this.featureExpressionInfoContext;return i!=null&&(r+=eh(i)*this._metersPerElevationInfoUnit),r/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=vl(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=ne(e.offset,0)}updateFeatureExpressionInfoContext(e,r,i){if(K(e))return void(this._featureExpressionInfoContext=null);const s=e&&e.arcade;s&&x(r)&&x(i)?(this._featureExpressionInfoContext=Qd(e),Kd(this._featureExpressionInfoContext,Yd(s.modules,r,i))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const r=new In;return x(e)&&r.setFromElevationInfo(e),r}}const ma=128,Mn=.5;function xf(t,e=ma,r=e*Mn,i=0){const s=rh(t,e,r,i);return new hc(s,{mipmap:!1,wrap:{s:dr.CLAMP_TO_EDGE,t:dr.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0})}function rh(t,e=ma,r=e*Mn,i=0){switch(t){case"circle":default:return ih(e,r);case"square":return sh(e,r);case"cross":return oh(e,r,i);case"x":return nh(e,r,i);case"kite":return ah(e,r);case"triangle":return lh(e,r);case"arrow":return ch(e,r)}}function ih(t,e){const r=t/2-.5;return fi(t,Fn(r,r,e/2))}function sh(t,e){return $n(t,e,!1)}function ah(t,e){return $n(t,e,!0)}function oh(t,e,r=0){return Ln(t,e,!1,r)}function nh(t,e,r=0){return Ln(t,e,!0,r)}function lh(t,e){return fi(t,Nn(t/2,e,e/2))}function ch(t,e){const r=e,i=e/2,s=t/2,a=.8*r,o=Fn(s,(t-e)/2-a,Math.sqrt(a*a+i*i)),n=Nn(s,r,i);return fi(t,(c,l)=>Math.max(n(c,l),-o(c,l)))}function $n(t,e,r){return r&&(e/=Math.SQRT2),fi(t,(i,s)=>{let a=i-.5*t+.25,o=.5*t-s-.75;if(r){const n=(a+o)/Math.SQRT2;o=(o-a)/Math.SQRT2,a=n}return Math.max(Math.abs(a),Math.abs(o))-.5*e})}function Ln(t,e,r,i=0){e-=i,r&&(e*=Math.SQRT2);const s=.5*e;return fi(t,(a,o)=>{let n,c=a-.5*t,l=.5*t-o-1;if(r){const h=(c+l)/Math.SQRT2;l=(l-c)/Math.SQRT2,c=h}return c=Math.abs(c),l=Math.abs(l),n=c>l?c>s?Math.sqrt((c-s)*(c-s)+l*l):l:l>s?Math.sqrt(c*c+(l-s)*(l-s)):c,n-=i/2,n})}function Fn(t,e,r){return(i,s)=>{const a=i-t,o=s-e;return Math.sqrt(a*a+o*o)-r}}function Nn(t,e,r){const i=Math.sqrt(e*e+r*r);return(s,a)=>{const o=Math.abs(s-t)-r,n=a-t+e/2+.75,c=(e*o+r*n)/i,l=-n;return Math.max(c,l)}}function fi(t,e){const r=new Uint8Array(4*t*t);for(let i=0;i<t;i++)for(let s=0;s<t;s++){const a=s+t*i;let o=e(s,i);o=o/t+.5,dn(o,r,4*a)}return r}function dh(t){return t instanceof Float32Array&&t.length>=16}function hh(t){return Array.isArray(t)&&t.length>=16}function uh(t){return dh(t)||hh(t)}var Hi;(function(t){t[t.Occluded=0]="Occluded",t[t.NotOccluded=1]="NotOccluded",t[t.Both=2]="Both",t[t.COUNT=3]="COUNT"})(Hi||(Hi={}));var st;function ph(t,e){t.include(en),t.attributes.add(d.POSITION,"vec3"),t.attributes.add(d.NORMAL,"vec3"),t.attributes.add(d.AUXPOS1,"vec4");const r=t.vertex;hi(t,e),oa(r,e),r.uniforms.add([new We("viewport",(i,s)=>s.camera.fullViewport),new pe("polygonOffset",i=>i.shaderPolygonOffset),new pe("cameraGroundRelative",(i,s)=>s.camera.aboveGround?1:-1),new pe("renderTransparentlyOccludedHUD",(i,s)=>s.renderTransparentlyOccludedHUD===Hi.Occluded?1:s.renderTransparentlyOccludedHUD===Hi.NotOccluded?0:.75),new Lr("hudVisibilityTexture",(i,s)=>s.hudVisibilityTexture)]),e.hasVerticalOffset&&uc(r),r.constants.add("smallOffsetAngle","float",.984807753012208),r.code.add(p`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),r.code.add(p`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
float pointGroundSign = sign(pointGroundDistance);
if (pointGroundSign == 0.0) {
pointGroundSign = cameraGroundRelative;
}
float groundRelative = cameraGroundRelative * pointGroundSign;
if (polygonOffset > .0) {
float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
float factor = (1.0 - tanAlpha / viewport[2]);
if (groundRelative > 0.0) {
posView *= factor;
}
else {
posView /= factor;
}
}
return groundRelative;
}`),e.isDraped&&!e.hasVerticalOffset||r.uniforms.add(new ar("viewNormal",(i,s)=>s.camera.viewInverseTransposeMatrix)),e.isDraped||(r.uniforms.add(new pe("perDistancePixelRatio",(i,s)=>Math.tan(s.camera.fovY/2)/(s.camera.fullViewport[2]/2))),r.code.add(p`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
float distanceToCamera = length(posView);
float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;
vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;
vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
posModel += modelOffset;
posView += viewOffset;
}`)),e.screenCenterOffsetUnitsEnabled===st.Screen&&r.uniforms.add(new pe("pixelRatio",(i,s)=>s.camera.pixelRatio)),e.hasScreenSizePerspective&&tn(r),r.code.add(p`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      // centerOffset is in view space and is used to implement world size offsetting
      // of labels with respect to objects. It also pulls the label towards the viewer
      // so that the label is visible in front of the object.
      vec3 centerOffset = auxpos1.xyz;

      // The pointGroundDistance is the distance of the geometry to the ground and is
      // negative if the point is below the ground, or positive if the point is above
      // ground.
      float pointGroundDistance = auxpos1.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.isDraped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled===st.Screen)?"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?p`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled!==st.Screen?p`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `:""}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled===st.Screen?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled===st.Screen?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `),r.code.add(p`bool testVisibilityHUD(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}(function(t){t[t.World=0]="World",t[t.Screen=1]="Screen",t[t.COUNT=2]="COUNT"})(st||(st={}));function fh(t){const e=p`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`,r=p`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`;t.vertex.code.add(e),t.vertex.code.add(r),t.fragment.code.add(e),t.fragment.code.add(r)}function mh(t){t.include(ti),t.uniforms.add([new Lr("geometryDepthTexture",(e,r)=>r.multipassGeometry.linearDepthTexture),new qe("nearFar",(e,r)=>r.camera.nearFar)]),t.code.add(p`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}class gh{constructor(){this.enabled=!1}}function vh(t,e){const{vertex:r,fragment:i}=t;e.hasMultipassGeometry&&r.include(mh),e.hasMultipassTerrain&&t.varyings.add("depth","float"),r.code.add(p`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${e.hasMultipassGeometry?p`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }`:""}

      ${e.hasMultipassTerrain?"depth = projectAux.posView.z;":""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `),e.hasMultipassTerrain&&i.include(ti),e.hasMultipassTerrain&&i.uniforms.add([new Lr("terrainDepthTexture",(s,a)=>a.multipassTerrain.linearDepthTexture),new qe("nearFar",(s,a)=>a.camera.nearFar),new qe("inverseViewport",(s,a)=>a.inverseViewport)]),i.include(aa),i.code.add(p`
  void main() {
    gl_FragColor = vec4(1, 1, 1, 1);
    ${e.hasMultipassTerrain?p`
          vec2 uv = gl_FragCoord.xy * inverseViewport;

          //Read the rgba data from the texture linear depth
          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);

          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          //Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            gl_FragColor.g = 0.5;
          }`:""}
  }
  `)}function _h(t){const e=new pr,r=t.signedDistanceFieldEnabled;if(e.include(fh),e.include(ph,t),e.include(Nt,t),t.output===w.Occlusion)return e.include(vh,t),e;const{vertex:i,fragment:s}=e;e.include(en),s.include(aa),s.include(Xi),e.include(pc,t),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2"),t.binaryHighlightOcclusionEnabled&&e.varyings.add("voccluded","float"),i.uniforms.add([new We("viewport",(l,h)=>h.camera.fullViewport),new qe("screenOffset",(l,h)=>yt(zn,2*l.screenOffset[0]*h.camera.pixelRatio,2*l.screenOffset[1]*h.camera.pixelRatio)),new qe("anchorPosition",l=>Bi(l)),new We("materialColor",l=>l.color),new pe("pixelRatio",(l,h)=>h.camera.pixelRatio)]),r&&(i.uniforms.add(new We("outlineColor",l=>l.outlineColor)),s.uniforms.add([new We("outlineColor",l=>Xa(l)?l.outlineColor:qi),new pe("outlineSize",l=>Xa(l)?l.outlineSize:0)])),t.hasScreenSizePerspective&&(fc(i),tn(i)),(t.debugDrawLabelBorder||t.binaryHighlightOcclusionEnabled)&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(d.UV0,"vec2"),e.attributes.add(d.COLOR,"vec4"),e.attributes.add(d.SIZE,"vec2"),e.attributes.add(d.AUXPOS2,"vec4"),i.code.add(p`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${t.hasScreenSizePerspective?p`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `:p`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${t.vvSize?"inputSize *= vvScale(auxpos2).xx;":""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${t.occlusionTestEnabled||t.binaryHighlightOcclusionEnabled?"bool visible = testVisibilityHUD(posProj);":""}

      ${t.binaryHighlightOcclusionEnabled?"voccluded = visible ? 0.0 : 1.0;":""}
    `);const a=p`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`,o=t.pixelSnappingEnabled?r?p`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:p`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:p`posProj += quadOffset;`;t.vvColor&&i.uniforms.add([new Qo("vvColorColors",l=>l.vvColorColors,Qr),new bi("vvColorValues",l=>l.vvColorValues,Qr)]),i.uniforms.add(new qe("textureCoordinateScaleFactor",l=>x(l.texture)&&x(l.texture.descriptor.textureCoordinateScaleFactor)?l.texture.descriptor.textureCoordinateScaleFactor:_l)),i.code.add(p`
    ${t.occlusionTestEnabled?"if (visible) {":""}
    ${a}
    ${t.vvColor?"vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    bool alphaDiscard = vcolor.a < ${p.float(rt)};
    ${r?`alphaDiscard = alphaDiscard && outlineColor.a < ${p.float(rt)};`:""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${o}
      gl_Position = posProj;
    }

    vtc = uv * textureCoordinateScaleFactor;

    ${t.debugDrawLabelBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":""}
    vsize = inputSize;
    ${t.occlusionTestEnabled?p`} else { vtc = vec2(0.0);
      ${t.debugDrawLabelBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"}`:""}
  }
  `),s.uniforms.add(new Lr("tex",l=>l.texture));const n=t.debugDrawLabelBorder?p`(isBorder > 0.0 ? 0.0 : ${p.float(Ma)})`:p.float(Ma),c=p`
    ${t.debugDrawLabelBorder?p`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`:""}

    ${r?p`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = ${p.float(ma)};
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${n} ||
          fillPixelColor.a + outlinePixelColor.a < ${p.float(rt)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        gl_FragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${n}) {
          discard;
        }

        gl_FragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:p`
          vec4 texColor = texture2D(tex, vtc, -0.5);
          if (texColor.a < ${n}) {
            discard;
          }
          gl_FragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${t.debugDrawLabelBorder?p`gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`:""}
  `;return t.output===w.Alpha&&s.code.add(p`
      void main() {
        ${c}
        gl_FragColor = vec4(gl_FragColor.a);
      }
      `),t.output===w.Color&&s.code.add(p`
    void main() {
      ${c}
      ${t.transparencyPassType===Oe.FrontFace?"gl_FragColor.rgb /= gl_FragColor.a;":""}
    }
    `),t.output===w.Highlight&&(e.include(Yi),s.code.add(p`
    void main() {
      ${c}
      ${t.binaryHighlightOcclusionEnabled?p`
          if (voccluded == 1.0) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }`:"outputHighlight();"}
    }
    `)),e}function Xa(t){return t.outlineColor[3]>0&&t.outlineSize>0}function Bi(t,e=zn){return t.textureIsSignedDistanceField?yh(t.anchorPosition,t.distanceFieldBoundingBox,e):Fr(e,t.anchorPosition),e}function yh(t,e,r){x(e)?yt(r,t[0]*(e[2]-e[0])+e[0],t[1]*(e[3]-e[1])+e[1]):yt(r,0,0)}const zn=fe(),Sh=Object.freeze(Object.defineProperty({__proto__:null,build:_h,calculateAnchorPosForRendering:Bi},Symbol.toStringTag,{value:"Module"}));class mi extends fr{initializeConfiguration(e,r){r.spherical=e.viewingMode===Bt.Global}initializeProgram(e){const r=mi.shader.get().build(this.configuration);return new mr(e.rctx,r,Nr)}_setPipelineState(e){const r=this.configuration,i=e===Oe.NONE,s=e===Oe.FrontFace,a=this.configuration.hasPolygonOffset&&Th,o=(i||s)&&r.output!==w.Highlight?(r.depthEnabled||r.output===w.Occlusion)&&$r:null;return at({blending:r.output===w.Color||r.output===w.Alpha||r.output===w.Highlight?i?xh:Zi(e):null,depthTest:{func:Qc.LEQUAL},depthWrite:o,colorWrite:vt,polygonOffset:a})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return this.configuration.output===w.Occlusion?Rt.POINTS:Rt.TRIANGLES}}mi.shader=new gr(Sh,()=>kt(()=>import("./HUDMaterial.glsl.57e8ee43.js"),["assets/HUDMaterial.glsl.57e8ee43.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/floatRGBA.5328f61e.js","assets/Matrix4Uniform.9e24b035.js","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));const Th={factor:0,units:-4},xh=ic(gt.ONE,gt.ONE_MINUS_SRC_ALPHA);class ve extends di{constructor(){super(...arguments),this.output=w.Color,this.screenCenterOffsetUnitsEnabled=st.World,this.transparencyPassType=Oe.NONE,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.binaryHighlightOcclusionEnabled=!0,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.isDraped=!1,this.hasMultipassGeometry=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}v([R({count:w.COUNT})],ve.prototype,"output",void 0),v([R({count:st.COUNT})],ve.prototype,"screenCenterOffsetUnitsEnabled",void 0),v([R({count:Oe.COUNT})],ve.prototype,"transparencyPassType",void 0),v([R()],ve.prototype,"spherical",void 0),v([R()],ve.prototype,"occlusionTestEnabled",void 0),v([R()],ve.prototype,"signedDistanceFieldEnabled",void 0),v([R()],ve.prototype,"vvSize",void 0),v([R()],ve.prototype,"vvColor",void 0),v([R()],ve.prototype,"hasVerticalOffset",void 0),v([R()],ve.prototype,"hasScreenSizePerspective",void 0),v([R()],ve.prototype,"debugDrawLabelBorder",void 0),v([R()],ve.prototype,"binaryHighlightOcclusionEnabled",void 0),v([R()],ve.prototype,"hasSlicePlane",void 0),v([R()],ve.prototype,"hasPolygonOffset",void 0),v([R()],ve.prototype,"depthEnabled",void 0),v([R()],ve.prototype,"pixelSnappingEnabled",void 0),v([R()],ve.prototype,"isDraped",void 0),v([R()],ve.prototype,"hasMultipassGeometry",void 0),v([R()],ve.prototype,"hasMultipassTerrain",void 0),v([R()],ve.prototype,"cullAboveGround",void 0),v([R({constValue:!0})],ve.prototype,"hasSliceInVertexProgram",void 0),v([R({constValue:!1})],ve.prototype,"hasVvInstancing",void 0);class Of extends ui{constructor(e){super(e,new Ih),this.techniqueConfig=new ve}getConfiguration(e,r){return this.techniqueConfig.output=e,this.techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this.techniqueConfig.hasVerticalOffset=!!this.parameters.verticalOffset,this.techniqueConfig.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen"?st.Screen:st.World,this.techniqueConfig.hasPolygonOffset=this.parameters.polygonOffset,this.techniqueConfig.isDraped=this.parameters.isDraped,this.techniqueConfig.occlusionTestEnabled=this.parameters.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this.techniqueConfig.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.parameters.vvColorEnabled,e===w.Color&&(this.techniqueConfig.debugDrawLabelBorder=!!this.parameters.debugDrawLabelBorder),e===w.Highlight&&(this.techniqueConfig.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.parameters.depthEnabled,this.techniqueConfig.transparencyPassType=r.transparencyPassType,this.techniqueConfig.hasMultipassGeometry=r.multipassGeometry.enabled,this.techniqueConfig.hasMultipassTerrain=r.multipassTerrain.enabled,this.techniqueConfig.cullAboveGround=r.multipassTerrain.cullAboveGround,this.techniqueConfig}intersect(e,r,i,s,a,o,n,c,l){x(l)?this._intersectDrapedHudGeometry(e,o,n,c,l):this._intersectHudGeometry(e,r,i,s,n,c)}_intersectDrapedHudGeometry(e,r,i,s,a){const o=e.vertexAttributes.get(d.POSITION),n=e.vertexAttributes.get(d.SIZE),c=this.parameters,l=Bi(c);let h=1,u=1;if(x(s)){const S=s(Ya);h=S[0],u=S[5]}h*=e.screenToWorldRatio,u*=e.screenToWorldRatio;const f=Ph*e.screenToWorldRatio;for(let S=0;S<o.data.length/o.size;S++){const O=S*o.size,b=o.data[O],U=o.data[O+1],C=S*n.size;let P;Dt[0]=n.data[C]*h,Dt[1]=n.data[C+1]*u,c.textureIsSignedDistanceField&&(P=c.outlineSize*e.screenToWorldRatio/2),Ja(r,b,U,Dt,f,P,c,l)&&i(a.dist,a.normal,-1,!1)}}_intersectHudGeometry(e,r,i,s,a,o){if(!s.options.selectionMode||!s.options.hud||Ji(r))return;const n=this.parameters;let c=1,l=1;if(Sa(Ts,i),x(o)){const P=o(Ya);c=P[0],l=P[5],Rh(Ts)}const h=e.vertexAttributes.get(d.POSITION),u=e.vertexAttributes.get(d.SIZE),f=e.vertexAttributes.get(d.NORMAL),S=e.vertexAttributes.get(d.AUXPOS1);Pe(h.size>=3);const O=s.point,b=s.camera,U=Bi(n);c*=b.pixelRatio,l*=b.pixelRatio;const C=this.parameters.centerOffsetUnits==="screen";for(let P=0;P<h.data.length/h.size;P++){const y=P*h.size;ae(Ie,h.data[y],h.data[y+1],h.data[y+2]),ue(Ie,Ie,i);const _=P*u.size;Dt[0]=u.data[_]*c,Dt[1]=u.data[_+1]*l,ue(Ie,Ie,b.viewMatrix);const m=P*S.size;if(ae(Je,S.data[m+0],S.data[m+1],S.data[m+2]),!C&&(Ie[0]+=Je[0],Ie[1]+=Je[1],Je[2]!==0)){const A=Je[2];Re(Je,Ie),xe(Ie,Ie,ce(Je,Je,A))}const g=P*f.size;if(ae(Hr,f.data[g],f.data[g+1],f.data[g+2]),this._normalAndViewAngle(Hr,Ts,b,xs),this._applyVerticalOffsetTransformationView(Ie,xs,b,Ss),b.applyProjection(Ie,Ne),Ne[0]>-1){Ne[0]=Math.floor(Ne[0]),Ne[1]=Math.floor(Ne[1]),C&&(Je[0]||Je[1])&&(Ne[0]+=Je[0],Je[1]!==0&&(Ne[1]+=mc(Je[1],Ss.factorAlignment)),b.unapplyProjection(Ne,Ie)),Ne[0]+=this.parameters.screenOffset[0],Ne[1]+=this.parameters.screenOffset[1],gc(Dt,Ss.factor,Dt);const A=Eh*b.pixelRatio;let E;if(n.textureIsSignedDistanceField&&(E=n.outlineSize*b.pixelRatio/2),Ja(O,Ne[0],Ne[1],Dt,A,E,n,U)){const D=s.ray;if(ue(Qa,Ie,Er(bh,b.viewMatrix)),Ne[0]=O[0],Ne[1]=O[1],b.unprojectFromRenderScreen(Ne,Ie)){const $=j();te($,D.direction);const T=1/Ot($);ce($,$,T),a(Ct(D.origin,Ie)*T,$,-1,!0,1,Qa)}}}}}computeAttachmentOrigin(e,r){const i=e.vertexAttributes;if(!i)return!1;const s=i.get(d.POSITION),a=e.indices.get(d.POSITION);return Hc(s,a,r)}createBufferWriter(){return new $h(this)}_normalAndViewAngle(e,r,i,s){return uh(r)&&(r=Sa(Ah,r)),yl(s.normal,e,r),ue(s.normal,s.normal,i.viewInverseTransposeMatrix),s.cosAngle=At(Vn,Dh),s}_updateScaleInfo(e,r,i){const s=this.parameters;x(s.screenSizePerspective)?$a(i,r,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),x(s.screenSizePerspectiveAlignment)?$a(i,r,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,r,i,s,a,o,n){const c=this._normalAndViewAngle(r,i,a,xs);return this._applyVerticalGroundOffsetView(e,c,a,n),this._applyVerticalOffsetTransformationView(n,c,a,o),this._applyPolygonOffsetView(n,c,s[3],a,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,r,i,s,a){return this._applyCenterOffsetNDC(e,r,i,s),x(a)&&te(a,s),this._applyPolygonOffsetNDC(s,r,i,s),s}_applyPolygonOffsetView(e,r,i,s,a){const o=s.aboveGround?1:-1;let n=Math.sign(i);n===0&&(n=o);const c=o*n;if(this.parameters.shaderPolygonOffset<=0)return te(a,e);const l=jt(Math.abs(r.cosAngle),.01,1),h=1-Math.sqrt(1-l*l)/l/s.viewport[2];return ce(a,e,c>0?h:1/h),a}_applyVerticalGroundOffsetView(e,r,i,s){const a=Ot(e),o=i.aboveGround?1:-1,n=.5*i.computeRenderPixelSizeAtDist(a),c=ce(Ie,r.normal,o*n);return _e(s,e,c),s}_applyVerticalOffsetTransformationView(e,r,i,s){const a=this.parameters;if(!a.verticalOffset||!a.verticalOffset.screenLength){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const l=Ot(e);this._updateScaleInfo(s,l,r.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const o=Ot(e),n=ne(a.screenSizePerspectiveAlignment,a.screenSizePerspective),c=vc(i,o,a.verticalOffset,r.cosAngle,n);return this._updateScaleInfo(s,o,r.cosAngle),ce(r.normal,r.normal,c),_e(e,e,r.normal)}_applyCenterOffsetView(e,r,i){const s=this.parameters.centerOffsetUnits!=="screen";return i!==e&&te(i,e),s&&(i[0]+=r[0],i[1]+=r[1],r[2]&&(Re(Hr,i),_e(i,i,ce(Hr,Hr,r[2])))),i}_applyCenterOffsetNDC(e,r,i,s){const a=this.parameters.centerOffsetUnits!=="screen";return s!==e&&te(s,e),a||(s[0]+=r[0]/i.fullWidth*2,s[1]+=r[1]/i.fullHeight*2),s}_applyPolygonOffsetNDC(e,r,i,s){const a=this.parameters.shaderPolygonOffset;if(e!==s&&te(s,e),a){const o=i.aboveGround?1:-1,n=o*Math.sign(r[3]);s[2]-=(n||o)*a}return s}requiresSlot(e){if(e===se.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:r,occlusionTest:i}=this.parameters;return e===(r?se.LABEL_MATERIAL:se.HUD_MATERIAL)||i&&e===se.OCCLUSION_PIXELS}createGLMaterial(e){return e.output===w.Color||e.output===w.Alpha?new Oh(e):e.output===w.Highlight?new Un(e):null}calculateRelativeScreenBounds(e,r,i=br()){return wh(this.parameters,e,r,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class Un extends _c{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(mi,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}class Oh extends Un{_isOcclusionSlot(e){return e.slot===se.OCCLUSION_PIXELS&&this._material.parameters.occlusionTest&&(this._output===w.Color||this._output===w.Alpha)}selectProgram(e){return this.ensureTechnique(mi,e,this._isOcclusionSlot(e)?w.Occlusion:this._output)}}function wh(t,e,r,i=Ch){return Fr(i,t.anchorPosition),i[0]*=-e[0],i[1]*=-e[1],i[0]+=t.screenOffset[0]*r,i[1]+=t.screenOffset[1]*r,i}function Rh(t){const e=t[0],r=t[1],i=t[2],s=t[3],a=t[4],o=t[5],n=t[6],c=t[7],l=t[8],h=1/Math.sqrt(e*e+r*r+i*i),u=1/Math.sqrt(s*s+a*a+o*o),f=1/Math.sqrt(n*n+c*c+l*l);return t[0]=e*h,t[1]=r*h,t[2]=i*h,t[3]=s*u,t[4]=a*u,t[5]=o*u,t[6]=n*f,t[7]=c*f,t[8]=l*f,t}function Ja(t,e,r,i,s,a,o,n){let c=e-s-(n[0]>0?i[0]*n[0]:0),l=c+i[0]+2*s,h=r-s-(n[1]>0?i[1]*n[1]:0),u=h+i[1]+2*s;const f=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&x(f)&&(c+=i[0]*f[0],h+=i[1]*f[1],l-=i[0]*(1-f[2]),u-=i[1]*(1-f[3]),c-=a,l+=a,h-=a,u+=a),t[0]>c&&t[0]<l&&t[1]>h&&t[1]<u}const Ss={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},Ch=fe(),Ie=j(),Hr=j(),Ne=ot(),Vn=j(),Qa=j(),Ts=ua(),Ah=ua(),bh=le(),Je=j(),xs={normal:Vn,cosAngle:0},Ya=le(),Eh=1,Ph=2,Dt=[0,0],Dh=Mr(0,0,1);class Ih extends yc{constructor(){super(...arguments),this.renderOccluded=Ht.Occlude,this.color=[1,1,1,1],this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=ea(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=[1,1,1,1],this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSizeMinSize=[1,1,1],this.vvSizeMaxSize=[100,100,100],this.vvSizeOffset=[0,0,0],this.vvSizeFactor=[1,1,1],this.vvColorEnabled=!1,this.vvColorValues=[0,0,0,0,0,0,0,0],this.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.debugDrawLabelBorder=!1,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const Mh=pi().vec3f(d.POSITION).vec3f(d.NORMAL).vec2f(d.UV0).vec4u8(d.COLOR).vec2f(d.SIZE).vec4f(d.AUXPOS1).vec4f(d.AUXPOS2);class $h{constructor(e){this.material=e,this.vertexBufferLayout=Mh}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(d.POSITION).length}write(e,r,i,s){Sc(r.indices.get(d.POSITION),r.vertexAttributes.get(d.POSITION).data,e.transformation,i.position,s,6),Tc(r.indices.get(d.NORMAL),r.vertexAttributes.get(d.NORMAL).data,e.invTranspTransformation,i.normal,s,6);{const a=r.vertexAttributes.get(d.UV0).data;let o,n,c,l;if(a==null||a.length<4){const S=this.material.parameters;o=0,n=0,c=S.texCoordScale[0],l=S.texCoordScale[1]}else o=a[0],n=a[1],c=a[2],l=a[3];c=Math.min(1.99999,c+1),l=Math.min(1.99999,l+1);const h=r.indices.get(d.POSITION).length,u=i.uv0;let f=s;for(let S=0;S<h;++S)u.set(f,0,o),u.set(f,1,n),f+=1,u.set(f,0,c),u.set(f,1,n),f+=1,u.set(f,0,c),u.set(f,1,l),f+=1,u.set(f,0,c),u.set(f,1,l),f+=1,u.set(f,0,o),u.set(f,1,l),f+=1,u.set(f,0,o),u.set(f,1,n),f+=1}xc(r.indices.get(d.COLOR),r.vertexAttributes.get(d.COLOR).data,4,i.color,s,6);{const a=r.indices.get(d.SIZE),o=r.vertexAttributes.get(d.SIZE).data,n=a.length,c=i.size;let l=s;for(let h=0;h<n;++h){const u=o[2*a[h]],f=o[2*a[h]+1];for(let S=0;S<6;++S)c.set(l,0,u),c.set(l,1,f),l+=1}}r.indices.get(d.AUXPOS1)&&r.vertexAttributes.get(d.AUXPOS1)&&La(r.indices.get(d.AUXPOS1),r.vertexAttributes.get(d.AUXPOS1).data,i.auxpos1,s,6),r.indices.get(d.AUXPOS2)&&r.vertexAttributes.get(d.AUXPOS2)&&La(r.indices.get(d.AUXPOS2),r.vertexAttributes.get(d.AUXPOS2).data,i.auxpos2,s,6)}}const Lh=pi().vec3f(d.POSITION),Fh=pi().vec3f(d.POSITION).vec2f(d.UV0),jn=pi().vec3f(d.POSITION).vec4u8(d.COLOR);class ga{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(d.POSITION).length}write(e,r,i,s){rn(r,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,i,s)}}function Nh(t){const e=new pr,r=t.output===w.Depth,i=t.hasMultipassTerrain&&(t.output===w.Color||t.output===w.Alpha);hi(e,t),e.include(ca,{hasModelTransformation:!1,linearDepth:r}),e.include(sn,t),e.attributes.add(d.POSITION,"vec3"),e.varyings.add("vpos","vec3"),i&&e.varyings.add("depth","float");const{vertex:s,fragment:a}=e;return r&&(e.include(Yo,t),s.uniforms.add(new qe("nearFar",(o,n)=>n.camera.nearFar)),e.varyings.add("linearDepth","float")),s.code.add(p`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${i?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${r?p`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);`:p`transformPosition(proj, view, vpos);`}
    }
  `),e.include(Nt,t),i&&e.include(na,t),a.include(Xi),a.uniforms.add(new We("eColor",o=>o.color)),t.output===w.Highlight&&e.include(Yi),a.code.add(p`
  void main() {
    discardBySlice(vpos);
    ${i?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 fColor = ${t.hasVertexColors?"vColor * eColor;":"eColor;"}

    if (fColor.a < ${p.float(rt)}) {
      discard;
    }

    ${t.output===w.Alpha?p`gl_FragColor = vec4(fColor.a);`:""}

    ${t.output===w.Color?p`gl_FragColor = highlightSlice(fColor, vpos); ${t.transparencyPassType===Oe.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${t.output===w.Highlight?p`outputHighlight();`:""};
    ${t.output===w.Depth?p`outputDepth(linearDepth);`:""};
  }
  `),e}const zh=Object.freeze(Object.defineProperty({__proto__:null,build:Nh},Symbol.toStringTag,{value:"Module"}));class ts extends fr{initializeProgram(e){const r=ts.shader.get().build(this.configuration);return new mr(e.rctx,r,Nr)}_createPipeline(e,r){const i=this.configuration,s=e===Oe.NONE,a=e===Oe.FrontFace;return at({blending:i.output!==w.Color&&i.output!==w.Alpha||!i.transparent?null:s?Jr:Zi(e),culling:sc(i.cullFace),depthTest:{func:ia(e)},depthWrite:s||a?i.writeDepth&&$r:null,colorWrite:vt,stencilWrite:i.hasOccludees?Fi:null,stencilTest:i.hasOccludees?r?Ni:la:null,polygonOffset:s||a?i.polygonOffset&&Uh:qo(i.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._createPipeline(this.configuration.transparencyPassType,!0),this._createPipeline(this.configuration.transparencyPassType,!1)}getPipelineState(e,r){return r?this._occludeePipelineState:super.getPipelineState(e,r)}}ts.shader=new gr(zh,()=>kt(()=>import("./ColorMaterial.glsl.bcd64a14.js"),["assets/ColorMaterial.glsl.bcd64a14.js","assets/Matrix4Uniform.9e24b035.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/floatRGBA.5328f61e.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));const Uh={factor:1,units:1};class Ye extends di{constructor(){super(...arguments),this.output=w.Color,this.cullFace=sa.None,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=Oe.NONE,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}v([R({count:w.COUNT})],Ye.prototype,"output",void 0),v([R({count:sa.COUNT})],Ye.prototype,"cullFace",void 0),v([R()],Ye.prototype,"hasSlicePlane",void 0),v([R()],Ye.prototype,"hasVertexColors",void 0),v([R()],Ye.prototype,"transparent",void 0),v([R()],Ye.prototype,"polygonOffset",void 0),v([R()],Ye.prototype,"enableOffset",void 0),v([R()],Ye.prototype,"writeDepth",void 0),v([R()],Ye.prototype,"hasOccludees",void 0),v([R({count:Oe.COUNT})],Ye.prototype,"transparencyPassType",void 0),v([R()],Ye.prototype,"hasMultipassTerrain",void 0),v([R()],Ye.prototype,"cullAboveGround",void 0);class wf extends ui{constructor(e){super(e,new jh),this.supportsEdges=!0,this._configuration=new Ye}getConfiguration(e,r){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.enableOffset=r.camera.relativeElevation<ko,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration}intersect(e,r,i,s,a,o,n){an(e,r,s,a,o,void 0,n)}requiresSlot(e,r){return e===se.DRAPED_MATERIAL?!0:ii(r)===w.Highlight?e===se.OPAQUE_MATERIAL:e===(this.parameters.transparent?this.parameters.writeDepth?se.TRANSPARENT_MATERIAL:se.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:se.OPAQUE_MATERIAL)}createGLMaterial(e){return e.output===w.Color||e.output===w.Alpha||e.output===w.Highlight||e.output===w.Depth&&this.parameters.writeLinearDepth?new Vh(e):null}createBufferWriter(){return new ga(jn)}}class Vh extends Qi{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output!==w.Color&&this._output!==w.Alpha||this._updateOccludeeState(e),this.ensureTechnique(ts,e)}}class jh extends da{constructor(){super(...arguments),this.color=qi,this.transparent=!1,this.writeDepth=!0,this.writeLinearDepth=!1,this.hasVertexColors=!1,this.polygonOffset=!1,this.hasSlicePlane=!1,this.cullFace=sa.None,this.hasOccludees=!1}}const Me={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},Hh={dash:Me.dash,"dash-dot":[...Me.dash,...Me.dot],dot:Me.dot,"long-dash":Me["long-dash"],"long-dash-dot":[...Me["long-dash"],...Me.dot],"long-dash-dot-dot":[...Me["long-dash"],...Me.dot,...Me.dot],none:null,"short-dash":Me["short-dash"],"short-dash-dot":[...Me["short-dash"],...Me["short-dot"]],"short-dash-dot-dot":[...Me["short-dash"],...Me["short-dot"],...Me["short-dot"]],"short-dot":Me["short-dot"],solid:null},Bh=8;function Gh(t,e=2){return K(t)?t:{pattern:t.slice(),pixelRatio:e}}function Rf(t,e=2){return{pattern:[t,t],pixelRatio:e}}function Cf(t){return x(t)&&t.type==="style"?Wh(t.style):null}function Wh(t){return x(t)?Gh(Hh[t],Bh):null}var Kr,Zs;(function(t){t[t.RasterImage=0]="RasterImage",t[t.Features=1]="Features"})(Kr||(Kr={})),function(t){t[t.WithRasterImage=0]="WithRasterImage",t[t.WithoutRasterImage=1]="WithoutRasterImage"}(Zs||(Zs={}));var et;(function(t){var e,r;(e=t.Geometry||(t.Geometry={}))[e.ADD=1]="ADD",e[e.UPDATE=2]="UPDATE",e[e.REMOVE=4]="REMOVE",(r=t.State||(t.State={}))[r.VISIBILITIES=1]="VISIBILITIES",r[r.VERTEXATTRS=2]="VERTEXATTRS",r[r.TRANSFORMATION=4]="TRANSFORMATION",r[r.HIGHLIGHTS=8]="HIGHLIGHTS",r[r.OCCLUDEES=16]="OCCLUDEES"})(et||(et={}));const Af=1.2,bf=qi,qh=ki;let me=class extends ta{constructor(){super(...arguments),this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR=!1,this.DECONFLICTOR_SHOW_VISIBLE=!1,this.DECONFLICTOR_SHOW_INVISIBLE=!1,this.DECONFLICTOR_SHOW_GRID=!1,this.LABELS_SHOW_BORDER=!1,this.TEXT_SHOW_BASELINE=!1,this.TEXT_SHOW_BORDER=!1,this.OVERLAY_DRAW_DEBUG_TEXTURE=!1,this.OVERLAY_SHOW_CENTER=!1,this.SHOW_POI=!1,this.TESTS_DISABLE_OPTIMIZATIONS=!1,this.TESTS_DISABLE_FAST_UPDATES=!1,this.DRAW_MESH_GEOMETRY_NORMALS=!1,this.FEATURE_TILE_FETCH_SHOW_TILES=!1,this.FEATURE_TILE_TREE_SHOW_TILES=!1,this.TERRAIN_TILE_TREE_SHOW_TILES=!1,this.I3S_TREE_SHOW_TILES=!1,this.I3S_SHOW_MODIFICATIONS=!1,this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES=!1,this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL=!1,this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES=!1,this.LINE_WIREFRAMES=!1}};v([ie()],me.prototype,"SCENEVIEW_HITTEST_RETURN_INTERSECTOR",void 0),v([ie()],me.prototype,"DECONFLICTOR_SHOW_VISIBLE",void 0),v([ie()],me.prototype,"DECONFLICTOR_SHOW_INVISIBLE",void 0),v([ie()],me.prototype,"DECONFLICTOR_SHOW_GRID",void 0),v([ie()],me.prototype,"LABELS_SHOW_BORDER",void 0),v([ie()],me.prototype,"TEXT_SHOW_BASELINE",void 0),v([ie()],me.prototype,"TEXT_SHOW_BORDER",void 0),v([ie()],me.prototype,"OVERLAY_DRAW_DEBUG_TEXTURE",void 0),v([ie()],me.prototype,"OVERLAY_SHOW_CENTER",void 0),v([ie()],me.prototype,"SHOW_POI",void 0),v([ie()],me.prototype,"TESTS_DISABLE_OPTIMIZATIONS",void 0),v([ie()],me.prototype,"TESTS_DISABLE_FAST_UPDATES",void 0),v([ie()],me.prototype,"DRAW_MESH_GEOMETRY_NORMALS",void 0),v([ie()],me.prototype,"FEATURE_TILE_FETCH_SHOW_TILES",void 0),v([ie()],me.prototype,"FEATURE_TILE_TREE_SHOW_TILES",void 0),v([ie()],me.prototype,"TERRAIN_TILE_TREE_SHOW_TILES",void 0),v([ie()],me.prototype,"I3S_TREE_SHOW_TILES",void 0),v([ie()],me.prototype,"I3S_SHOW_MODIFICATIONS",void 0),v([ie()],me.prototype,"LOD_INSTANCE_RENDERER_DISABLE_UPDATES",void 0),v([ie()],me.prototype,"LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL",void 0),v([ie()],me.prototype,"EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",void 0),v([ie()],me.prototype,"LINE_WIREFRAMES",void 0),me=v([ra("esri.views.3d.support.DebugFlags")],me);const Ka=new me;var Dr,eo,to,ro,Te,io;(function(t){t[t.INNER=0]="INNER",t[t.OUTER=1]="OUTER"})(Dr||(Dr={})),function(t){t[t.REGULAR=0]="REGULAR",t[t.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",t[t.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",t[t.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}(eo||(eo={})),function(t){t[t.NORTH=0]="NORTH",t[t.NORTH_EAST=1]="NORTH_EAST",t[t.EAST=2]="EAST",t[t.SOUTH_EAST=3]="SOUTH_EAST",t[t.SOUTH=4]="SOUTH",t[t.SOUTH_WEST=5]="SOUTH_WEST",t[t.WEST=6]="WEST",t[t.NORTH_WEST=7]="NORTH_WEST"}(to||(to={})),function(t){t[t.OFF=0]="OFF",t[t.ON=1]="ON"}(ro||(ro={})),function(t){t[t.Color=0]="Color",t[t.ColorNoRasterImage=1]="ColorNoRasterImage",t[t.Highlight=2]="Highlight",t[t.Water=3]="Water",t[t.Occluded=4]="Occluded"}(Te||(Te={})),function(t){t[t.FADING=0]="FADING",t[t.IMMEDIATE=1]="IMMEDIATE",t[t.UNFADED=2]="UNFADED"}(io||(io={}));class kh{constructor(e,r){this.vec3=e,this.id=r}}function Di(t,e,r,i){return new kh(Mr(t,e,r),i)}var ei;(function(t){t[t.None=0]="None",t[t.ColorAndWater=1]="ColorAndWater",t[t.Highlight=2]="Highlight",t[t.Occluded=3]="Occluded"})(ei||(ei={}));class so{constructor(e,r){this.index=e,this.renderTargets=r,this._extent=br(),this.resolution=0,this.renderLocalOrigin=Di(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new Zh,this.validTargets=null,this.hasDrapedFeatureSource=!1,this.hasDrapedRasterSource=!1,this.hasTargetWithoutRasterImage=!1,this.index=e,this.validTargets=new Array(r.renderTargets.length).fill(!1)}get extent(){return this._extent}getValidTexture(e){return this.validTargets[e]?this.renderTargets.getTarget(e).getTexture():null}get _needsColorWithoutRasterImage(){return this.hasDrapedRasterSource&&this.hasDrapedFeatureSource&&this.hasTargetWithoutRasterImage}getColorTexture(e){const r=e===ei.ColorAndWater?this.renderTargets.getTarget(Te.Color):e===ei.Highlight?this.renderTargets.getTarget(Te.Highlight):this.renderTargets.getTarget(Te.Occluded);return r?r.getTexture():null}getColorTextureNoRasterImage(){return this._needsColorWithoutRasterImage?this.getValidTexture(Te.ColorNoRasterImage):this.hasDrapedFeatureSource?this.getValidTexture(Te.Color):null}getNormalTexture(e){const r=e===ei.ColorAndWater?this.renderTargets.getTarget(Te.Water):null;return r?r.getTexture():null}draw(e,r){const i=this.computeRenderTargetValidityBitfield();for(const s of this.renderTargets.renderTargets)s.type!==Te.ColorNoRasterImage||this._needsColorWithoutRasterImage?this.validTargets[s.type]=e.drawTarget(this,s,r):this.validTargets[s.type]=!1;return i^this.computeRenderTargetValidityBitfield()?Da.CHANGED:Da.UNCHANGED}computeRenderTargetValidityBitfield(){const e=this.validTargets;return+e[Te.Color]|+e[Te.ColorNoRasterImage]<<1|+e[Te.Highlight]<<2|+e[Te.Water]<<3|+e[Te.Occluded]<<4}setupGeometryViewsCyclical(e){this.setupGeometryViewsDirect();const r=.001*e.range;if(this._extent[0]-r<=e.min){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Ta(this._extent,e.range,0,i)}if(this._extent[2]+r>=e.max){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Ta(this._extent,-e.range,0,i)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,Sl(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let e=0;e<this.canvasGeometries.numViews;e++){const r=this.canvasGeometries.extents[e];if(r[0]!==r[2]&&r[1]!==r[3])return!0}return!1}applyViewport(e){e.setViewport(this.index===Dr.INNER?0:this.resolution,0,this.resolution,this.resolution)}}class Zh{constructor(){this.extents=[br(),br(),br()],this.numViews=0}}class Hn{constructor(e,r){this.size=Tl(),this._fbo=null,this._fbo=new Yr(e,{colorTarget:pa.TEXTURE,depthStencilTarget:fa.NONE},{target:or.TEXTURE_2D,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,wrapMode:dr.CLAMP_TO_EDGE,samplingMode:ri.LINEAR_MIPMAP_LINEAR,hasMipmap:r,maxAnisotropy:8,width:0,height:0})}dispose(){this._fbo=Fe(this._fbo)}getTexture(){return this._fbo?this._fbo.colorTexture:null}isValid(){return this._fbo!==null}resize(e,r){this.size[0]=e,this.size[1]=r,this._fbo.resize(this.size[0],this.size[1])}bind(e){e.bindFramebuffer(this._fbo)}generateMipMap(){this._fbo.colorTexture.descriptor.hasMipmap&&this._fbo.colorTexture.generateMipmap()}disposeRenderTargetMemory(){var e;(e=this._fbo)==null||e.resize(0,0)}get gpuMemoryUsage(){var e,r;return(r=(e=this._fbo)==null?void 0:e.gpuMemoryUsage)!=null?r:0}}class Xh{constructor(e){const r=(i,s,a=!0)=>({type:s,fbo:new Hn(e,a),renderPass:i,valid:!1,lastUsed:1/0});this.renderTargets=[r(ye.MATERIAL,Te.Color),r(ye.MATERIAL,Te.ColorNoRasterImage),r(ye.MATERIAL_HIGHLIGHT,Te.Highlight,!1),r(ye.MATERIAL_NORMAL,Te.Water),r(ye.MATERIAL,Te.Occluded)]}getTarget(e){return this.renderTargets[e].fbo}dispose(){for(const e of this.renderTargets)e.fbo.dispose()}disposeRenderTargetMemory(){for(const e of this.renderTargets)e.fbo.disposeRenderTargetMemory()}validateUsageForTarget(e,r,i){if(e)r.lastUsed=i;else if(i-r.lastUsed>Jh)r.fbo.disposeRenderTargetMemory(),r.lastUsed=1/0;else if(r.lastUsed<1/0)return!0;return!1}get gpuMemoryUsage(){return this.renderTargets.reduce((e,r)=>e+r.fbo.gpuMemoryUsage,0)}}const Jh=1e3;class Qh{constructor(e){this._context=e,this._perConstructorInstances=new un,this._frameCounter=0,this._keepAliveFrameCount=ao}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}dispose(){this._perConstructorInstances.forEach(e=>e.forEach(r=>r.technique.destroy())),this._perConstructorInstances.clear()}acquire(e,r){const i=r.key;let s=this._perConstructorInstances.get(e,i);if(K(s)){const a=new e(this._context,r,()=>this.release(a));s=new Yh(a),this._perConstructorInstances.set(e,i,s)}return++s.refCount,s.technique}releaseAndAcquire(e,r,i){if(x(i)){if(r.key===i.key)return i;this.release(i)}return this.acquire(e,r)}release(e){if(K(e)||this._perConstructorInstances.empty)return;const r=this._perConstructorInstances.get(e.constructor,e.key);K(r)||(--r.refCount,r.refCount===0&&(r.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==ao&&this._perConstructorInstances.forEach((e,r)=>{e.forEach((i,s)=>{i.refCount===0&&i.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(i.technique.destroy(),this._perConstructorInstances.delete(r,s))})})}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach((r,i)=>{const s=async(a,o)=>{const n=o.shader;n&&(await n.reload(),a.forEach(c=>{c.technique.reload(this._context)}))};e.push(s(r,i))}),await Promise.all(e)}}class Yh{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}}const ao=-1,Kh=t=>{class e extends t{constructor(){super(...arguments),this._isDisposed=!1}dispose(){var i;for(const s of(i=this._managedDisposables)!=null?i:[]){const a=this[s];this[s]=null,a&&typeof a.dispose=="function"&&a.dispose()}this._isDisposed=!0}get isDisposed(){return this._isDisposed}}return e};function oo(){return(t,e)=>{var r,i;t.hasOwnProperty("_managedDisposables")||(t._managedDisposables=(i=(r=t._managedDisposables)==null?void 0:r.slice())!=null?i:[]),t._managedDisposables.unshift(e)}}const eu=li.getLogger("esri.views.3d.webgl-engine.lib.Camera");class gi{constructor(e=null,r=null,i=null){this._viewUp=j(),this._viewForward=j(),this._viewRight=j(),this._ray=$t(),this._viewport=$i(0,0,1,1),this._padding=$i(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=ea(1,1e3),this._viewDirty=!0,this._viewMatrix=le(),this._projectionDirty=!0,this._projectionMatrix=le(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=le(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=le(),this._inverseProjectionDirty=!0,this._inverseProjectionMatrix=null,this._frustumDirty=!0,this._frustum=id(),this._fullViewport=ot(),this._pixelRatio=1,this.relativeElevation=0,x(e)&&te(this._ray.origin,e),this._center=x(r)?Ii(r):j(),this._up=x(i)?Ii(i):Mr(0,0,1)}get pixelRatio(){return this._pixelRatio}set pixelRatio(e){this._pixelRatio=e>0?e:1}get eye(){return this._ray.origin}set eye(e){this._compareAndSetView(e,this._ray.origin)}get center(){return this._center}set center(e){this._compareAndSetView(e,this._center)}get ray(){return xe(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(e){this._compareAndSetView(e,this._up)}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(e){ft(this._viewMatrix,e),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),this._viewForward}get viewUp(){return this._ensureViewClean(),this._viewUp}get viewRight(){return this._ensureViewClean(),this._viewRight}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(e){this._nearFar[0]!==e&&(this._nearFar[0]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get far(){return this._nearFar[1]}set far(e){this._nearFar[1]!==e&&(this._nearFar[1]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get viewport(){return this._viewport}set viewport(e){this.x=e[0],this.y=e[1],this.width=e[2],this.height=e[3]}get x(){return this._viewport[0]}set x(e){e+=this._padding[Y.LEFT],this._viewport[0]!==e&&(this._viewport[0]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get y(){return this._viewport[1]}set y(e){e+=this._padding[Y.BOTTOM],this._viewport[1]!==e&&(this._viewport[1]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get width(){return this._viewport[2]}set width(e){this._viewport[2]!==e&&(this._viewport[2]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get height(){return this._viewport[3]}set height(e){this._viewport[3]!==e&&(this._viewport[3]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get fullWidth(){return this._viewport[2]+this._padding[Y.RIGHT]+this._padding[Y.LEFT]}set fullWidth(e){this.width=e-(this._padding[Y.RIGHT]+this._padding[Y.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[Y.TOP]+this._padding[Y.BOTTOM]}set fullHeight(e){this.height=e-(this._padding[Y.TOP]+this._padding[Y.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[Y.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[Y.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get aspect(){return this.width/this.height}get padding(){return this._padding}set padding(e){this._padding[Y.TOP]===e[Y.TOP]&&this._padding[Y.RIGHT]===e[Y.RIGHT]&&this._padding[Y.BOTTOM]===e[Y.BOTTOM]&&this._padding[Y.LEFT]===e[Y.LEFT]||(this._viewport[0]+=e[Y.LEFT]-this._padding[Y.LEFT],this._viewport[1]+=e[Y.BOTTOM]-this._padding[Y.BOTTOM],this._viewport[2]-=e[Y.RIGHT]+e[Y.LEFT]-(this._padding[Y.RIGHT]+this._padding[Y.LEFT]),this._viewport[3]-=e[Y.TOP]+e[Y.BOTTOM]-(this._padding[Y.TOP]+this._padding[Y.BOTTOM]),vi(this._padding,e),this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get viewProjectionMatrix(){return this._viewProjectionDirty&&(lr(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){if(this._projectionDirty){const e=this.width,r=this.height,i=this.near*Math.tan(this.fovY/2),s=i*this.aspect;xl(this._projectionMatrix,-s*(1+2*this._padding[Y.LEFT]/e),s*(1+2*this._padding[Y.RIGHT]/e),-i*(1+2*this._padding[Y.BOTTOM]/r),i*(1+2*this._padding[Y.TOP]/r),this.near,this.far),this._projectionDirty=!1}return this._projectionMatrix}get inverseProjectionMatrix(){return K(this._inverseProjectionMatrix)&&(this._inverseProjectionMatrix=le()),this._inverseProjectionDirty&&Er(this._inverseProjectionMatrix,this.projectionMatrix),this._inverseProjectionMatrix}set projectionMatrix(e){ft(this._projectionMatrix,e),this._projectionDirty=!1,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fov(){return this._fov}set fov(e){this._fov=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return Gc(this._fov,this.width,this.height)}set fovX(e){this._fov=Wc(e,this.width,this.height),this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return qc(this._fov,this.width,this.height)}set fovY(e){this._fov=kc(e,this.width,this.height),this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return Ct(this._center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(Er(this._viewInverseTransposeMatrix,this.viewMatrix),jo(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(e){const r=2*e-1;return 2*this.near*this.far/(this.far+this.near-r*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this._pixelRatio}get aboveGround(){return this.relativeElevation&&this.relativeElevation>=0}copyFrom(e){te(this._ray.origin,e.eye),te(this._center,e.center),te(this._up,e.up),vi(this._viewport,e.viewport),vi(this._padding,e.padding),Fr(this._nearFar,e.nearFar),this._fov=e.fov,this.relativeElevation=e.relativeElevation;const r=e;return this._viewDirty=r._viewDirty,this._viewDirty||(ft(this._viewMatrix,e.viewMatrix),te(this._viewRight,e.viewRight),te(this._viewUp,e.viewUp),te(this._viewForward,e.viewForward)),r._projectionDirty?this._projectionDirty=!0:(ft(this._projectionMatrix,e.projectionMatrix),this._projectionDirty=!1),this._viewProjectionDirty=!0,this._inverseProjectionDirty=!0,this._frustumDirty=r._frustumDirty,this._frustumDirty||(sd(this._frustum,e.frustum),this._frustumDirty=!1),r._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(ft(this._viewInverseTransposeMatrix,e.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),vi(this._fullViewport,e.fullViewport),this._pixelRatio=e.pixelRatio,this}copyViewFrom(e){this.eye=e.eye,this.center=e.center,this.up=e.up}clone(){return new gi().copyFrom(this)}equals(e){return Zr(this.eye,e.eye)&&Zr(this._center,e.center)&&Zr(this._up,e.up)&&xa(this._viewport,e.viewport)&&xa(this._padding,e.padding)&&Ol(this._nearFar,e.nearFar)&&this._fov===e.fov&&this._pixelRatio===e.pixelRatio&&this.relativeElevation===e.relativeElevation}almostEquals(e){if(this._pixelRatio!==e.pixelRatio||Math.abs(e.fov-this._fov)>=.001)return!1;const r=5e-4,i=1-1e-10;Oa($e,e.eye,e.center),Oa(Os,this.eye,this._center);const s=At($e,Os),a=wa($e),o=wa(Os);return s*s>=i*a*o&&wl(e.eye,this.eye)<Math.max(a,o)*r*r&&Ra(e.padding,this._padding)<.5&&Ra(e.viewport,this._viewport)<.5}computeRenderPixelSizeAt(e){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(e))}computeRenderPixelSizeAtDist(e){return e*this.perRenderPixelRatio}computeScreenPixelSizeAt(e){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(e))}_viewDirectionDistance(e){return Math.abs(ec(this.viewForward,xe($e,e,this.eye)))}computeScreenPixelSizeAtDist(e){return e*this.perScreenPixelRatio}computeDistanceFromRadius(e,r){return e/Math.tan(Math.min(this.fovX,this.fovY)/(2*(r||1)))}getScreenCenter(e=Rl()){return e[0]=(this.padding[Y.LEFT]+this.width/2)/this._pixelRatio,e[1]=(this.padding[Y.TOP]+this.height/2)/this._pixelRatio,e}getRenderCenter(e,r=.5,i=.5){return e[0]=this.padding[Y.LEFT]+this.width*r,e[1]=this.padding[Y.BOTTOM]+this.height*i,e[2]=.5,e}setGLViewport(e){const r=this.viewport,i=this.padding;e.setViewport(r[0]-i[3],r[1]-i[2],r[2]+i[1]+i[3],r[3]+i[0]+i[2])}applyProjection(e,r){e!==Z&&te(Z,e),Z[3]=1,Cr(Z,Z,this.projectionMatrix);const i=Math.abs(Z[3]);ce(Z,Z,1/i);const s=this.fullViewport;r[0]=rr(0,s[0]+s[2],.5+.5*Z[0]),r[1]=rr(0,s[1]+s[3],.5+.5*Z[1]),r[2]=.5*(Z[2]+1),r[3]=i}unapplyProjection(e,r){const i=this.fullViewport;Z[0]=(e[0]/(i[0]+i[2])*2-1)*e[3],Z[1]=(e[1]/(i[1]+i[3])*2-1)*e[3],Z[2]=(2*e[2]-1)*e[3],Z[3]=e[3],Cr(Z,Z,this.inverseProjectionMatrix),r[0]=Z[0],r[1]=Z[1],r[2]=Z[2]}projectToScreen(e,r){this.projectToRenderScreen(e,ws),this.renderToScreen(ws,r)}projectToRenderScreen(e,r){if(Z[0]=e[0],Z[1]=e[1],Z[2]=e[2],Z[3]=1,Cr(Z,Z,this.viewProjectionMatrix),Z[3]===0)return null;ce(Z,Z,1/Math.abs(Z[3]));const i=this.fullViewport;return"x"in r?(r.x=rr(0,i[0]+i[2],.5+.5*Z[0]),r.y=rr(0,i[1]+i[3],.5+.5*Z[1])):(r[0]=rr(0,i[0]+i[2],.5+.5*Z[0]),r[1]=rr(0,i[1]+i[3],.5+.5*Z[1]),r.length>2&&(r[2]=.5*(Z[2]+1))),r}unprojectFromScreen(e,r){return this.unprojectFromRenderScreen(this.screenToRender(e,ws),r)}unprojectFromRenderScreen(e,r){if(lr(Ti,this.projectionMatrix,this.viewMatrix),!Er(Ti,Ti))return null;const i=this.fullViewport;return Z[0]=2*(e[0]-i[0])/i[2]-1,Z[1]=2*(e[1]-i[1])/i[3]-1,Z[2]=2*e[2]-1,Z[3]=1,Cr(Z,Z,Ti),Z[3]===0?null:(r[0]=Z[0]/Z[3],r[1]=Z[1]/Z[3],r[2]=Z[2]/Z[3],r)}constrainWindowSize(e,r,i,s=i){const a=e*this._pixelRatio,o=r*this._pixelRatio,n=Math.max(a-i/2,0),c=Math.max(this.fullHeight-o-s/2,0),l=-Math.min(a-i/2,0),h=-Math.min(this.fullHeight-o-s/2,0);return[n,c,i-l- -Math.min(this.fullWidth-a-i/2,0),s-h- -Math.min(o-s/2,0)]}computeUp(e){e===Bt.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(e,r){const i=e[0]*this._pixelRatio,s=this.fullHeight-e[1]*this._pixelRatio;return r[0]=i,r[1]=s,r}renderToScreen(e,r){const i=e[0]/this._pixelRatio,s=(this.fullHeight-e[1])/this._pixelRatio;r[0]=i,r[1]=s}_computeUpGlobal(){xe($e,this.center,this.eye);const e=Ot(this.center);e<1?(ae(this._up,0,0,1),this._markViewDirty()):Math.abs(At($e,this.center))>.9999*Ot($e)*e||(ut(this._up,$e,this.center),ut(this._up,this._up,$e),Re(this._up,this._up),this._markViewDirty())}_computeUpLocal(){Cl($e,this.eye,this.center),Math.abs($e[2])<=.9999&&(ce($e,$e,$e[2]),ae(this._up,-$e[0],-$e[1],1-$e[2]),Re(this._up,this._up),this._markViewDirty())}_compareAndSetView(e,r){typeof e[0]=="number"&&isFinite(e[0])&&typeof e[1]=="number"&&isFinite(e[1])&&typeof e[2]=="number"&&isFinite(e[2])?Zr(e,r)||(te(r,e),this._markViewDirty()):eu.warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(ad(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(Ho(this._viewMatrix,this.eye,this._center,this._up),ae(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),ae(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),ae(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}}const Z=ot(),Ti=le(),$e=j(),Os=j(),ws=tt();var Y;(function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"})(Y||(Y={}));const tu=li.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository");class ru{constructor(e,r,i,s){this._textureRepository=e,this._techniqueRepository=r,this.materialChanged=i,this.requestRender=s,this._id2glMaterialRef=new un}dispose(){this._textureRepository.dispose()}acquire(e,r){this._ownMaterial(e);let i=this._id2glMaterialRef.get(r,e.id);if(K(i)){const s=e.createGLMaterial({material:e,techniqueRep:this._techniqueRepository,textureRep:this._textureRepository,output:r});i=new iu(s),this._id2glMaterialRef.set(r,e.id,i)}return i.ref(),i.glMaterial}release(e,r){const i=this._id2glMaterialRef.get(r,e.id);x(i)&&(i.unref(),i.referenced||(Fe(i.glMaterial),this._id2glMaterialRef.delete(r,e.id)))}_ownMaterial(e){x(e.repository)&&e.repository!==this&&tu.error("Material is already owned by a different material repository"),e.repository=this}}class iu{constructor(e){this.glMaterial=e,this.refCnt=0}ref(){++this.refCnt}unref(){--this.refCnt,Pe(this.refCnt>=0)}get referenced(){return this.refCnt>0}}const su={rootOrigin:null};class au{constructor(e,r=125e4){this._originSR=e,this._gridSize=r,this._origins=new Map,this._objects=new Map,this._rootOriginId="root/"+ni()}getOrigin(e){const r=this._origins.get(this._rootOriginId);if(r==null){const h=su.rootOrigin;if(x(h))return this._origins.set(this._rootOriginId,Di(h[0],h[1],h[2],this._rootOriginId)),this.getOrigin(e);const u=Di(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,u),u}const i=this._gridSize,s=Math.round(e[0]/i),a=Math.round(e[1]/i),o=Math.round(e[2]/i),n=`${s}/${a}/${o}`;let c=this._origins.get(n);const l=.5*i;if(xe(be,e,r.vec3),be[0]=Math.abs(be[0]),be[1]=Math.abs(be[1]),be[2]=Math.abs(be[2]),be[0]<l&&be[1]<l&&be[2]<l){if(c){const h=Math.max(...be);if(xe(be,e,c.vec3),be[0]=Math.abs(be[0]),be[1]=Math.abs(be[1]),be[2]=Math.abs(be[2]),Math.max(...be)<h)return c}return r}return c||(c=Di(s*i,a*i,o*i,n),this._origins.set(n,c)),c}_drawOriginBox(e,r=$i(1,1,0,1)){const i=window.view,s=i._stage,a=r.toString();if(!this._objects.has(a)){this._material=new Od({width:2,color:r}),s.add(this._material);const S=new ud({isPickable:!1}),O=new vn({castShadow:!1});s.add(O),S.add(O),s.add(S),this._objects.set(a,O)}const o=this._objects.get(a),n=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],c=n.length,l=new Array(3*c),h=new Uint16Array(2*(c-1)),u=.5*this._gridSize;for(let S=0;S<c;S++)l[3*S+0]=e[0]+(1&n[S]?u:-u),l[3*S+1]=e[1]+(2&n[S]?u:-u),l[3*S+2]=e[2]+(4&n[S]?u:-u),S>0&&(h[2*S+0]=S-1,h[2*S+1]=S);Mi(l,this._originSR,0,l,i.renderSpatialReference,0,c);const f=new Ve([[d.POSITION,{size:3,data:l,exclusive:!0}]],[[d.POSITION,h]],Xr.Line);s.add(f),o.addGeometry(f,this._material,cr)}}const be=j();class ou{constructor(){this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=j(),this.parallax={anchorPointClouds:j(),cloudsHeight:1e5,radiusCurvatureCorrectionFactor:0,transform:le()},this.parallaxNew={anchorPointClouds:j(),cloudsHeight:1e5,radiusCurvatureCorrectionFactor:0,transform:le()},this.crossFade={enabled:!1,factor:0,distanceThresholdFactor:.3},this.fadeInOut={stage:Gi.FINISHED,factor:0,distanceThresholdFactor:.6},this.fadeIn={stage:Xs.FINISHED,factor:0,distanceThresholdFactor:2},this.fadeInOutHeight={stage:Js.FINISHED,factor:-1}}}var Xs,Gi,Js;(function(t){t[t.FINISHED=0]="FINISHED",t[t.CHANGE_ANCHOR=1]="CHANGE_ANCHOR",t[t.FADE_IN=2]="FADE_IN"})(Xs||(Xs={})),function(t){t[t.FINISHED=0]="FINISHED",t[t.FADE_OUT=1]="FADE_OUT",t[t.SWITCH=2]="SWITCH",t[t.FADE_IN=3]="FADE_IN"}(Gi||(Gi={})),function(t){t[t.FINISHED=0]="FINISHED",t[t.HEIGHT_FADE=1]="HEIGHT_FADE"}(Js||(Js={}));function nu(t,e){const r=t.fragment.uniforms;r.add(new qe("nearFar",(i,s)=>s.camera.nearFar)),r.add(new Lr("depthMap",(i,s)=>s.linearDepthTexture)),r.add(new ar("view",(i,s)=>s.ssr.camera.viewMatrix)),r.add(new ar("proj",(i,s)=>s.ssr.camera.projectionMatrix)),r.add(new pe("invResolutionHeight",(i,s)=>1/s.ssr.camera.height)),r.add(new Lr("lastFrameColorMap",(i,s)=>s.ssr.lastFrameColorTexture)),r.add(new ar("reprojectionMatrix",(i,s)=>s.ssr.reprojectionMatrix)),t.fragment.include(ti),t.fragment.code.add(p`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${e.highStepCount?"150;":"75;"}

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}class lu{constructor(){this.reprojectionMatrix=le()}}class cu{constructor(e,r,i){this.shadowMap=e,this.ssaoHelper=r,this.slicePlane=i,this.slot=se.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this._inverseViewport=fe(),this.lighting=new Oc,this.ssr=new lu,this.multipassTerrain=new wc,this.multipassGeometry=new gh,this.clouds=new ou,this.overlays=[]}get camera(){return this._camera}set camera(e){this._camera=this.ssr.camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}}class du{constructor(e,r,i,s=null){this.rctx=e,this.sliceHelper=s,this.lastFrameCamera=new gi,this.pass=ye.MATERIAL,this.renderOccludedMask=no,this.bindParameters=new cu(r,i,x(s)?s.plane:null)}resetRenderOccludedMask(){this.renderOccludedMask=no}get isHighlightPass(){return this.pass===ye.MATERIAL_HIGHLIGHT}}const no=Ht.Occlude|Ht.OccludeAndTransparent|Ht.OccludeAndTransparentStencil;var lo;(function(t){t[t.Highlight=0]="Highlight",t[t.Default=1]="Default"})(lo||(lo={}));class xi{constructor(){this.camera=new gi,this.lightMat=le()}}class hu{constructor(e,r,i=0){this.rctx=e,this.viewingMode=r,this._enabled=!1,this._snapshots=new Array,this._textureSize=0,this.maxTextureSize=0,this.numCascades=1,this.maxNumCascades=4,this.splitSchemeLambda=0,this.warp=!0,this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=ot(),this._cascades=[new xi,new xi,new xi,new xi],this.maxTextureSize=this.rctx.parameters.maxTextureSize,this.snapshotCount=i}get depthTexture(){return this._depthTexture}get textureSize(){return this._textureSize}get cascadeDistances(){return nr(this._usedCascadeDistances,this._cascadeDistances[0],this.numCascades>1?this._cascadeDistances[1]:1/0,this.numCascades>2?this._cascadeDistances[2]:1/0,this.numCascades>3?this._cascadeDistances[3]:1/0)}dispose(){this._discardDepthTexture(),this._discardAllSnapshots()}set maxCascades(e){this.maxNumCascades=jt(Math.floor(e),1,4)}get maxCascades(){return this.maxNumCascades}set enabled(e){this._enabled=e,e||(this._discardDepthTexture(),this._discardAllSnapshots())}get enabled(){return this._enabled}get ready(){return this._enabled&&x(this._depthTexture)}get snapshotCount(){return this._snapshots.length}set snapshotCount(e){const r=this._snapshots.length;if(e>r){const i=e-r;this._snapshots.length=e;for(let s=0;s<i;++s)this._snapshots[r+s]=null}else if(e<this.snapshotCount){const i=r-e;for(let s=0;s<i;++s)this._discardSnapshot(e+s);this._snapshots.length=e}}getSnapshot(e){return this.enabled?this._snapshots[e]:null}getCascades(){for(let e=0;e<this.numCascades;++e)Cs[e]=this._cascades[e];return Cs.length=this.numCascades,Cs}start(e,r,i){Pe(this.enabled),this._textureSize=this._computeTextureSize(e.fullWidth,e.fullHeight),this._ensureDepthTexture();const{near:s,far:a}=this._clampNearFar(i);this._computeCascadeDistances(a,s),this._setupMatrices(e,r);const o=e.viewMatrix,n=e.projectionMatrix;for(let c=0;c<this.numCascades;++c)this._constructCascade(c,n,o,r);this.lastOrigin=null,this.clear()}finish(e){Pe(this.enabled),this.rctx.bindFramebuffer(e)}getShadowMapMatrices(e){if(!this.lastOrigin||!Zr(e,this.lastOrigin)){this.lastOrigin=this.lastOrigin||j(),te(this.lastOrigin,e);for(let r=0;r<this.numCascades;++r){Ca(yo,this._cascades[r].lightMat,e);for(let i=0;i<16;++i)So[16*r+i]=yo[i]}}return So}takeCascadeSnapshotTo(e,r){Pe(this.enabled);const i=this._ensureSnapshot(r);this._bindFbo();const s=this.rctx,a=s.bindTexture(i,ir.TEXTURE_UNIT_FOR_UPDATES);s.gl.copyTexSubImage2D(or.TEXTURE_2D,0,e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[2],e.camera.viewport[3]),s.bindTexture(a,ir.TEXTURE_UNIT_FOR_UPDATES)}clear(){const e=this.rctx;this._bindFbo(),e.setClearColor(1,1,1,1),e.clearSafe(zi.COLOR_BUFFER_BIT|zi.DEPTH_BUFFER_BIT)}_computeTextureSize(e,r){const i=.5*Math.log(e*e+r*r)*Math.LOG2E,s=.35,a=2**Math.round(i+s);return Math.min(this.maxTextureSize,2*a)}_ensureDepthTexture(){if(x(this._depthTexture)&&this._depthTexture.descriptor.width===this._textureSize)return;this._discardDepthTexture();const e={target:or.TEXTURE_2D,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,wrapMode:dr.CLAMP_TO_EDGE,samplingMode:ri.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize};this._depthTexture=new ir(this.rctx,e),this._fbo=new Yr(this.rctx,{colorTarget:pa.TEXTURE,depthStencilTarget:fa.DEPTH_RENDER_BUFFER,width:this._textureSize,height:this._textureSize},this._depthTexture)}_ensureSnapshot(e){let r=this._snapshots[e];if(x(r)&&r.descriptor.width===this._textureSize)return r;this._discardSnapshot(e);const i={target:or.TEXTURE_2D,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,wrapMode:dr.CLAMP_TO_EDGE,samplingMode:ri.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize};return r=new ir(this.rctx,i),this._snapshots[e]=r,r}_discardDepthTexture(){this._fbo=Fe(this._fbo),this._depthTexture=Fe(this._depthTexture)}_discardSnapshot(e){this._snapshots[e]=Fe(this._snapshots[e])}_discardAllSnapshots(){for(let e=0;e<this.snapshotCount;++e)this._discardSnapshot(e)}_bindFbo(){const e=this.rctx;e.unbindTexture(this._depthTexture),e.bindFramebuffer(this._fbo)}_constructCascade(e,r,i,s){const a=this._cascades[e],o=-this._cascadeDistances[e],n=-this._cascadeDistances[e+1],c=(r[10]*o+r[14])/Math.abs(r[11]*o+r[15]),l=(r[10]*n+r[14])/Math.abs(r[11]*n+r[15]);Pe(c<l);for(let u=0;u<8;++u){nr(po,u%4==0||u%4==3?-1:1,u%4==0||u%4==1?-1:1,u<4?c:l,1),Cr(Ze[u],po,uo);for(let f=0;f<3;++f)Ze[u][f]/=Ze[u][3]}Al(Rs,Ze[0]),Ca(co,_o,Rs),a.camera.viewMatrix=co;for(let u=0;u<8;++u)ue(Ze[u],Ze[u],a.camera.viewMatrix);te(lt,Ze[0]),te(ct,Ze[0]);for(let u=1;u<8;++u)for(let f=0;f<3;++f)lt[f]=Math.min(lt[f],Ze[u][f]),ct[f]=Math.max(ct[f],Ze[u][f]);lt[2]-=200,ct[2]+=200,a.camera.near=-ct[2],a.camera.far=-lt[2],this.warp?this._constructTrapezoidalProjection(i,s,a):this._constructOrthogonalProjection(a),lr(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const h=this._textureSize/2;a.camera.viewport[0]=e%2==0?0:h,a.camera.viewport[1]=Math.floor(e/2)===0?0:h,a.camera.viewport[2]=h,a.camera.viewport[3]=h}_constructOrthogonalProjection(e){Bo(e.camera.projectionMatrix,lt[0],ct[0],lt[1],ct[1],e.camera.near,e.camera.far)}_constructTrapezoidalProjection(e,r,i){const s=1/Ze[0][3],a=1/Ze[4][3];Pe(s<a);let o=s+Math.sqrt(s*a);const n=Math.sin(bl(e[2]*r[0]+e[6]*r[1]+e[10]*r[2]));o/=n,pu(Ze,o,n,fo,mo,uu,go,vo),fu(fo,mo,go,vo,i.camera.projectionMatrix),i.camera.projectionMatrix[10]=2/(lt[2]-ct[2]),i.camera.projectionMatrix[14]=-(lt[2]+ct[2])/(lt[2]-ct[2])}_setupMatrices(e,r){lr(ho,e.projectionMatrix,e.viewMatrix),Er(uo,ho);const i=this.viewingMode===Bt.Global?e.eye:ae(Rs,0,0,1);Ho(_o,[0,0,0],[-r[0],-r[1],-r[2]],i)}_clampNearFar(e){let{near:r,far:i}=e;return r<2&&(r=2),i<2&&(i=2),r>=i&&(r=2,i=4),{near:r,far:i}}_computeCascadeDistances(e,r){this.numCascades=Math.min(1+Math.floor(Zc(e/r,4)),this.maxNumCascades);const i=(e-r)/this.numCascades,s=(e/r)**(1/this.numCascades);let a=r,o=r;for(let n=0;n<this.numCascades+1;++n)this._cascadeDistances[n]=rr(a,o,this.splitSchemeLambda),a*=s,o+=i}get gpuMemoryUsage(){var e,r;return this._snapshots.reduce((i,s)=>i+Kc(s),(r=(e=this._fbo)==null?void 0:e.gpuMemoryUsage)!=null?r:0)}get test(){const e=this;return{maxNumCascades:this.maxNumCascades,cascades:this._cascades,textureSize:this._textureSize,set splitSchemeLambda(r){e.splitSchemeLambda=r},get splitSchemeLambda(){return e.splitSchemeLambda},set warp(r){e.warp=r},get warp(){return e.warp}}}}const co=le(),ho=le(),uo=le(),po=ot(),Ze=[];for(let t=0;t<8;++t)Ze.push(ot());const lt=j(),ct=j(),fo=fe(),mo=fe(),uu=fe(),go=fe(),vo=fe(),_o=le(),Rs=j(),Cs=[],yo=le(),So=new Float32Array(64),Qe=fe(),Sr=fe(),Yt=[fe(),fe(),fe(),fe()],Se=fe(),As=fe(),It=fe(),Br=fe(),Tr=fe(),xr=fe(),Oi=fe();function pu(t,e,r,i,s,a,o,n){yt(Qe,0,0);for(let m=0;m<4;++m)Zt(Qe,Qe,t[m]);Or(Qe,Qe,.25),yt(Sr,0,0);for(let m=4;m<8;++m)Zt(Sr,Sr,t[m]);Or(Sr,Sr,.25),Vr(Yt[0],t[4],t[5],.5),Vr(Yt[1],t[5],t[6],.5),Vr(Yt[2],t[6],t[7],.5),Vr(Yt[3],t[7],t[4],.5);let c=0,l=Aa(Yt[0],Qe);for(let m=1;m<4;++m){const g=Aa(Yt[m],Qe);g<l&&(l=g,c=m)}wr(Se,Yt[c],t[c+4]);const h=Se[0];let u,f;Se[0]=-Se[1],Se[1]=h,wr(As,Sr,Qe),Le(As,Se)<0&&El(Se,Se),Vr(Se,Se,As,r),ba(Se,Se),u=f=Le(wr(It,t[0],Qe),Se);for(let m=1;m<8;++m){const g=Le(wr(It,t[m],Qe),Se);g<u?u=g:g>f&&(f=g)}Fr(i,Qe),Or(It,Se,u-e),Zt(i,i,It);let S=-1,O=1,b=0,U=0;for(let m=0;m<8;++m){wr(Br,t[m],i),ba(Br,Br);const g=Se[0]*Br[1]-Se[1]*Br[0];g>0?g>S&&(S=g,b=m):g<O&&(O=g,U=m)}vr(S>0,"leftArea"),vr(O<0,"rightArea"),Or(Tr,Se,u),Zt(Tr,Tr,Qe),Or(xr,Se,f),Zt(xr,xr,Qe),Oi[0]=-Se[1],Oi[1]=Se[0];const C=_i(i,t[U],xr,Zt(It,xr,Oi),1,s),P=_i(i,t[b],xr,It,1,a),y=_i(i,t[b],Tr,Zt(It,Tr,Oi),1,o),_=_i(i,t[U],Tr,It,1,n);vr(C,"rayRay"),vr(P,"rayRay"),vr(y,"rayRay"),vr(_,"rayRay")}function Q(t,e){return 3*e+t}const To=fe();function ke(t,e){return yt(To,t[e],t[e+3]),To}const Ge=fe(),I=ua();function fu(t,e,r,i,s){wr(Ge,r,i),Or(Ge,Ge,.5),I[0]=Ge[0],I[1]=Ge[1],I[2]=0,I[3]=Ge[1],I[4]=-Ge[0],I[5]=0,I[6]=Ge[0]*Ge[0]+Ge[1]*Ge[1],I[7]=Ge[0]*Ge[1]-Ge[1]*Ge[0],I[8]=1,I[Q(0,2)]=-Le(ke(I,0),t),I[Q(1,2)]=-Le(ke(I,1),t);let a=Le(ke(I,0),r)+I[Q(0,2)],o=Le(ke(I,1),r)+I[Q(1,2)],n=Le(ke(I,0),i)+I[Q(0,2)],c=Le(ke(I,1),i)+I[Q(1,2)];a=-(a+n)/(o+c),I[Q(0,0)]+=I[Q(1,0)]*a,I[Q(0,1)]+=I[Q(1,1)]*a,I[Q(0,2)]+=I[Q(1,2)]*a,a=1/(Le(ke(I,0),r)+I[Q(0,2)]),o=1/(Le(ke(I,1),r)+I[Q(1,2)]),I[Q(0,0)]*=a,I[Q(0,1)]*=a,I[Q(0,2)]*=a,I[Q(1,0)]*=o,I[Q(1,1)]*=o,I[Q(1,2)]*=o,I[Q(2,0)]=I[Q(1,0)],I[Q(2,1)]=I[Q(1,1)],I[Q(2,2)]=I[Q(1,2)],I[Q(1,2)]+=1,a=Le(ke(I,1),e)+I[Q(1,2)],o=Le(ke(I,2),e)+I[Q(2,2)],n=Le(ke(I,1),r)+I[Q(1,2)],c=Le(ke(I,2),r)+I[Q(2,2)],a=-.5*(a/o+n/c),I[Q(1,0)]+=I[Q(2,0)]*a,I[Q(1,1)]+=I[Q(2,1)]*a,I[Q(1,2)]+=I[Q(2,2)]*a,a=Le(ke(I,1),e)+I[Q(1,2)],o=Le(ke(I,2),e)+I[Q(2,2)],n=-o/a,I[Q(1,0)]*=n,I[Q(1,1)]*=n,I[Q(1,2)]*=n,s[0]=I[0],s[1]=I[1],s[2]=0,s[3]=I[2],s[4]=I[3],s[5]=I[4],s[6]=0,s[7]=I[5],s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=I[6],s[13]=I[7],s[14]=0,s[15]=I[8]}class mu{constructor(){this.adds=new wt,this.removes=new wt,this.updates=new wt({allocator:e=>e||new gu,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}}class gu{}class vu{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}}var Wt,ur;(function(t){t[t.OBJECT=0]="OBJECT",t[t.HUD=1]="HUD",t[t.TERRAIN=2]="TERRAIN",t[t.OVERLAY=3]="OVERLAY",t[t.I3S=4]="I3S",t[t.PCL=5]="PCL",t[t.LOD=6]="LOD",t[t.VOXEL=7]="VOXEL"})(Wt||(Wt={}));class _u{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.store=ur.ALL}}(function(t){t[t.MIN=0]="MIN",t[t.MINMAX=1]="MINMAX",t[t.ALL=2]="ALL"})(ur||(ur={}));function yu(t){return x(t)&&x(t.dist)}const xo=1e-5;class Su{constructor(e){this.options=new _u,this._results=new Tu,this.transform=new Rc,this.tolerance=xo,this.verticalOffset=null,this._ray=$t(),this._rayEnd=j(),this._rayBeginTransformed=j(),this._rayEndTransformed=j(),this.viewingMode=e==null?Bt.Global:e}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(e,r,i){this.resetWithRay(tc(e,r,this._ray),i)}resetWithRay(e,r){this.camera=r,e!==this._ray&&zs(e,this._ray),this.options.verticalOffset!==0?this.viewingMode===Bt.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,_e(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(e=null,r,i,s,a){this.point=r,this.filterPredicate=s,this.tolerance=i==null?xo:i;const o=Fa(this.verticalOffset);if(x(e)&&e.length>0){const n=a?c=>{a(c)&&this.intersectObject(c)}:c=>{this.intersectObject(c)};for(const c of e){const l=c.getSpatialQueryAccelerator&&c.getSpatialQueryAccelerator();x(l)?(x(o)?l.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,n,o):l.forEachAlongRay(this._ray.origin,this._ray.direction,n),this.options.selectionMode&&this.options.hud&&l.forEachDegenerateObject(n)):c.objects.forAll(h=>n(h))}}this.sortResults()}intersectObject(e){const r=e.geometryRecords;if(!r)return;const i=e.transformation,s=Fa(this.verticalOffset);for(const a of r){const{geometry:o,material:n,instanceParameters:c}=a;if(Ji(c))continue;const l=o.id;this.transform.setAndInvalidateLazyTransforms(i,a.getShaderTransformation()),ue(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),ue(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const h=this.transform.transform;x(s)&&(s.objectTransform=this.transform),n.intersect(o,c,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(u,f,S,O,b,U)=>{if(u>=0){if(x(this.filterPredicate)&&!this.filterPredicate(this._ray.origin,this._rayEnd,u))return;const C=O?this._results.hud:this._results,P=O?y=>{const _={object:e,geometryId:l,triangleNr:S,center:x(U)?[U[0],U[1],U[2]]:null};y.set(Wt.HUD,_,u,f,cr,b)}:y=>y.set(Wt.OBJECT,{object:e,geometryId:l,triangleNr:S},u,f,h,b);if((C.min.drapedLayerOrder==null||b>=C.min.drapedLayerOrder)&&(C.min.dist==null||u<C.min.dist)&&P(C.min),this.options.store!==ur.MIN&&(C.max.drapedLayerOrder==null||b<C.max.drapedLayerOrder)&&(C.max.dist==null||u>C.max.dist)&&P(C.max),this.options.store===ur.ALL)if(O){const y=new Qs(this._ray);P(y),this._results.hud.all.push(y)}else{const y=new Ir(this._ray);P(y),this._results.all.push(y)}}},a.shaderTransformation)}}sortResults(e=this._results.all){e.sort((r,i)=>r.dist!==i.dist?ne(r.dist,0)-ne(i.dist,0):r.drapedLayerOrder!==i.drapedLayerOrder?ne(r.drapedLayerOrder,Number.MAX_VALUE)-ne(i.drapedLayerOrder,Number.MAX_VALUE):ne(i.drapedLayerGraphicOrder,Number.MIN_VALUE)-ne(r.drapedLayerGraphicOrder,Number.MIN_VALUE))}}function Ef(t){return new Su(t)}class Tu{constructor(){this.min=new Ir($t()),this.max=new Ir($t()),this.hud={min:new Qs($t()),max:new Qs($t()),all:new Array},this.ground=new Ir($t()),this.all=[]}init(e){this.min.init(e),this.max.init(e),this.ground.init(e),this.all.length=0,this.hud.min.init(e),this.hud.max.init(e),this.hud.all.length=0}}class Ir{constructor(e){this.intersector=Wt.OBJECT,this.normal=j(),this.transformation=le(),this._ray=$t(),this.init(e)}get ray(){return this._ray}get distanceInRenderSpace(){return x(this.dist)?(ce(wi,this.ray.direction,this.dist),Ot(wi)):null}getIntersectionPoint(e){return!!yu(this)&&(ce(wi,this.ray.direction,this.dist),_e(e,this.ray.origin,wi),!0)}getTransformedNormal(e){return te(Gr,this.normal),Gr[3]=0,Cr(Gr,Gr,this.transformation),te(e,Gr),Re(e,e)}init(e){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=Wt.OBJECT,zs(e,this._ray)}set(e,r,i,s,a,o,n){this.intersector=e,this.dist=i,te(this.normal,ne(s,Pl)),ft(this.transformation,ne(a,cr)),this.target=r,this.drapedLayerOrder=o,this.drapedLayerGraphicOrder=n}copy(e){zs(e.ray,this._ray),this.intersector=e.intersector,this.dist=e.dist,this.target=e.target,this.drapedLayerOrder=e.drapedLayerOrder,this.drapedLayerGraphicOrder=e.drapedLayerGraphicOrder,te(this.normal,e.normal),ft(this.transformation,e.transformation)}}class Qs extends Ir{constructor(){super(...arguments),this.intersector=Wt.HUD}}function xu(t){return new Ir(t)}const wi=j(),Gr=ot();function Ou(t){const e=new Map,r=i=>{let s=e.get(i);return s||(s=new vu,e.set(i,s)),s};return t.removes.forAll(i=>{bs(i)&&r(i.material).removes.push(i)}),t.adds.forAll(i=>{bs(i)&&r(i.material).adds.push(i)}),t.updates.forAll(i=>{bs(i.renderGeometry)&&r(i.renderGeometry.material).updates.push(i)}),e}function bs(t){return t.data.indexCount>=1}class wu extends Cc{constructor(e=j()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}}class Ru{constructor(){this.enabled=!0,this._time=0}get time(){return Dl(this._time)}advance(e){return x(e.forcedTime)?this._time!==e.forcedTime&&(this._time=e.forcedTime,!0):!(!this.enabled||e.dt===0)&&(this._time+=e.dt,!0)}}function Oo(t,e){e.spherical?t.vertex.code.add(p`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`):t.vertex.code.add(p`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`),e.spherical?t.vertex.code.add(p`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`):t.vertex.code.add(p`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)}function Cu(t){t.fragment.code.add(p`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function Au(t){t.fragment.code.add(p`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function bu(t){t.fragment.code.add(p`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}class Eu extends ci{constructor(e,r){super(e,"samplerCube",Ac.Pass,(i,s,a)=>i.bindTexture(e,r(s,a)))}}function Pu(t){const e=t.fragment;e.uniforms.add([new ar("rotationMatrixClouds",(r,i)=>i.clouds.parallax.transform),new ar("rotationMatrixCloudsCrossFade",(r,i)=>i.clouds.parallaxNew.transform),new mt("anchorPosition",(r,i)=>i.clouds.parallax.anchorPointClouds),new mt("anchorPositionCrossFade",(r,i)=>i.clouds.parallaxNew.anchorPointClouds),new qe("cloudVariables",(r,i)=>x(i.clouds.data)?yt(Du,i.clouds.data.coverage,i.clouds.data.absorption):Il),new pe("cloudsHeight",(r,i)=>i.clouds.parallax.cloudsHeight),new pe("radiusCurvatureCorrectionFactor",(r,i)=>i.clouds.parallax.radiusCurvatureCorrectionFactor),new pe("totalFadeInOut",(r,i)=>i.clouds.fadeInOut.stage===Gi.FINISHED?i.clouds.fadeInOutHeight.factor+Math.max(jt(i.clouds.fadeIn.factor,0,1)):i.clouds.fadeInOutHeight.factor+Math.max(jt(i.clouds.fadeInOut.factor,0,1))),new pe("crossFadeAnchorFactor",(r,i)=>jt(i.clouds.crossFade.factor,0,1)),new Eu("cubeMap",(r,i)=>x(i.clouds.data)?i.clouds.data.cubeMap.colorTexture:null),new bc("crossFade",(r,i)=>i.clouds.crossFade.enabled)]),e.constants.add("planetRadius","float",Ml.radius),e.code.add(p`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),e.code.add(p`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),e.code.add(p`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),e.uniforms.add([new mt("lightingMainDirection",(r,i)=>i.lighting.lightingMainDirection),new mt("lightingMainIntensity",(r,i)=>i.lighting.mainLight.intensity)]),e.code.add(p`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(lightingMainDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(lightingMainDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((lightingMainIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * pow(dirDotLight, RIM_SCATTERING_FACTOR) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),e.code.add(p`vec4 getCloudData(vec3 rayDir)
{
vec4 cloudData = textureCube(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
return mix(vec4(vec3(clamp(1.0 - cloudVariables.y, 0.6, 1.0)), 0.0), cloudData, smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(mu)));
}`),e.code.add(p`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),e.code.add(p`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),e.code.add(p`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}const Du=fe();function Iu(t,e){t.include(Ec,e),t.include(bu),t.include(Au),e.hasCloudsReflections&&t.include(Pu,e),e.hasScreenSpaceReflections&&t.include(nu,e);const r=t.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(p`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add([new pe("lightingSpecularStrength",(i,s)=>s.lighting.mainLight.specularStrength),new pe("lightingEnvironmentStrength",(i,s)=>s.lighting.mainLight.environmentStrength)]),r.code.add(p`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),e.hasCloudsReflections&&r.code.add(p`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y*cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),e.hasScreenSpaceReflections?r.code.add(p`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view *vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3*dCoords.y), 0.0, 1.0) * heightMod;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture2D(lastFrameColorMap, reprojectedCoordinate).xyz)* reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod*0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor + reflSea * seaColorMod + specular  + foam);`):r.code.add(p`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),e.hasCloudsReflections?e.hasScreenSpaceReflections?r.code.add(p`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(p`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(p`return waterRenderedColor;
}`)}function wo(t){t.fragment.uniforms.add(new pt("texWaveNormal")),t.fragment.uniforms.add(new pt("texWavePerturbation")),t.fragment.uniforms.add([new We("waveParams",e=>nr(Mu,e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset)),new qe("waveDirection",e=>yt($u,e.waveDirection[0]*e.waveVelocity,e.waveDirection[1]*e.waveVelocity))]),t.include(Cu),t.fragment.code.add(p`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture2D(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}const Mu=ot(),$u=fe();function Lu(t){const e=new pr,{vertex:r,fragment:i}=e,s=hi(e,t);return e.include(ca),e.attributes.add(d.POSITION,"vec3"),e.attributes.add(d.UV0,"vec2"),r.uniforms.add(new We("waterColor",a=>a.color)),t.output!==w.Color&&t.output!==w.Alpha||(e.include(Oo,t),e.include(Pc,t),e.varyings.add("vuv","vec2"),e.varyings.add("vpos","vec3"),e.varyings.add("vnormal","vec3"),e.varyings.add("vtbnMatrix","mat3"),i.uniforms.add(s),t.hasMultipassTerrain&&e.varyings.add("depth","float"),r.code.add(p`
      void main(void) {
        if (waterColor.a < ${p.float(rt)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${t.hasMultipassTerrain?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${t.output===w.Color?"forwardLinearDepth();":""}
      }
    `)),e.include(na,t),t.output===w.Alpha&&(e.include(Nt,t),i.uniforms.add(new Pi("waterColor")),i.code.add(p`
        void main() {
          discardBySlice(vpos);
          ${t.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}

          gl_FragColor = vec4(waterColor.a);
        }
      `)),t.output===w.Color&&(e.include(Dc,{isGround:!1}),e.include(Ic,{pbrMode:on.Disabled,lightingSphericalHarmonicsOrder:2}),e.include(wo),e.include(Nt,t),e.include(Mc,t),e.include(Iu,t),i.uniforms.add([new Pi("waterColor"),new mt("lightingMainDirection",(a,o)=>o.lighting.lightingMainDirection),new mt("lightingMainIntensity",(a,o)=>o.lighting.mainLight.intensity),new pe("timeElapsed",a=>a.timeElapsed),new $c("view")]),oa(i,t),i.include(Xi),i.code.add(p`
      void main() {
        discardBySlice(vpos);
        ${t.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${t.receiveShadows?p`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view*vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, lightingMainDirection, waterColor.rgb, lightingMainIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        gl_FragColor = delinearizeGamma(final);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${t.transparencyPassType===Oe.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `)),t.output===w.Normal&&(e.include(Oo,t),e.include(wo,t),e.include(Nt,t),e.varyings.add("vpos","vec3"),e.varyings.add("vuv","vec2"),r.code.add(p`
        void main(void) {
          if (waterColor.a < ${p.float(rt)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),i.uniforms.add(new pe("timeElapsed",a=>a.timeElapsed)),i.code.add(p`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
gl_FragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`)),t.output===w.Draped&&(e.varyings.add("vpos","vec3"),r.code.add(p`
        void main(void) {
          if (waterColor.a < ${p.float(rt)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),i.uniforms.add(new Pi("waterColor")),i.code.add(p`void main() {
gl_FragColor = waterColor;
}`)),t.output===w.Highlight&&(e.include(Yi),e.varyings.add("vpos","vec3"),r.code.add(p`
      void main(void) {
        if (waterColor.a < ${p.float(rt)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),e.include(Nt,t),i.code.add(p`void main() {
discardBySlice(vpos);
outputHighlight();
}`)),e}const Fu=Object.freeze(Object.defineProperty({__proto__:null,build:Lu},Symbol.toStringTag,{value:"Module"}));class rs extends fr{constructor(e,r,i){super(e,r,i),this._textureRepository=e.waterTextureRepository}initializeConfiguration(e,r){r.spherical=e.viewingMode===Bt.Global,r.doublePrecisionRequiresObfuscation=Lc(e.rctx)}initializeProgram(e){const r=rs.shader.get().build(this.configuration);return new mr(e.rctx,r,Nr)}bindPass(e,r){this.program.bindPass(e,r),this.configuration.output!==w.Color&&this.configuration.output!==w.Normal||this._textureRepository.bind(this.program)}_setPipelineState(e){const r=this.configuration,i=e===Oe.NONE,s=e===Oe.FrontFace;return at({blending:r.output!==w.Normal&&r.output!==w.Highlight&&r.transparent?i?Jr:Zi(e):null,depthTest:{func:ia(e)},depthWrite:i?r.writeDepth&&$r:Wo(e),colorWrite:vt,polygonOffset:i||s?null:qo(r.enableOffset)})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}rs.shader=new gr(Fu,()=>kt(()=>import("./WaterSurface.glsl.d54908b7.js"),["assets/WaterSurface.glsl.d54908b7.js","assets/Matrix4Uniform.9e24b035.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/floatRGBA.5328f61e.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));class Ee extends di{constructor(){super(...arguments),this.output=w.Color,this.transparencyPassType=Oe.NONE,this.spherical=!1,this.receiveShadows=!1,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.hasScreenSpaceReflections=!1,this.doublePrecisionRequiresObfuscation=!1,this.hasCloudsReflections=!1,this.isDraped=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}v([R({count:w.COUNT})],Ee.prototype,"output",void 0),v([R({count:Oe.COUNT})],Ee.prototype,"transparencyPassType",void 0),v([R()],Ee.prototype,"spherical",void 0),v([R()],Ee.prototype,"receiveShadows",void 0),v([R()],Ee.prototype,"hasSlicePlane",void 0),v([R()],Ee.prototype,"transparent",void 0),v([R()],Ee.prototype,"enableOffset",void 0),v([R()],Ee.prototype,"writeDepth",void 0),v([R()],Ee.prototype,"hasScreenSpaceReflections",void 0),v([R()],Ee.prototype,"doublePrecisionRequiresObfuscation",void 0),v([R()],Ee.prototype,"hasCloudsReflections",void 0),v([R()],Ee.prototype,"isDraped",void 0),v([R()],Ee.prototype,"hasMultipassTerrain",void 0),v([R()],Ee.prototype,"cullAboveGround",void 0),v([R({constValue:on.Water})],Ee.prototype,"pbrMode",void 0),v([R({constValue:!0})],Ee.prototype,"useCustomDTRExponentForWater",void 0),v([R({constValue:!0})],Ee.prototype,"highStepCount",void 0),v([R({constValue:!1})],Ee.prototype,"useFillLights",void 0);class Ro extends Qi{_updateShadowState(e){e.shadowMap.enabled!==this._material.parameters.receiveShadows&&this._material.setParameters({receiveShadows:e.shadowMap.enabled})}_updateSSRState(e){e.ssr.enabled!==this._material.parameters.hasScreenSpaceReflections&&this._material.setParameters({hasScreenSpaceReflections:e.ssr.enabled})}_updateCloudsReflectionState(e){const r=x(e.clouds.data);r!==this._material.parameters.hasCloudsReflections&&this._material.setParameters({hasCloudsReflections:r})}ensureResources(e){const r=this._techniqueRepository.constructionContext.waterTextureRepository;return r.resourceState===Go.NOT_LOADED&&r.loadTextures(e),r.resourceState}beginSlot(e){return this._output===w.Color&&(this._updateShadowState(e),this._updateSSRState(e),this._updateCloudsReflectionState(e)),this.ensureTechnique(rs,e)}}class Nu extends ui{constructor(e){super(e,new zu),this._techniqueConfig=new Ee,this.animation=new Ru}getConfiguration(e,r){return this._techniqueConfig.output=e,this._techniqueConfig.writeDepth=this.parameters.writeDepth,this._techniqueConfig.receiveShadows=this.parameters.receiveShadows,this._techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this._techniqueConfig.transparent=this.parameters.transparent,this._techniqueConfig.hasScreenSpaceReflections=this.parameters.hasScreenSpaceReflections,this._techniqueConfig.hasCloudsReflections=this.parameters.hasCloudsReflections,this._techniqueConfig.isDraped=this.parameters.isDraped,this._techniqueConfig.transparencyPassType=r.transparencyPassType,this._techniqueConfig.enableOffset=r.camera.relativeElevation<ko,this._techniqueConfig.hasMultipassTerrain=r.multipassTerrain.enabled,this._techniqueConfig.cullAboveGround=r.multipassTerrain.cullAboveGround,this._techniqueConfig}update(e){const r=Math.min(e.camera.relativeElevation,e.camera.distance);this.animation.enabled=Math.sqrt(this.parameters.waveTextureRepeat/this.parameters.waveStrength)*r<Uu;const i=this.animation.advance(e);return this.setParameters({timeElapsed:$l(this.animation.time)*this.parameters.animationSpeed},!1),this.animation.enabled&&i}intersect(e,r,i,s,a,o,n){an(e,r,s,a,o,void 0,n)}requiresSlot(e,r){switch(ii(r)){case w.Normal:return e===se.DRAPED_WATER;case w.Color:if(this.parameters.isDraped)return e===se.DRAPED_MATERIAL;break;case w.Highlight:return e===se.OPAQUE_MATERIAL||e===se.DRAPED_MATERIAL}let i=se.OPAQUE_MATERIAL;return this.parameters.transparent&&(i=this.parameters.writeDepth?se.TRANSPARENT_MATERIAL:se.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL),e===i}createGLMaterial(e){if(e.output===w.Color&&this.parameters.isDraped)return e.output=w.Draped,new Ro(e);switch(e.output){case w.Color:case w.Normal:case w.Highlight:case w.Alpha:return new Ro(e)}return null}createBufferWriter(){return new ga(Fh)}}class zu extends da{constructor(){super(...arguments),this.waveStrength=.06,this.waveTextureRepeat=32,this.waveDirection=ea(1,0),this.waveVelocity=.05,this.flowStrength=.015,this.flowOffset=-.5,this.animationSpeed=.35,this.timeElapsed=0,this.color=$i(0,0,0,0),this.transparent=!0,this.writeDepth=!0,this.hasSlicePlane=!1,this.isDraped=!1,this.receiveShadows=!0,this.hasScreenSpaceReflections=!1,this.hasCloudsReflections=!1}}const Uu=35e3;class Co{constructor(e){this.first=e.from,this.count=e.to-e.from}}class Rr{constructor(e=0,r=0){this.from=e,this.to=r}}class Vu extends Rr{constructor(e,r,i,s,a,o){super(r,i),this.id=e,this.isVisible=s,this.hasHighlights=a,this.hasOccludees=o}}function Ao(t){return Array.from(t.values()).sort(ju)}function ju(t,e){return t.from===e.from?t.to-e.to:t.from-e.from}function Ri(t,e){if(t.length===0)return void t.push(new Co(e));const r=t[t.length-1];if(Hu(r,e)){const i=e.from-r.first+e.to-e.from;r.count=i}else t.push(new Co(e))}function Hu(t,e){return t.first+t.count>=e.from}class Bu{constructor(e,r){this._pool=e,this._size=0,this._buffer=e.newBuffer(Ys(r))}dispose(){this._buffer=this._pool.deleteBuffer(this._buffer),this._size=0}release(){this.erase(0,this._size),this.dispose()}get vao(){return this._buffer.vao}get array(){return this._buffer.array}get size(){return this._size}grow(e){this._resize(this._size+e,!0).dispose()}alloc(e){return this._resize(e,!1)}_resize(e,r){let i;const s=Gu(this._buffer.length,this._size,e);if(this._buffer.length!==s){const o=this._pool.newBuffer(s);r&&(o.array.set(this._buffer.array.subarray(0,Math.min(this._size,s))),o.vao.vertexBuffers.geometry.setSubData(o.array,0,0,o.array.byteLength)),i=this._buffer,this._buffer=o}const a=this._size;return this._size=e,i?{dispose:()=>{i.array.fill(0,0,a),this._pool.deleteBuffer(i)},copy:(o,n,c)=>this._buffer.array.set(i.array.subarray(n,c),o),hasNewBuffer:!0}:{dispose:()=>{},copy:(o,n,c)=>{o!==n&&this._buffer.array.copyWithin(o,n,c)},hasNewBuffer:!1}}erase(e,r){this._buffer.array.fill(0,e,r)}}const bo=65536;function Ys(t){return Math.ceil(t/bo)*bo}function Gu(t,e,r){return e<=r?t>=r?t:Ys(Math.max(2*t,r)):t<=2*r?t:Ys(r)}class Wu{constructor(e,r,i,s){this.vao=new ed(e,r,{geometry:i},{geometry:td.createVertex(e,Yc.STATIC_DRAW)}),this.array=new Float32Array(s),this.vao.vertexBuffers.geometry.setSize(this.array.byteLength)}dispose(){this.vao.dispose(!0)}get length(){return this.array.length}}const qu=Fl+1;class ku{constructor(e,r,i){this._rctx=e,this._locations=r,this._layout=i,this._cache=e.newCache(`MergedRenderer pool ${ni()}`,Zu)}dispose(){this._cache.destroy()}newBuffer(e){const r=e.toString(),i=this._cache.pop(r);if(x(i)){const s=i.pop();return i.length>0&&this._cache.put(r,i,s.array.byteLength*i.length,qu),s}return new Wu(this._rctx,this._locations,this._layout,e)}deleteBuffer(e){const r=e.array.byteLength,i=e.array.length.toString(),s=this._cache.pop(i);return x(s)?(s.push(e),this._cache.put(i,s,r*s.length,-1)):this._cache.put(i,[e],r,-1),null}}function Zu(t,e){if(e===Ll.ALL)return void t.forEach(s=>s.dispose());const r=t.pop(),i=t.length*r.array.byteLength;return r.dispose(),i}class Xu{constructor(e,r,i){this._rctx=e,this._materialRepository=r,this._material=i,this.type="MergedRenderer",this._dataByOrigin=new Map,this._renderCommandData=new wt,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new pd(this._material,this._materialRepository),this._bufferWriter=i.createBufferWriter(),this._bufferPool=new ku(e,i.vertexAttributeLocations,od(this._bufferWriter.vertexBufferLayout))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach(e=>e.buffer.dispose()),this._dataByOrigin.clear(),this._bufferPool.dispose()}get isEmpty(){return this._dataByOrigin.size===0}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this._material instanceof Nu}get rendersOccluded(){return!this.isEmpty&&this._material.renderOccluded!==Ht.Occlude}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateRenderCommands()}_addAndRemoveGeometries(e,r){const i=this._bufferWriter,s=i.vertexBufferLayout.stride/4,a=this._dataByOrigin,o=Qu(e,r);o.forEach((n,c)=>{o.delete(c);const l=n.toAdd.reduce((C,P)=>C+i.elementCount(P.data),0);let h=a.get(c);if(h==null)Pe(n.toRemove.length===0),h=new Ku(n.origin,new Bu(this._bufferPool,l*s)),a.set(c,h);else if(n.toAdd.length===0&&h.instances.size===n.toRemove.length)return h.buffer.dispose(),void a.delete(c);let u=0;h.instances.forEach(C=>u+=C.to-C.from);const f=n.toRemove.reduce((C,P)=>C+i.elementCount(P.data),0),S=h.buffer.size,O=(u+l-f)*s,b=tp;if(O<S/2?this._removeAndRebuild(h,n.toRemove,s,O,b):n.toRemove.length>0&&this._remove(h,n.toRemove,s,b),n.toAdd.length>0){const C=rp;Xc(C,-n.origin[0],-n.origin[1],-n.origin[2]),this._add(h,n.toAdd,s,C,b)}const U=h.buffer.vao.vertexBuffers.geometry;Do(b),b.forAll(({from:C,to:P})=>{if(C<P){const y=h.buffer.array,_=4,m=C*_,g=P*_;U.setSubData(y,m,m,g)}}),b.clear(),h.drawCommandsDirty=!0})}_updateGeometries(e){const r=this._bufferWriter,i=r.vertexBufferLayout.stride/4;for(const s of e){const a=s.renderGeometry,o=this._dataByOrigin.get(a.origin.id),n=o&&o.instances.get(a.id);if(!n)return;const c=s.updateType;if(c&et.State.VISIBILITIES&&(n.isVisible=a.instanceParameters.visible),c&(et.State.HIGHLIGHTS|et.State.VISIBILITIES)){const l=a.instanceParameters.visible;n.hasHighlights=!!a.instanceParameters.highlights&&l}if(c&et.State.OCCLUDEES&&(n.hasOccludees=!!a.instanceParameters.occludees),c&(et.State.VERTEXATTRS|et.State.TRANSFORMATION)){const{array:l,vao:h}=o.buffer;Fc(a,Es,Wr),r.write({transformation:Es,invTranspTransformation:Wr},a.data,r.vertexBufferLayout.createView(l.buffer),n.from),Pe(n.from+r.elementCount(a.data)===n.to,"material VBO layout has changed"),h.vertexBuffers.geometry.setSubData(l,n.from*i*4,n.from*i*4,n.to*i*4)}o.drawCommandsDirty=!0}}_updateRenderCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(r=>{r.hasHiddenInstances=!1,r.hasHighlights=!1,r.hasOccludees=!1,Lt(r.instances,i=>(i.isVisible?(i.hasHighlights&&(this._hasHighlights=!0,r.hasHighlights=!0),i.hasOccludees&&(this._hasOccludees=!0,r.hasOccludees=!0)):r.hasHiddenInstances=!0,r.hasHiddenInstances&&r.hasHighlights&&r.hasOccludees))});const e=r=>{if(r.drawCommandsDefault=null,r.drawCommandsHighlight=null,r.drawCommandsOccludees=null,r.drawCommandsShadowHighlightRest=null,r.instances.size===0)return;if(!Po(r)){const s=this._bufferWriter.vertexBufferLayout.stride,a=4*r.buffer.size/s;return void(r.drawCommandsDefault=[{first:0,count:a}])}const i=Ao(r.instances);r.drawCommandsDefault=[],r.drawCommandsHighlight=[],r.drawCommandsOccludees=[],r.drawCommandsShadowHighlightRest=[];for(const s of i)s.isVisible&&(s.hasOccludees?Ri(r.drawCommandsOccludees,s):Ri(r.drawCommandsDefault,s),s.hasHighlights?Ri(r.drawCommandsHighlight,s):Ri(r.drawCommandsShadowHighlightRest,s))};this._dataByOrigin.forEach(r=>{r.drawCommandsDirty&&(e(r),r.drawCommandsDirty=!1)})}updateAnimation(e){return this._material.update(e)}requiresSlot(e,r){return e==null||this._material.requiresSlot(e,r)}render(e,r){if(!this.requiresSlot(r.slot,e))return!1;const i=e===ye.MATERIAL_HIGHLIGHT||e===ye.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT;if(i&&!this._hasHighlights)return!1;const s=e===ye.MATERIAL_DEPTH_SHADOWMAP_DEFAULT,a=!(i||s);if(this._dataByOrigin.forEach(l=>{if(i&&!l.hasHighlights)return;const h=(i?l.drawCommandsHighlight:s&&Po(l)?l.drawCommandsShadowHighlightRest:l.drawCommandsDefault)||null,u=a&&l.drawCommandsOccludees||null;(x(h)||x(u))&&this._renderCommandData.push(new ep(l.origin,l.buffer,h,u))}),this._renderCommandData.length===0)return!1;const o=this._rctx,n=this._glMaterials.load(o,e);if(K(n))return this._renderCommandData.clear(),!1;const c=n.beginSlot(r);return o.bindTechnique(c,this._material.parameters,r,!1),this._renderCommandData.forAll(l=>{c.bindDraw(l,r);const{buffer:h,renderCommands:u,occludeeCommands:f}=l;c.ensureAttributeLocations(h.vao),o.bindVAO(h.vao);const S=c.primitiveType;x(u)&&this._renderCommands(o,S,u),x(f)&&(c.bindPipelineState(o,r.slot,!0),this._renderCommands(o,S,f),c.bindPipelineState(o,r.slot,!1))}),this._renderCommandData.clear(),!0}_renderCommands(e,r,i){for(let s=0;s<i.length;s++)e.drawArrays(r,i[s].first,i[s].count)}_removeAndRebuild(e,r,i,s,a){for(const h of r)e.instances.delete(h.id);const o=Ao(e.instances);e.instances.clear();const n=e.buffer.size,c=e.buffer.alloc(s);let l=0;for(const h of o){const u=h.from*i,f=h.to*i;c.copy(l,u,f),h.from=l/i,l+=f-u,h.to=l/i,e.instances.set(h.id,h)}a.push(new Rr(0,c.hasNewBuffer?e.buffer.array.length:n)),c.dispose(),e.buffer.erase(l,a.back().to),e.holes.clear()}_remove(e,r,i,s){for(const a of r){const o=a.id,n=e.instances.get(o),c=n.from*i,l=n.to*i;e.buffer.erase(c,l),e.holes.push(new Rr(n.from,n.to)),e.instances.delete(o),s.push(new Rr(c,l))}Do(e.holes)}_add(e,r,i,s,a){if(r.length===0)return;const o=this._bufferWriter;let n=o.vertexBufferLayout.createView(e.buffer.array.buffer);const c=e.holes.length>0;let l=Number.MAX_SAFE_INTEGER,h=Number.MIN_SAFE_INTEGER;for(const u of r){const f=x(u.transformation)?lr(Es,s,u.transformation):s;Er(Wr,f);const S=jo(Wr,Wr),O=o.elementCount(u.data),b=O*i;let U=Yu(e.holes,O);K(U)&&(U=e.buffer.size/i,e.buffer.grow(b),n=o.vertexBufferLayout.createView(e.buffer.array.buffer)),o.write({transformation:f,invTranspTransformation:S},u.data,n,U);const C=u.instanceParameters.visible,P=!!u.instanceParameters.highlights&&C,y=!!u.instanceParameters.occludees,_=new Vu(u.id,U,U+O,C,P,y);Pe(e.instances.get(u.id)==null),e.instances.set(u.id,_),c?a.push(new Rr(_.from*i,_.to*i)):(l=Math.min(_.from,l),h=Math.max(_.to,h))}c||a.push(new Rr(l*i,h*i))}get test(){return{material:this._material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}}class Ju{constructor(e){this.origin=e,this.toAdd=new Array,this.toRemove=new Array}}function Qu(t,e){const r=new Map;for(const i of t)Eo(r,i,!0);for(const i of e)Eo(r,i,!1);return r}function Eo(t,e,r){const i=e.origin;if(K(i))return;let s=t.get(i.id);s==null&&(s=new Ju(i.vec3),t.set(i.id,s)),r?s.toAdd.push(e):s.toRemove.push(e)}function Po(t){return t.hasOccludees||t.hasHighlights||t.hasHiddenInstances}function Yu(t,e){let r;if(!t.some(s=>!(s.to-s.from<e)&&(r=s,!0)))return null;const i=r.from;return r.from+=e,r.from>=r.to&&t.removeUnordered(r),i}function Do(t){const e=new Map;t.forAll(i=>e.set(i.from,i));let r=!0;for(;r;)r=!1,t.forEach(i=>{const s=e.get(i.to);s&&(i.to=s.to,e.delete(s.from),t.removeUnordered(s),r=!0)})}class Ku{constructor(e,r){this.origin=e,this.buffer=r,this.instances=new Map,this.holes=new wt({deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!1}}class ep extends wu{constructor(e,r,i,s){super(e),this.buffer=r,this.renderCommands=i,this.occludeeCommands=s}}const tp=new wt({deallocator:null}),rp=le(),Es=le(),Wr=le();let xt=class extends ta{constructor(t){super(t),this._pending=new ip,this._changes=new mu,this._materialRenderers=new Map,this._sortedMaterialRenderers=new wt,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forEach(t=>t.dispose()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return Lt(this._materialRenderers,t=>t.rendersOccluded)}get isEmpty(){return!this.updating&&this._materialRenderers.size===0&&this._geometries.size===0}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const t=Ou(this._changes);let e=!1,r=!1,i=!1;return t.forEach((s,a)=>{let o=this._materialRenderers.get(a);if(!o&&s.adds.length>0&&(o=new Xu(this.rctx,this._materialRepository,a),this._materialRenderers.set(a,o),e=!0,r=!0,i=!0),!o)return;const n=r||o.hasHighlights,c=i||o.hasWater;o.modify(s),r=r||n!==o.hasHighlights,i=i||c!==o.hasWater,o.isEmpty&&(this._materialRenderers.delete(a),o.dispose(),e=!0)}),this._changes.clear(),e&&this._updateSortedMaterialRenderers(),r&&(this._hasHighlights=Lt(this._materialRenderers,s=>s.hasHighlights)),i&&(this._hasWater=Lt(this._materialRenderers,s=>s.hasWater)),this.notifyChange("updating"),!0}addGeometries(t,e){if(t.length===0)return;const r=this._validateRenderGeometries(t);for(const s of r)this._geometries.set(s.id,s);const i=this._pending.empty;for(const s of r)this._pending.adds.add(s);i&&this.notifyChange("updating"),e===et.Geometry.UPDATE&&this._notifyGraphicGeometryChanged(t)}removeGeometries(t,e){const r=this._pending.empty,i=this._pending.adds;for(const s of t)i.has(s)?(this._pending.removed.add(s),i.delete(s)):this._pending.removed.has(s)||this._pending.removes.add(s),this._geometries.delete(Nl(s.id));r&&!this._pending.empty&&this.notifyChange("updating"),e===et.Geometry.UPDATE&&this._notifyGraphicGeometryChanged(t)}modifyGeometries(t,e){const r=this._changes.updates.length===0;for(const i of t){const s=this._changes.updates.pushNew();s.renderGeometry=this._validateRenderGeometry(i),s.updateType=e}switch(r&&this._changes.updates.length>0&&this.notifyChange("updating"),e){case et.State.TRANSFORMATION:case et.State.VERTEXATTRS:return this._notifyGraphicGeometryChanged(t);case et.State.VISIBILITIES:return this._notifyGraphicVisibilityChanged(t)}}updateAnimation(t){let e=!1;return this._sortedMaterialRenderers.forAll(({materialRenderer:r})=>e=r.updateAnimation(t)||e),e}render(t,e){for(let r=0;r<this._sortedMaterialRenderers.length;r++){const i=this._sortedMaterialRenderers.data[r];i.material.shouldRender(t)&&i.materialRenderer.render(t.pass,e)}}intersect(t,e,r,i,s){return this._geometries.forEach(a=>{if(i&&!i(a))return;this._intersectRenderGeometry(a,r,e,0,t,s);const o=this.rendererContext.longitudeCyclical;o&&(a.boundingSphere[0]-a.boundingSphere[3]<o.min&&this._intersectRenderGeometry(a,r,e,o.range,t,s),a.boundingSphere[0]+a.boundingSphere[3]>o.max&&this._intersectRenderGeometry(a,r,e,-o.range,t,s)),s++}),s}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let t=0;this._materialRenderers.forEach((e,r)=>{r.insertOrder=t++,this._sortedMaterialRenderers.push({material:r,materialRenderer:e})}),this._sortedMaterialRenderers.sort((e,r)=>{const i=r.material.renderPriority-e.material.renderPriority;return i!==0?i:e.material.insertOrder-r.material.insertOrder})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let t=0;t<this._changes.updates.length;){const e=this._changes.updates.data[t];this._pending.has(e.renderGeometry)?this._changes.updates.removeUnorderedIndex(t):t++}this._pending.clear()}_intersectRenderGeometry(t,e,r,i,s,a){if(!t.instanceParameters.visible)return;let o=0;x(t.transformation)&&(i+=t.transformation[12],o=t.transformation[13]),Ci[0]=r[0]-i,Ci[1]=r[1]-o,Ci[2]=1,Ai[0]=r[0]-i,Ai[1]=r[1]-o,Ai[2]=0,t.screenToWorldRatio=this.rendererContext.screenToWorldRatio,t.material.intersect(t,null,t.getShaderTransformation(),s,Ci,Ai,(n,c,l)=>{sp(e,l,t.material.renderPriority,a,s,t.layerUid,t.graphicUid)},t.calculateShaderTransformation,e)}_notifyGraphicGeometryChanged(t){if(K(this.drapeSource.notifyGraphicGeometryChanged))return;let e;for(const r of t){const i=r.graphicUid;x(i)&&i!==e&&(this.drapeSource.notifyGraphicGeometryChanged(i),e=i)}}_notifyGraphicVisibilityChanged(t){if(K(this.drapeSource.notifyGraphicVisibilityChanged))return;let e;for(const r of t){const i=r.graphicUid;x(i)&&i!==e&&(this.drapeSource.notifyGraphicVisibilityChanged(i),e=i)}}_validateRenderGeometries(t){for(const e of t)this._validateRenderGeometry(e);return t}_validateRenderGeometry(t){return K(t.origin)&&(t.origin=this._localOriginFactory.getOrigin(t.boundingSphere)),t}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};v([ie()],xt.prototype,"drapeSource",void 0),v([ie()],xt.prototype,"updating",null),v([ie()],xt.prototype,"rctx",null),v([ie()],xt.prototype,"rendererContext",void 0),v([ie()],xt.prototype,"_materialRepository",null),v([ie()],xt.prototype,"_localOriginFactory",null),xt=v([ra("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],xt);class ip{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return this.adds.size===0&&this.removes.size===0&&this.removed.size===0}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}function sp(t,e,r,i,s,a,o){const n={layerUid:a,graphicUid:o,triangleNr:e},c=l=>{l.set(Wt.OVERLAY,n,t.dist,t.normal,t.transformation,r,i)};if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||s.results.ground.dist<=s.results.min.dist)&&c(s.results.min),s.options.store!==ur.MIN&&(s.results.max.drapedLayerOrder==null||r<s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||s.results.ground.dist>s.results.max.dist)&&c(s.results.max),s.options.store===ur.ALL){const l=xu(s.ray);c(l),s.results.all.push(l)}}const Ci=j(),Ai=j();class Ps extends ci{constructor(e){super(e,"vec2")}}var qt;(function(t){t[t.SSAO=0]="SSAO",t[t.Blur=1]="Blur",t[t.COUNT=2]="COUNT"})(qt||(qt={}));class Bn extends ha{constructor(){super(...arguments),this.output=qt.SSAO}}v([R({count:qt.COUNT})],Bn.prototype,"output",void 0);const qr={samples:16,filterRadius:4};function ap(t){const e=new pr,r=e.fragment;if(e.include(gn),t.output===qt.Blur){const i=(qr.filterRadius+1)/2,s=1/(2*i*i);r.include(ti),r.uniforms.add([new pt("normalMap"),new pt("depthMap"),new pt("tex"),new Ps("blurSize"),new Ut("projScale"),new qe("nearFar",(a,o)=>o.camera.nearFar)]),r.code.add(p`
      void blurFunction(vec2 uv, float r, float center_d, float sharpness, inout float wTotal, inout float bTotal) {
        float c = texture2D(tex, uv).r;
        float d = linearDepthFromTexture(depthMap, uv, nearFar);

        float ddiff = d - center_d;

        float w = exp(-r * r * ${p.float(s)} - ddiff * ddiff * sharpness);
        wTotal += w;
        bTotal += w * c;
      }
    `),r.code.add(p`
      void main(void) {
        float b = 0.0;
        float w_total = 0.0;

        float center_d = linearDepthFromTexture(depthMap, uv, nearFar);

        float sharpness = -0.05 * projScale/center_d;
        for (int r = -${p.int(qr.filterRadius)}; r <= ${p.int(qr.filterRadius)}; ++r) {
          float rf = float(r);
          vec2 uvOffset = uv + rf * blurSize;
          blurFunction(uvOffset, rf, center_d, sharpness, w_total, b);
        }

        gl_FragColor = vec4(b / w_total);
      }
    `)}return t.output===qt.SSAO&&(r.include(ti),e.include(cd),r.uniforms.add(new pt("normalMap")),r.uniforms.add(new pt("depthMap")),r.uniforms.add(new pt("rnm")),r.uniforms.add(new Ut("intensity")),r.uniforms.add(new Ut("projScale")),r.uniforms.add(new Ut("radius")),r.uniforms.add(new qe("nearFar",(i,s)=>s.camera.nearFar)),r.uniforms.add(new Ps("screenSize")),r.uniforms.add(new Ps("rnmScale")),r.code.add(p`vec3 sphere[16];
void fillSphere() {
sphere[0] = vec3(0.186937, 0.0, 0.0);
sphere[1] = vec3(0.700542, 0.0, 0.0);
sphere[2] = vec3(-0.864858, -0.481795, -0.111713);
sphere[3] = vec3(-0.624773, 0.102853, -0.730153);
sphere[4] = vec3(-0.387172, 0.260319, 0.007229);
sphere[5] = vec3(-0.222367, -0.642631, -0.707697);
sphere[6] = vec3(-0.01336, -0.014956, 0.169662);
sphere[7] = vec3(0.122575, 0.1544, -0.456944);
sphere[8] = vec3(-0.177141, 0.85997, -0.42346);
sphere[9] = vec3(-0.131631, 0.814545, 0.524355);
sphere[10] = vec3(-0.779469, 0.007991, 0.624833);
sphere[11] = vec3(0.308092, 0.209288,0.35969);
sphere[12] = vec3(0.359331, -0.184533, -0.377458);
sphere[13] = vec3(0.192633, -0.482999, -0.065284);
sphere[14] = vec3(0.233538, 0.293706, -0.055139);
sphere[15] = vec3(0.417709, -0.386701, 0.442449);
}
float fallOffFunction(float vv, float vn, float bias) {
float f = max(radius * radius - vv, 0.0);
return f * f * f * max(vn-bias, 0.0);
}`),r.code.add(p`float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {
vec3 v = Q - C;
float vv = dot(v, v);
float vn = dot(normalize(v), n_C);
return fallOffFunction(vv, vn, 0.1);
}`),e.fragment.uniforms.add(new qe("zScale",(i,s)=>mn(s))),r.code.add(p`
      void main(void) {
        fillSphere();
        vec3 fres = normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));
        float currentPixelDepth = linearDepthFromTexture(depthMap, uv, nearFar);

        if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
          gl_FragColor = vec4(0.0);
          return;
        }

        vec3 currentPixelPos = reconstructPosition(gl_FragCoord.xy,currentPixelDepth);

        // get the normal of current fragment
        vec4 norm4 = texture2D(normalMap, uv);
        vec3 norm = vec3(-1.0) + 2.0 * norm4.xyz;
        bool isTerrain = norm4.w<0.5;

        float sum = .0;
        vec3 tapPixelPos;

        // note: the factor 2.0 should not be necessary, but makes ssao much nicer.
        // bug or deviation from CE somewhere else?
        float ps = projScale/(2.0 * currentPixelPos.z * zScale.x + zScale.y);

        for(int i = 0; i < ${p.int(qr.samples)}; ++i) {
          vec2 unitOffset = reflect(sphere[i], fres).xy;
          vec2 offset = vec2(-unitOffset * radius * ps);

          //don't use current or very nearby samples
          if ( abs(offset.x)<2.0 || abs(offset.y)<2.0) continue;

          vec2 tc = vec2(gl_FragCoord.xy + offset);
          if (tc.x < 0.0 || tc.y < 0.0 || tc.x > screenSize.x || tc.y > screenSize.y) continue;
          vec2 tcTap = tc / screenSize;
          float occluderFragmentDepth = linearDepthFromTexture(depthMap, tcTap, nearFar);

          if (isTerrain) {
            bool isTerrainTap = texture2D(normalMap, tcTap).w<0.5;
            if (isTerrainTap) {
              continue;
            }
          }

          tapPixelPos = reconstructPosition(tc, occluderFragmentDepth);

          sum+= aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);
        }

        // output the result
        float A = max(1.0-sum*intensity/float(${p.int(qr.samples)}),0.0);

        // Anti-tone map to reduce contrast and drag dark region farther: (x^0.2 + 1.2 * x^4)/2.2
        A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;
        gl_FragColor = vec4(A);
      }
    `)),e}const op=Object.freeze(Object.defineProperty({__proto__:null,build:ap},Symbol.toStringTag,{value:"Module"}));class si extends fr{initializeProgram(e){const r=si.shader.get().build(this.configuration);return new mr(e.rctx,r,Nr)}initializePipeline(){return at({colorWrite:vt})}}si.shader=new gr(op,()=>kt(()=>import("./SSAO.glsl.46092e6a.js"),["assets/SSAO.glsl.46092e6a.js","assets/Matrix4Uniform.9e24b035.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/floatRGBA.5328f61e.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));class np{constructor(e,r,i){this._techniqueRep=e,this._rctx=r,this._requestRender=i,this._enabled=!1,this._ssaoTechniqueConfig=new Bn,this.quadVAO=null,this._blurSizePx=2,this._attenuation=.5}dispose(){this.quadVAO=Fe(this.quadVAO)}disposeOffscreenBuffers(){cs(this._ssaoFBO,e=>e.resize(0,0)),cs(this._blur0FBO,e=>e.resize(0,0)),cs(this._blur1FBO,e=>e.resize(0,0))}set enabled(e){e?this._enable():this._disable()}get enabled(){return this._enabled}get ready(){return this.enabled&&x(this._noiseTexture)&&x(this._ssaoFBO)&&x(this._blur0FBO)&&x(this._blur1FBO)}get colorTexture(){return x(this._blur1FBO)?this._blur1FBO.colorTexture:null}get width(){return x(this._ssaoFBO)?this._ssaoFBO.width:-1}get height(){return x(this._ssaoFBO)?this._ssaoFBO.height:-1}computeSSAO(e,r,i){if(!this.enabled||K(r)||K(i)||K(this._noiseTexture)||K(this._ssaoFBO)||K(this._blur0FBO)||K(this._blur1FBO))return;const s=this._rctx,a=e.camera,o=a.fullViewport,n=o[2],c=o[3],l=n/this._blurSizePx,h=c/this._blurSizePx;this._ssaoFBO.resize(n,c),this._blur0FBO.resize(l,h),this._blur1FBO.resize(l,h);const u=1,f=1,S=n*u,O=c*f;s.bindFramebuffer(this._ssaoFBO),s.setViewport(0,0,n,c);const b=s.bindTechnique(this._ssaoTechnique,Io,e);b.setUniform2f("rnmScale",n/this._noiseTexture.descriptor.width,c/this._noiseTexture.descriptor.height);let U=1/a.computeRenderPixelSizeAtDist(1);b.setUniform1f("projScale",U*u),b.setUniform2f("screenSize",S,O);const C=Ct(a.eye,a.center);let P=20*a.computeRenderPixelSizeAtDist(C);P=Math.max(.1,P),b.setUniform1f("radius",P),b.setUniform1f("intensity",4*this._attenuation/P**6),b.bindTexture("rnm",this._noiseTexture),b.bindTexture("normalMap",i),b.bindTexture("depthMap",r),K(this.quadVAO)&&(this.quadVAO=nn(this._rctx)),s.bindVAO(this.quadVAO),s.drawArrays(Rt.TRIANGLE_STRIP,0,Ei(this.quadVAO,"geometry"));const y=s.bindTechnique(this._blurTechnique,Io,e);y.bindTexture("tex",this._ssaoFBO.colorTexture),y.bindTexture("normalMap",i),y.bindTexture("depthMap",r),s.setViewport(0,0,S/this._blurSizePx,O/this._blurSizePx),s.bindFramebuffer(this._blur0FBO),y.setUniform2f("screenSize",S,O),y.setUniform2f("blurSize",0,this._blurSizePx*u/O),C>5e4&&(U=Math.max(0,U-(C-5e4))),y.setUniform1f("projScale",U),s.drawArrays(Rt.TRIANGLE_STRIP,0,Ei(this.quadVAO,"geometry")),y.setUniform2f("blurSize",this._blurSizePx*f/S,0),s.bindFramebuffer(this._blur1FBO),y.bindTexture("tex",this._blur0FBO.colorTexture),s.drawArrays(Rt.TRIANGLE_STRIP,0,Ei(this.quadVAO,"geometry")),s.setViewport(o[0],o[1],o[2],o[3])}_selectPrograms(){this._ssaoTechniqueConfig.output=qt.SSAO,this._ssaoTechnique=this._techniqueRep.releaseAndAcquire(si,this._ssaoTechniqueConfig,this._ssaoTechnique),this._ssaoTechniqueConfig.output=qt.Blur,this._blurTechnique=this._techniqueRep.releaseAndAcquire(si,this._ssaoTechniqueConfig,this._blurTechnique)}_enable(){this.enabled||(this._enabled=!0,this._loadResources(()=>{this._enabled&&this._initialize()}))}_loadResources(e){this._data?e():kt(()=>import("./SSAOHelperData.08f44d75.js"),[]).then(r=>{this._data=r,e()})}_initialize(){const e={target:or.TEXTURE_2D,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,samplingMode:ri.LINEAR,wrapMode:dr.CLAMP_TO_EDGE,width:0,height:0},r={colorTarget:pa.TEXTURE,depthStencilTarget:fa.NONE};ac(this._data.noiseTexture).then(i=>{this._enabled&&(this._ssaoFBO=new Yr(this._rctx,r,e),this._blur0FBO=new Yr(this._rctx,r,e),this._blur1FBO=new Yr(this._rctx,r,e),this._noiseTexture=new ir(this._rctx,{target:or.TEXTURE_2D,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,hasMipmap:!0,width:i.width,height:i.height},i),this._requestRender())}),this._selectPrograms()}_disable(){this._enabled=!1,this._noiseTexture=Fe(this._noiseTexture),this._blur1FBO=Fe(this._blur1FBO),this._blur0FBO=Fe(this._blur0FBO),this._ssaoFBO=Fe(this._ssaoFBO)}get gpuMemoryUsage(){return(x(this._blur0FBO)?this._blur0FBO.gpuMemoryUsage:0)+(x(this._blur1FBO)?this._blur1FBO.gpuMemoryUsage:0)+(x(this._ssaoFBO)?this._ssaoFBO.gpuMemoryUsage:0)}get test(){return{ssao:this._ssaoFBO,blur:this._blur1FBO}}}const Io=new Nc;function lp(){const t=new pr;return t.include(gn),t.fragment.uniforms.add([new pt("tex"),new Pi("uColor")]),t.fragment.code.add(p`void main() {
vec4 texColor = texture2D(tex, uv);
gl_FragColor = texColor * uColor;
}`),t}const cp=Object.freeze(Object.defineProperty({__proto__:null,build:lp},Symbol.toStringTag,{value:"Module"}));class is extends fr{initializeProgram(e){const r=is.shader.get().build();return new mr(e.rctx,r,Nr)}initializePipeline(){return this.configuration.hasAlpha?at({blending:Zo(gt.SRC_ALPHA,gt.ONE,gt.ONE_MINUS_SRC_ALPHA,gt.ONE_MINUS_SRC_ALPHA),colorWrite:vt}):at({colorWrite:vt})}}is.shader=new gr(cp,()=>kt(()=>import("./TextureOnly.glsl.95bbd6b9.js"),["assets/TextureOnly.glsl.95bbd6b9.js","assets/Matrix4Uniform.9e24b035.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/floatRGBA.5328f61e.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));class Gn extends ha{constructor(){super(...arguments),this.hasAlpha=!1}}v([R()],Gn.prototype,"hasAlpha",void 0);class dp{constructor(e){this._rctx=e,this.cache=new Map}dispose(){this.cache.forEach(e=>e.texture=Fe(e.texture)),this.cache.clear()}_acquire(e){if(K(e))return null;const r=this._patternId(e),i=this.cache.get(r);if(i)return i.refCount++,i.bind;const s=e.pixelRatio,{encodedData:a,sdfNormalizer:o,pixels:n,paddedPixels:c}=hp(e.pattern,s),l=n/s,h={refCount:1,texture:null,bind:u=>(K(h.texture)&&(h.texture=new ir(this._rctx,{width:c,height:1,internalFormat:Gt.RGBA,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,wrapMode:dr.CLAMP_TO_EDGE},a)),u.bindTexture("stipplePatternTexture",h.texture),{pixelSize:l,sdfNormalizer:o,pixels:n})};return this.cache.set(r,h),h.bind}release(e){if(K(e))return;const r=this._patternId(e),i=this.cache.get(r);i&&(i.refCount--,i.refCount===0&&(x(i.texture)&&i.texture.dispose(),this.cache.delete(r)))}swap(e,r){const i=this._acquire(r);return this.release(e),i}_patternId(e){return`${e.pattern.join(",")}-r${e.pixelRatio}`}}function hp(t,e){const r=t.map(O=>Math.round(O*e)),i=1/e,s=Math.floor(r.reduce((O,b)=>O+b)),a=r.reduce((O,b)=>Math.max(O,b)),o=(Math.floor(.5*(a-1))+.5)*i,n=[];let c=1;for(const O of r){for(let b=0;b<O;b++){const U=c*(Math.min(b,O-1-b)+.5)*i/o*.5+.5;n.push(U)}c=-c}const l=Math.round(r[0]/2),h=[...n.slice(l),...n.slice(0,l)],u=s+2,f=new Uint8Array(4*u);let S=4;for(const O of h)dn(O,f,S),S+=4;return f.copyWithin(0,S-4,S),f.copyWithin(S,4,8),{encodedData:f,sdfNormalizer:o,paddedPixels:u,pixels:s}}var ai,oi;(function(t){t[t.Standard=0]="Standard",t[t.TransparentToHUDVisibility=1]="TransparentToHUDVisibility",t[t.Transparency=2]="Transparency",t[t.OverlayWithTransparency=3]="OverlayWithTransparency",t[t.COUNT=4]="COUNT"})(ai||(ai={})),function(t){t[t.None=0]="None",t[t.Alpha=1]="Alpha",t[t.PremultipliedAlpha=2]="PremultipliedAlpha",t[t.COUNT=3]="COUNT"}(oi||(oi={}));class Ds extends ha{constructor(){super(...arguments),this.function=ai.Standard,this.alphaMode=oi.None,this.hasOpacityFactor=!1}}v([R({count:ai.COUNT})],Ds.prototype,"function",void 0),v([R({count:oi.COUNT})],Ds.prototype,"alphaMode",void 0),v([R()],Ds.prototype,"hasOpacityFactor",void 0);let dt=class extends Kh(ta){constructor(t){super(t),this._overlays=null,this._overlayRenderTarget=null,this._hasHighlights=!1,this._rendersOccluded=!1,this._hasWater=!1,this._handles=new zo,this._frameTask=zl,this._drapeSourceRenderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedDrapeSourceRenderers=new wt,this._rctx=null,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this.worldToPCSRatio=1,this.events=new No,this.longitudeCyclical=null}get _bindParameters(){return this._renderContext.bindParameters}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}initialize(){const t=this.view._stage.renderView;this._rctx=t.renderingContext;const e=t.waterTextureRepository;this._stippleTextureRepository=new dp(t.renderingContext),this._shaderTechniqueRepository=new Qh({rctx:this._rctx,viewingMode:Bt.Local,stippleTextureRepository:this._stippleTextureRepository,waterTextureRepository:e}),this._renderContext=new du(this._rctx,new hu(this._rctx,this.view.state.viewingMode),new np(this._shaderTechniqueRepository,this._rctx,()=>{})),this._handles.add([ds(()=>e.updating,()=>this.events.emit("content-changed"),Ea),ds(()=>this.spatialReference,r=>this._localOriginFactory=new au(r),Ea),Ul(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materialRepository=new ru(t.textureRepository,this._shaderTechniqueRepository,r=>{(r.renderOccluded&Mo)>0!==this._rendersOccluded&&this._updateRendersOccluded(),this.events.emit("content-changed"),this.notifyChange("updating")},()=>this.events.emit("content-changed")),this._bindParameters.slot=se.DRAPED_MATERIAL,this._bindParameters.highlightDepthTexture=zc(this._rctx),this._bindParameters.camera=sr,this._bindParameters.transparencyPassType=Oe.NONE,this._bindParameters.lighting.groundLightingFactor=1,this._bindParameters.lighting.globalFactor=0,this._bindParameters.lighting.set([new Uc(Mr(1,1,1))]),this._frameTask=this.view.resourceController.scheduler.registerTask(Vl.STAGE,this),this._handles.add(this._frameTask)}dispose(){this._handles.destroy(),this._drapeSourceRenderers.forEach(t=>t.destroy()),this._drapeSourceRenderers.clear(),this._debugTextureTechnique=jl(this._debugTextureTechnique),this._debugPatternTexture=Fe(this._debugPatternTexture),this._bindParameters.highlightDepthTexture=Fe(this._bindParameters.highlightDepthTexture),this._shaderTechniqueRepository=Fe(this._shaderTechniqueRepository),this._temporaryFBO=Fe(this._temporaryFBO),this._quadVAO=Fe(this._quadVAO),this.disposeOverlays()}get updating(){return this._sortedDrapeSourceRenderersDirty||this._frameTask.updating||Lt(this._drapeSourceRenderers,t=>t.updating)}get hasOverlays(){return x(this._overlays)&&x(this._overlayRenderTarget)}get gpuMemoryUsage(){return x(this._overlayRenderTarget)?this._overlayRenderTarget.gpuMemoryUsage:0}createGeometryDrapeSourceRenderer(t){return this.createDrapeSourceRenderer(t,xt)}createDrapeSourceRenderer(t,e,r){const i=this._drapeSourceRenderers.get(t);x(i)&&i.destroy();const s=new e({...r,rendererContext:this,drapeSource:t});return this._drapeSourceRenderers.set(t,s),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in t&&this._handles.add(ds(()=>t.fullOpacity,()=>this.events.emit("content-changed")),t),s}removeDrapeSourceRenderer(t){if(K(t))return;const e=this._drapeSourceRenderers.get(t);K(e)||(this._sortedDrapeSourceRenderersDirty=!0,this._drapeSourceRenderers.delete(t),this._handles.remove(t),e.destroy())}collectUnusedRenderTargetMemory(t){let e=!1;if(x(this._overlayRenderTarget))for(const r of this._overlayRenderTarget.renderTargets){const i=this.overlays[0].validTargets[r.type]||!this.overlays[1].validTargets[r.type];e=this._overlayRenderTarget.validateUsageForTarget(i,r,t)||e}return e}get overlays(){return ne(this._overlays,[])}ensureDrapeTargets(t){x(this._overlays)&&this._overlays.forEach(e=>{e.hasTargetWithoutRasterImage=hs(t,r=>r.drapeTargetType===Zs.WithoutRasterImage)})}ensureDrapeSources(t){x(this._overlays)&&this._overlays.forEach(e=>{e.hasDrapedFeatureSource=hs(t,r=>r.drapeSourceType===Kr.Features),e.hasDrapedRasterSource=hs(t,r=>r.drapeSourceType===Kr.RasterImage)})}ensureOverlays(t,e){K(this._overlays)&&(this._overlayRenderTarget=new Xh(this._rctx),this._overlays=[new so(Dr.INNER,this._overlayRenderTarget),new so(Dr.OUTER,this._overlayRenderTarget)]),this.ensureDrapeTargets(t),this.ensureDrapeSources(e)}disposeOverlays(){this._overlays=null,this._overlayRenderTarget=Fe(this._overlayRenderTarget),this.events.emit("textures-disposed")}get running(){return this.updating}runTask(t,e=()=>!0){this._frameTask.processQueue(t),t.done||this._processDrapeSources(t,e)}_processDrapeSources(t,e){let r=!1;for(const[i,s]of this._drapeSourceRenderers){if(t.done)break;(i.destroyed||e(i))&&s.commitChanges()&&(r=!0,t.madeProgress())}this._updateSortedDrapeSourceRenderers(),r&&(x(this._overlays)&&this._drapeSourceRenderers.size===0&&this.disposeOverlays(),this.notifyChange("updating"),this.events.emit("content-changed"),this._updateHasHighlights(),this._updateRendersOccluded(),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(Hl,t=>t.updatePolicy===Vs.SYNC)}isEmpty(){if(Ka.OVERLAY_DRAW_DEBUG_TEXTURE)return!1;for(const t of this._drapeSourceRenderers.values())if(!t.isEmpty)return!1;return!0}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return this._rendersOccluded}updateAnimation(t){let e=!1;return this._drapeSourceRenderers.forEach(r=>e=r.updateAnimation(t)||e),e}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawTarget(t,e,r){const i=t.canvasGeometries;if(i.numViews===0)return!1;this._screenToWorldRatio=r*t.mapUnitsPerPixel;const s=e.renderPass;if(this.isEmpty()||s===ye.MATERIAL_HIGHLIGHT&&!this.hasHighlights||s===ye.MATERIAL_NORMAL&&!this.hasWater||!t.hasSomeSizedView())return!1;const a=e.fbo;if(!a.isValid())return!1;const o=2*t.resolution,n=t.resolution;a.resize(o,n);const c=this._rctx;sr.pixelRatio=t.pixelRatio*r,this._renderContext.pass=s,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=s===ye.MATERIAL_NORMAL?se.DRAPED_WATER:se.DRAPED_MATERIAL,t.applyViewport(this._rctx),a.bind(c),t.index===Dr.INNER&&(c.setClearColor(0,0,0,0),c.clearSafe(zi.COLOR_BUFFER_BIT));const l=e.type===Te.ColorNoRasterImage?Mt.ExcludeRasterImage:e.type===Te.Occluded?Mt.OccludedOnly:Mt.Normal;if(l===Mt.OccludedOnly&&(this._renderContext.renderOccludedMask=Mo),Ka.OVERLAY_DRAW_DEBUG_TEXTURE&&l!==Mt.OccludedOnly)for(let h=0;h<i.numViews;h++)this._setViewParameters(i.extents[h],t,sr),this._drawDebugTexture(t.resolution,pp[t.index]);return this._drapeSourceRenderers.size>0&&this._sortedDrapeSourceRenderers.forAll(({drapeSource:h,renderer:u})=>{if(l===Mt.ExcludeRasterImage&&h.drapeSourceType===Kr.RasterImage)return;const{fullOpacity:f}=h,S=x(f)&&f<1&&s===ye.MATERIAL;S&&(this.bindTemporaryFramebuffer(this._rctx,o,n),c.clearSafe(zi.COLOR_BUFFER_BIT));for(let O=0;O<i.numViews;O++)this._setViewParameters(i.extents[O],t,sr),u.render(this._renderContext,this._bindParameters);S&&x(this._temporaryFBO)&&(a.bind(c),this.view._stage.renderView.compositingHelper.composite(this._renderContext.bindParameters,this._temporaryFBO.getTexture(),oi.PremultipliedAlpha,f,ai.OverlayWithTransparency,t.index))}),c.bindFramebuffer(null),a.generateMipMap(),this._renderContext.resetRenderOccludedMask(),!0}bindTemporaryFramebuffer(t,e,r){K(this._temporaryFBO)&&(this._temporaryFBO=new Hn(t,!1)),this._temporaryFBO.resize(e,r),this._temporaryFBO.bind(t)}async reloadShaders(){await this._shaderTechniqueRepository.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(t,e,r,i){var a,o;let s=0;for(const n of this._drapeSourceRenderers.values())s=(o=(a=n.intersect)==null?void 0:a.call(n,t,e,r,i,s))!=null?o:s}_updateSortedDrapeSourceRenderers(){if(!this._sortedDrapeSourceRenderersDirty||(this._sortedDrapeSourceRenderersDirty=!1,this._sortedDrapeSourceRenderers.clear(),this._drapeSourceRenderers.size===0))return;const t=this.view.map.allLayers;this._drapeSourceRenderers.forEach((e,r)=>{const i=t.indexOf(r.layer);this._sortedDrapeSourceRenderers.push(new up(r,e,i<0?1/0:i))}),this._sortedDrapeSourceRenderers.sort((e,r)=>e.index-r.index)}_setViewParameters(t,e,r){r.viewport[0]=r.viewport[1]=0,r.viewport[2]=r.viewport[3]=e.resolution,Bo(r.projectionMatrix,0,t[2]-t[0],0,t[3]-t[1],r.near,r.far),Bl(r.viewMatrix,[-t[0],-t[1],0]),this._bindParameters.camera=r}_updateHasWater(){const t=Lt(this._drapeSourceRenderers,e=>e.hasWater);t!==this._hasWater&&(this._hasWater=t,this.events.emit("has-water",t))}_updateHasHighlights(){const t=Lt(this._drapeSourceRenderers,e=>e.hasHighlights);t!==this._hasHighlights&&(this._hasHighlights=t,this.events.emit("has-highlights",t))}_updateRendersOccluded(){const t=Lt(this._drapeSourceRenderers,e=>e.rendersOccluded);t!==this._rendersOccluded&&(this._rendersOccluded=t,this.events.emit("renders-occluded",t))}_drawDebugTexture(t,e){this._ensureDebugPatternResources(t,t);const r=this._rctx,i=r.bindTechnique(this._debugTextureTechnique);i.setUniform4f("uColor",e[0],e[1],e[2],1),i.bindTexture("tex",this._debugPatternTexture),r.bindVAO(this._quadVAO),r.drawArrays(Rt.TRIANGLE_STRIP,0,Ei(this._quadVAO,"geometry"))}_ensureDebugPatternResources(t,e){if(this._debugPatternTexture)return;const r=new Uint8Array(t*e*4);let i=0;for(let a=0;a<e;a++)for(let o=0;o<t;o++){const n=Math.floor(o/10),c=Math.floor(a/10);n<2||c<2||10*n>t-20||10*c>e-20?(r[i++]=255,r[i++]=255,r[i++]=255,r[i++]=255):(r[i++]=255,r[i++]=255,r[i++]=255,r[i++]=1&n&&1&c?1&o^1&a?0:255:1&n^1&c?0:128)}this._debugPatternTexture=new ir(this._rctx,{target:or.TEXTURE_2D,pixelFormat:Gt.RGBA,dataType:hr.UNSIGNED_BYTE,samplingMode:ri.NEAREST,width:t,height:e},r);const s=new Gn;s.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniqueRepository.acquire(is,s),this._quadVAO=nn(this._rctx)}get test(){return{drapeSourceRenderers:this._drapeSourceRenderers,getDrapeSourceRenderer:t=>this._drapeSourceRenderers.get(t)}}};var Mt;v([ie()],dt.prototype,"_frameTask",void 0),v([ie()],dt.prototype,"_sortedDrapeSourceRenderersDirty",void 0),v([oo()],dt.prototype,"_shaderTechniqueRepository",void 0),v([oo()],dt.prototype,"_stippleTextureRepository",void 0),v([ie({constructOnly:!0})],dt.prototype,"view",void 0),v([ie()],dt.prototype,"worldToPCSRatio",void 0),v([ie()],dt.prototype,"spatialReference",void 0),v([ie({type:Boolean,readOnly:!0})],dt.prototype,"updating",null),dt=v([ra("esri.views.3d.terrain.OverlayRenderer")],dt),function(t){t[t.Normal=0]="Normal",t[t.OccludedOnly=1]="OccludedOnly",t[t.ExcludeRasterImage=2]="ExcludeRasterImage"}(Mt||(Mt={}));class up{constructor(e,r,i){this.drapeSource=e,this.renderer=r,this.index=i}}const pp=[[1,.5,.5],[.5,.5,1]],sr=new gi;sr.near=1,sr.far=1e4,sr.relativeElevation=null;const fp=-2,Mo=Ht.OccludeAndTransparent;function Pf(t){const e=[],r=[];mp(t,r,e);const i=r[0][1].data,s=e[0][1].length,a=new Uint16Array(s);return gp(t,r,e),vp(t,r,e,a),yp(t,r,e,a),_p(t,r,e,a),Sp(t,r,e,a),Tp(t,r,e,a),xp(t,r,e,i),new Ve(r,e,Xr.Line)}function Df(t,e,r,i){const s=t.type==="polygon"?Ui.CCW_IS_HOLE:Ui.NONE,a=t.type==="polygon"?t.rings:t.paths,{position:o,outlines:n}=hn(a,t.hasZ,s),c=new Float64Array(o.length),l=En(o,t.spatialReference,0,c,0,o,0,o.length/3,e,r,i),h=l!=null;return{lines:h?Wn(n,o,c):[],projectionSuccess:h,sampledElevation:l}}function Wn(t,e,r){const i=new Array;for(const{index:s,count:a}of t){if(a<=1)continue;const o=3*s,n=o+3*a;i.push({position:e.subarray(o,n),mapPosition:r?r.subarray(o,n):void 0})}return i}function If(t,e){const r=t.type==="polygon"?Ui.CCW_IS_HOLE:Ui.NONE,i=t.type==="polygon"?t.rings:t.paths,{position:s,outlines:a}=hn(i,!1,r),o=Mi(s,t.spatialReference,0,s,e,0,s.length/3);for(let n=2;n<s.length;n+=3)s[n]=fp;return{lines:o?Wn(a,s):[],projectionSuccess:o}}function mp(t,e,r){const{attributeData:{position:i},removeDuplicateStartEnd:s}=t,a=Op(i)&&s===Ks.REMOVE,o=i.length/3-(a?1:0),n=new Uint32Array(2*(o-1)),c=a?Gl(i,0,i.length-3):i;let l=0;for(let h=0;h<o-1;h++)n[l++]=h,n[l++]=h+1;e.push([d.POSITION,{size:3,data:c,exclusive:a}]),r.push([d.POSITION,n])}function gp(t,e,r){const i=t.attributeData.mapPosition;K(i)||(r.push([d.MAPPOS,r[0][1]]),e.push([d.MAPPOS,{size:3,data:i}]))}function vp(t,e,r,i){if(x(t.attributeData.colorFeature))return;const s=t.attributeData.color;e.push([d.COLOR,{size:4,data:ne(s,qh)}]),r.push([d.COLOR,i])}function _p(t,e,r,i){const s=t.attributeData.colorFeature;K(s)||(e.push([d.COLORFEATUREATTRIBUTE,{size:1,data:new Float32Array([s])}]),r.push([d.COLOR,i]))}function yp(t,e,r,i){if(x(t.attributeData.sizeFeature))return;const s=t.attributeData.size;e.push([d.SIZE,{size:1,data:[ne(s,1)]}]),r.push([d.SIZE,i])}function Sp(t,e,r,i){const s=t.attributeData.sizeFeature;K(s)||(e.push([d.SIZEFEATUREATTRIBUTE,{size:1,data:new Float32Array([s])}]),r.push([d.SIZEFEATUREATTRIBUTE,i]))}function Tp(t,e,r,i){const s=t.attributeData.opacityFeature;K(s)||(e.push([d.OPACITYFEATUREATTRIBUTE,{size:1,data:new Float32Array([s])}]),r.push([d.OPACITYFEATUREATTRIBUTE,i]))}function xp(t,e,r,i){if(K(t.overlayInfo)||t.overlayInfo.renderCoordsHelper.viewingMode!==Bt.Global||!t.overlayInfo.spatialReference.isGeographic)return;const s=new Float64Array(i.length),a=Wl(t.overlayInfo.spatialReference);for(let f=0;f<s.length;f+=3)ql(i,f,s,f,a);const o=i.length/3,n=new Float32Array(o+1);let c=wp,l=Rp,h=0,u=0;ae(c,s[u++],s[u++],s[u++]),n[0]=0;for(let f=1;f<o+1;++f)f===o&&(u=0),ae(l,s[u++],s[u++],s[u++]),h+=kl(c,l),n[f]=h,[c,l]=[l,c];e.push([d.DISTANCETOSTART,{size:1,data:n}]),r.push([d.DISTANCETOSTART,r[0][1]])}function Op(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}var Ks;(function(t){t[t.KEEP=0]="KEEP",t[t.REMOVE=1]="REMOVE"})(Ks||(Ks={}));const wp=j(),Rp=j();function Mf(t){switch(t){case"butt":return _t.BUTT;case"square":return _t.SQUARE;case"round":return _t.ROUND;default:return null}}class Cp{constructor(){this.visible=!0}}class $f{constructor(e,r,i={}){this.data=e,this.material=r,this.boundingSphere=ot(),this.instanceParameters=new Cp,this._transformation=le(),this._shaderTransformationDirty=!0,this.layerUid=ne(i.layerUid,null),this.graphicUid=ne(i.graphicUid,null),this.id=i.id?i.id:ni(),this.boundingInfo=ne(i.boundingInfo,null),this.calculateShaderTransformation=ne(i.calculateShaderTransformation,null),this.castShadow=!!i.castShadow&&i.castShadow}get transformation(){return this._transformation}updateTransformation(e){e(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(e,r,i=Ns(e)){K(this.boundingInfo)||(ue(r,this.boundingInfo.getCenter(),e),r[3]=this.boundingInfo.getBSRadius()*i)}get hasShaderTransformation(){return x(this.calculateShaderTransformation)}get primitiveType(){return this.data.primitiveType}getShaderTransformation(){return K(this.calculateShaderTransformation)?ne(this.transformation,cr):(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=le()),ft(this._shaderTransformation,this.calculateShaderTransformation(ne(this.transformation,cr))),this._shaderTransformationDirty=!1),this._shaderTransformation)}computeAttachmentOrigin(e){if(this.material.computeAttachmentOrigin)return!!this.material.computeAttachmentOrigin(this,e)&&(x(this._transformation)&&ue(e,e,this._transformation),!0);const r=this.indices.get(d.POSITION),i=this.vertexAttributes.get(d.POSITION);return!!Bc(i,r,e)&&(x(this._transformation)&&ue(e,e,this._transformation),!0)}get indices(){return this.data.indices}get vertexAttributes(){return this.data.vertexAttributes}addHighlight(){const e=new Bs(Us.Highlight),r=this.instanceParameters;return r.highlights=js(r.highlights,e),e}removeHighlight(e){const r=this.instanceParameters;r.highlights=Hs(r.highlights,e)}}const Vt=j();function Lf(t,e,r,i,s,a,o,n){const c=r?r.length:0,l=t.clippingExtent;if(Fs(e,Vt,t.elevationProvider.spatialReference),x(l)&&!Zl(l,Vt))return null;Fs(e,Vt,t.renderCoordsHelper.spatialReference);const h=t.localOriginFactory.getOrigin(Vt),u=new vn({castShadow:!1,metadata:{layerUid:a,graphicUid:o,usesVerticalDistanceToGround:!0}});for(let f=0;f<c;f++){const S=cr;u.addGeometry(r[f],i[f],S,h,n)}return{object:u,sampledElevation:jd(u,e,t.elevationProvider,t.renderCoordsHelper,s)}}function Ff(t,e,r){const i=t.elevationContext,s=r.spatialReference;Fs(e,Vt,s),i.centerPointInElevationSR=zr(Vt[0],Vt[1],e.hasZ?Vt[2]:0,s)}function Nf(t){switch(t.type){case"point":return t;case"polygon":case"extent":return Fd(t);case"polyline":{const e=t.paths[0];if(!e||e.length===0)return null;const r=Uo(e,Vo(e)/2);return zr(r[0],r[1],r[2],t.spatialReference)}case"mesh":return t.origin}return null}function zf(t,e,r,i,s){const a=new Float64Array(3*t.length),o=new Float64Array(a.length);t.forEach((l,h)=>{a[3*h+0]=l[0],a[3*h+1]=l[1],a[3*h+2]=l.length>2?l[2]:0});const n=En(a,e,0,o,0,a,0,a.length/3,r,i,s),c=n!=null;return{numVertices:t.length,position:a,mapPosition:o,projectionSuccess:c,sampledElevation:n}}function Ap(t){const e=new pr;e.include(ca),e.include(sn,t),e.include(yn,t),hi(e,t);const{vertex:r,fragment:i}=e;return t.stippleEnabled&&(e.attributes.add(d.UV0,"vec2"),e.attributes.add(d.AUXPOS1,"vec3"),r.uniforms.add(new We("viewport",(s,a)=>a.camera.fullViewport))),e.attributes.add(d.POSITION,"vec3"),e.varyings.add("vpos","vec3"),r.code.add(p`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),t.stippleEnabled&&(r.code.add(p`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),t.draped?r.uniforms.add(new pe("worldToScreenRatio",(s,a)=>1/a.screenToPCSRatio)):r.code.add(p`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),r.code.add(p`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`),t.draped?r.code.add(p`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`):r.code.add(p`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),r.code.add(p`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)),r.code.add(p`}`),t.output===w.Highlight&&e.include(Yi),e.include(Nt,t),i.uniforms.add(new pe("alphaCoverage",(s,a)=>Math.min(1,s.width*a.camera.pixelRatio))),t.hasVertexColors||i.uniforms.add(new We("constantColor",s=>s.color)),i.code.add(p`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${t.hasVertexColors?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${p.float(rt)}) {
      discard;
    }

    ${t.output===w.Color?p`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===w.Highlight?p`outputHighlight();`:""}
  }
  `),e}const bp=Object.freeze(Object.defineProperty({__proto__:null,build:Ap},Symbol.toStringTag,{value:"Module"}));class ss extends fr{constructor(e,r,i){super(e,r,i),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=e.stippleTextureRepository}get stippleEnabled(){return this.configuration.stippleEnabled&&this.configuration.output!==w.Highlight}initializeProgram(e){const r=ss.shader.get().build(this.configuration);return new mr(e.rctx,r,Nr)}destroy(){super.destroy(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,r){if(this.program.bindPass(e,r),this.stipplePattern!==e.stipplePattern){const i=e.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,i),this.stipplePattern=i}if(this.stippleEnabled){const{pixelSize:i,sdfNormalizer:s,pixels:a}=x(this.stippleTextureBind)?this.stippleTextureBind(this.program):{pixelSize:1,sdfNormalizer:1,pixels:1};this.program.setUniform1f("stipplePatternSDFNormalizer",s),this.program.setUniform1f("stipplePatternTextureSize",a),this.program.setUniform1f("stipplePatternPixelSize",i),this.program.setUniform1f("stipplePatternPixelSizeInv",1/i)}}initializePipeline(){const e=this.configuration,r=Zo(gt.SRC_ALPHA,gt.ONE,gt.ONE_MINUS_SRC_ALPHA,gt.ONE_MINUS_SRC_ALPHA),i=(s,a=null,o=null)=>at({blending:a,depthTest:Ko,depthWrite:o,colorWrite:vt,stencilWrite:e.hasOccludees?Fi:null,stencilTest:e.hasOccludees?s?Ni:la:null});return e.output===w.Color?(this._occludeePipelineState=i(!0,e.transparent||this.stippleEnabled?r:null,$r),i(!1,e.transparent||this.stippleEnabled?r:null,$r)):i(!1)}get primitiveType(){return Rt.LINES}getPipelineState(e,r){return r?this._occludeePipelineState:super.getPipelineState(e,r)}}ss.shader=new gr(bp,()=>kt(()=>import("./NativeLine.glsl.1ad6bdb2.js"),["assets/NativeLine.glsl.1ad6bdb2.js","assets/Matrix4Uniform.9e24b035.js","assets/index.52935b46.js","assets/index.be38f7b7.css","assets/enums.de935fa5.js","assets/Texture.7634927e.js","assets/requestImageUtils.16628477.js","assets/Util.221caaac.js","assets/geometryDataUtils.8151b70d.js","assets/triangle.4a12653d.js","assets/vectorStacks.a7af424f.js","assets/quatf64.b60d4974.js","assets/mat4f64.84d5c445.js","assets/lineSegment.42c0099b.js","assets/VertexAttribute.5551e0d8.js","assets/VertexArrayObject.b7add78f.js","assets/VertexElementDescriptor.d386088d.js","assets/BufferView.43fc091d.js","assets/quat.122fba57.js","assets/vec3f32.0772c8d8.js","assets/sphere.fe54e1ae.js","assets/plane.1ed71234.js","assets/InterleavedLayout.b5350ce1.js","assets/types.25c129c5.js","assets/floatRGBA.5328f61e.js","assets/triangulationUtils.b0bb3487.js","assets/earcut.d30cbec0.js","assets/deduplicate.ee0b1de6.js","assets/NestedMap.21c7ee53.js","assets/Octree.74aeccc1.js","assets/boundedPlane.d7d86859.js","assets/glUtil.345a77b1.js","assets/dehydratedFeatures.5573332f.js"]));class Ke extends di{constructor(){super(...arguments),this.output=w.Color,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.hasOccludees=!1}}v([R({count:w.COUNT})],Ke.prototype,"output",void 0),v([R()],Ke.prototype,"hasSlicePlane",void 0),v([R()],Ke.prototype,"hasVertexColors",void 0),v([R()],Ke.prototype,"transparent",void 0),v([R()],Ke.prototype,"draped",void 0),v([R()],Ke.prototype,"stippleEnabled",void 0),v([R()],Ke.prototype,"stippleOffColorEnabled",void 0),v([R()],Ke.prototype,"stipplePreferContinuous",void 0),v([R()],Ke.prototype,"hasOccludees",void 0),v([R({constValue:!1})],Ke.prototype,"stippleRequiresClamp",void 0),v([R({constValue:!1})],Ke.prototype,"stippleScaleWithLineWidth",void 0),v([R({constValue:!1})],Ke.prototype,"stippleRequiresStretchMeasure",void 0);const Ep=li.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");var Wi;(function(t){t[t.START=0]="START",t[t.END=1]="END"})(Wi||(Wi={}));class Uf extends ui{constructor(e){super(e,new Ip),this._techniqueConfig=new Ke}getConfiguration(e,r){this._techniqueConfig.output=e,this._techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this._techniqueConfig.hasVertexColors=this.parameters.hasVertexColors,this._techniqueConfig.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._techniqueConfig.draped=r.slot===se.DRAPED_MATERIAL;const i=x(this.parameters.stipplePattern);return this._techniqueConfig.stippleEnabled=i,this._techniqueConfig.stippleOffColorEnabled=i&&x(this.parameters.stippleOffColor),this._techniqueConfig.hasOccludees=this.parameters.hasOccludees,this._techniqueConfig.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._techniqueConfig}intersect(e,r,i,s,a,o,n,c,l){x(l)?Vc(e,s,l,o,1,n):this._intersectLineGeometry(e,r,i,s,n)}_intersectLineGeometry(e,r,i,s,a){if(!s.options.selectionMode||Ji(r))return;if(!cn(i))return void Ep.error("intersection assumes a translation-only matrix");const o=e.vertexAttributes.get(d.POSITION).data,n=s.camera,c=$p;Fr(c,s.point);const l=2;ae(kr[0],c[0]-l,c[1]+l,0),ae(kr[1],c[0]+l,c[1]+l,0),ae(kr[2],c[0]+l,c[1]-l,0),ae(kr[3],c[0]-l,c[1]-l,0);for(let O=0;O<4;O++)if(!n.unprojectFromRenderScreen(kr[O],Tt[O]))return;Ft(n.eye,Tt[0],Tt[1],Is),Ft(n.eye,Tt[1],Tt[2],Ms),Ft(n.eye,Tt[2],Tt[3],$s),Ft(n.eye,Tt[3],Tt[0],Ls);let h=Number.MAX_VALUE,u=0;for(let O=0;O<o.length-5;O+=3){if(ze[0]=o[O]+i[12],ze[1]=o[O+1]+i[13],ze[2]=o[O+2]+i[14],Ue[0]=o[O+3]+i[12],Ue[1]=o[O+4]+i[13],Ue[2]=o[O+5]+i[14],Ce(Is,ze)<0&&Ce(Is,Ue)<0||Ce(Ms,ze)<0&&Ce(Ms,Ue)<0||Ce($s,ze)<0&&Ce($s,Ue)<0||Ce(Ls,ze)<0&&Ce(Ls,Ue)<0)continue;if(n.projectToRenderScreen(ze,er),n.projectToRenderScreen(Ue,tr),er[2]<0&&tr[2]>0){xe(ht,ze,Ue);const U=n.frustum,C=-Ce(U[zt.NEAR],ze)/At(ht,Li(U[zt.NEAR]));ce(ht,ht,C),_e(ze,ze,ht),n.projectToRenderScreen(ze,er)}else if(er[2]>0&&tr[2]<0){xe(ht,Ue,ze);const U=n.frustum,C=-Ce(U[zt.NEAR],Ue)/At(ht,Li(U[zt.NEAR]));ce(ht,ht,C),_e(Ue,Ue,ht),n.projectToRenderScreen(Ue,tr)}else if(er[2]<0&&tr[2]<0)continue;er[2]=0,tr[2]=0;const b=pn(Pr(er,tr,Fo),c);b<h&&(h=b,te($o,ze),te(Lo,Ue),u=O/3)}const f=s.rayBegin,S=s.rayEnd;if(h<l*l){let O=Number.MAX_VALUE;if(fn(Pr($o,Lo,Fo),Pr(f,S,Mp),Kt)){xe(Kt,Kt,f);const b=Ot(Kt);ce(Kt,Kt,1/b),O=b/Ct(f,S)}a(O,Kt,u,!1)}}computeAttachmentOrigin(e,r){const i=e.vertexAttributes;if(!i)return!1;const s=i.get(d.POSITION);return ln(s,null,!1,r)}requiresSlot(e){return e===se.OPAQUE_MATERIAL||e===se.DRAPED_MATERIAL}createGLMaterial(e){return e.output===w.Color||e.output===w.Highlight?new Pp(e):null}createBufferWriter(){const e=this.parameters.hasVertexColors?jn:Lh;return K(this.parameters.stipplePattern)?new ga(e):new Dp(e.clone().vec3f(d.AUXPOS1).vec2f(d.UV0))}}class Pp extends Qi{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output===w.Color&&this._updateOccludeeState(e),this.ensureTechnique(ss,e)}}class Dp{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(d.POSITION).length}write(e,r,i,s){rn(r,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,i,s),this._writeAuxpos1(e,r,i,s),this._writeUV0(e,r,i,s)}_writeAuxpos1(e,r,i,s){const a=i.getField(d.AUXPOS1,nd),o=r.indices.get(d.POSITION),n=r.vertexAttributes.get(d.POSITION).data,c=e.transformation,l=a.typedBufferStride,h=a.typedBuffer;s*=l;for(let u=0;u<o.length-1;u+=2)for(const f of[1,0]){const S=3*o[u+f],O=n[S],b=n[S+1],U=n[S+2],C=c[0]*O+c[4]*b+c[8]*U+c[12],P=c[1]*O+c[5]*b+c[9]*U+c[13],y=c[2]*O+c[6]*b+c[10]*U+c[14];h[s]=C,h[s+1]=P,h[s+2]=y,s+=l}}_writeUV0(e,r,i,s){var _;const a=i.getField(d.UV0,ld),o=r.indices.get(d.POSITION),n=r.vertexAttributes.get(d.POSITION).data,c=(_=r.vertexAttributes.get(d.DISTANCETOSTART))==null?void 0:_.data,l=e.transformation,h=a.typedBufferStride,u=a.typedBuffer;let f=0;u[s*=h]=Wi.START,u[s+1]=f,s+=h;const S=3*o[0],O=ae(ze,n[S],n[S+1],n[S+2]);l&&ue(O,O,l);const b=Ue,U=o.length-1;let C=1;const P=c?(m,g,A)=>f=c[A]:(m,g,A)=>f+=Ct(m,g);for(let m=1;m<U;m+=2){const g=3*o[m];ae(b,n[g],n[g+1],n[g+2]),l&&ue(b,b,l),P(O,b,C++);for(let A=0;A<2;++A)u[s]=1-A,u[s+1]=f,s+=h;te(O,b)}const y=3*o[U];ae(b,n[y],n[y+1],n[y+2]),l&&ue(b,b,l),P(O,b,C),u[s]=Wi.END,u[s+1]=f}}class Ip extends da{constructor(){super(...arguments),this.color=ki,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.stipplePreferContinuous=!0,this.hasOccludees=!1}}const ze=j(),Ue=j(),ht=j(),Kt=j(),er=tt(),tr=tt(),$o=j(),Lo=j(),Fo=Ki(),Mp=Ki(),$p=j(),kr=[tt(),tt(),tt(),tt()],Tt=[j(),j(),j(),j()],Is=bt(),Ms=bt(),$s=bt(),Ls=bt();export{fp as $,ff as A,Kd as B,Tf as C,cf as D,et as E,Ud as F,ks as G,Od as H,fh as I,Of as J,gi as K,ph as L,mh as M,st as N,vn as O,Ks as P,gf as Q,Df as R,vf as S,of as T,Lf as U,pf as V,Uf as W,Ff as X,Yd as Y,Ld as Z,En as _,Pi as a,hf as a0,_f as a1,ma as a2,bf as a3,Nf as a4,fd as a5,_t as a6,Mf as a7,Cf as a8,Bs as a9,pd as aa,Wt as ab,ur as ac,xu as ad,df as ae,uf as af,Oo as ag,An as ah,zu as ai,Nu as aj,Ef as ak,au as al,Sf as am,yf as an,nf as ao,lf as ap,Af as aq,ji as ar,Sd as as,Nh as at,Ap as au,_h as av,Bi as aw,lp as ax,ap as ay,Lu as az,xf as b,Mn as c,wf as d,Rf as e,Kr as f,If as g,In as h,$f as i,Pf as j,ii as k,ud as l,mf as m,cd as n,gn as o,zf as p,yi as q,Ut as r,pt as s,wn as t,ga as u,Fh as v,Fd as w,kd as x,Pn as y,Ka as z};
