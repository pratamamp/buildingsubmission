import{ai as V,l as p,jD as D,at as x,c6 as pe,_ as H,aY as E,sn as Be,x1 as Ze,kL as Ve,eQ as Je,ae as We,w as Z,s as ae,aW as he,qh as Ie,i7 as ge,ha as De,gE as Q,qt as me,qu as de,qv as xe,qo as ye,qr as we,qs as ve,gM as ze,qw as Ae,x2 as q,x3 as K,lA as Xe,aU as Ce,i6 as ee,p2 as Ye,gJ as He,nj as Se,aX as ke,dh as Qe,c8 as Ke,g7 as et,pI as tt,I as nt,aw as le,v as rt,x4 as st,e as A,g as M,n as ot,dq as oe,b$ as it,i as at}from"./index.ce207a0f.js";import{a as J,g as ce,l as fe,x as lt,k as Y}from"./axisAngleDegrees.13d66b59.js";import{r as se,M as ct,x as ft,k as ut,L as te}from"./georeference.f046a67b.js";const ue=V.getLogger("esri.geometry.support.meshUtils.centerAt");function pt(e,n,t){var s;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=(s=t==null?void 0:t.origin)!=null?s:e.origin;p(e.transform)?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&ue.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),ht(e.transform,n,r)):se(e.spatialReference,t)?gt(e,n,r):mt(e,n,r)}function ht(e,n,t){const r=n.x-t.x,s=n.y-t.y,i=n.hasZ&&t.hasZ?n.z-t.z:0,o=e.origin;e.origin=[o[0]+r,o[1]+s,o[2]+i]}function gt(e,n,t){const r=ct(e.vertexAttributes,t,{geographic:!0}),{position:s,normal:i,tangent:o}=ft(r,n,{geographic:!0});e.vertexAttributes.position=s,e.vertexAttributes.normal=i,e.vertexAttributes.tangent=o,e.vertexAttributesChanged()}function mt(e,n,t){const r=yt,s=xt;if(D(n,s,e.spatialReference)){if(!D(t,r,e.spatialReference)){const i=e.origin;r[0]=i.x,r[1]=i.y,r[2]=i.z,ue.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}dt(e.vertexAttributes.position,s,r),e.vertexAttributesChanged()}else ue.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}function dt(e,n,t){if(e)for(let r=0;r<e.length;r+=3)for(let s=0;s<3;s++)e[r+s]+=n[s]-t[s]}const xt=x(),yt=x();async function wt(e,n,t){const{loadGLTFMesh:r}=await pe(H(()=>import("./loadGLTFMesh.0fabd25b.js"),["assets/loadGLTFMesh.0fabd25b.js","assets/index.ce207a0f.js","assets/index.34e61a30.css","assets/georeference.f046a67b.js","assets/axisAngleDegrees.13d66b59.js"]),t),s=await Te(n,t),i=r(new E({x:0,y:0,z:0,spatialReference:e.spatialReference}),s.url,{resolveFile:vt(s),useTransform:!0,signal:p(t)?t.signal:null});i.then(()=>s.dispose(),()=>s.dispose());const{vertexAttributes:o,components:a}=await i;e.vertexAttributes=o,e.components=a}function vt(e){const n=Be(e.url);return t=>{var i;const r=Ze(t,n,n),s=r?r.replace(/^ *\.\//,""):null;return(i=e.files.get(s))!=null?i:t}}async function Te(e,n){return e instanceof Blob?G.fromBlob(e):typeof e=="string"?new G(e):Array.isArray(e)?At(e,n):$t(e,n)}async function At(e,n){const t=new Map;let r=null;const s=await Ve(e.map(async o=>({name:o.name,source:await Te(o instanceof Blob?o:o.source,n)}))),i=[];for(const o of s)o&&(Je(n)?o.source.dispose():i.push(o));We(n);for(const{name:o,source:a}of i)(Z(r)||/\.(gltf|glb)/i.test(o))&&(r=a.url),t.set(o,a.url),a.files&&a.files.forEach((l,c)=>t.set(c,l));if(Z(r))throw new ae("mesh-load-external:missing-files","Missing files to load external mesh source");return new G(r,()=>i.forEach(({source:o})=>o.dispose()),t)}async function $t(e,n){const{default:t}=await pe(H(()=>import("./index.ce207a0f.js").then(s=>s.x$),["assets/index.ce207a0f.js","assets/index.34e61a30.css"]),n),r=typeof e.multipart[0]=="string"?await Promise.all(e.multipart.map(async s=>(await t(s,{responseType:"array-buffer"})).data)):e.multipart;return G.fromBlob(new Blob(r))}class G{constructor(n,t=()=>{},r=new Map){this.url=n,this.dispose=t,this.files=r}static fromBlob(n){const t=URL.createObjectURL(n);return new G(t,()=>URL.revokeObjectURL(t))}}const bt=V.getLogger("esri.geometry.support.meshUtils.offset");function Rt(e,n,t){e.vertexAttributes&&e.vertexAttributes.position&&(p(e.transform)?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&bt.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),Mt(e.transform,n)):se(e.spatialReference,t)?Ft(e,n):Et(e,n))}function Mt(e,n){const t=e.origin;e.origin=he(x(),t,n)}function Ft(e,n){const t=e.spatialReference,r=e.vertexAttributes.position,s=e.vertexAttributes.normal,i=e.vertexAttributes.tangent,o=new Float64Array(r.length),a=p(s)?new Float32Array(s.length):null,l=p(i)?new Float32Array(i.length):null,c=e.extent.center,f=Ot;Ie(t,[c.x,c.y,c.z],$e,ge(t)),De(be,$e),Q(f,n,be),me(r,t,o),p(s)&&de(s,r,o,t,a),p(i)&&xe(i,r,o,t,l),_e(o,f),ye(o,r,t),p(s)&&we(a,r,o,t,s),p(i)&&ve(l,r,o,t,i),e.vertexAttributesChanged()}function Et(e,n){_e(e.vertexAttributes.position,n),e.vertexAttributesChanged()}function _e(e,n){if(e)for(let t=0;t<e.length;t+=3)for(let r=0;r<3;r++)e[t+r]+=n[r]}const Ot=x(),$e=ze(),be=Ae();function Lt(){const{faceDescriptions:e,faceVertexOffsets:n,uvScales:t}=Tt,r=4*e.length,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,f=0,g=0;for(let h=0;h<e.length;h++){const u=e[h],w=l/3;for(const d of n)a[g++]=w+d;const O=u.corners;for(let d=0;d<4;d++){const b=O[d];let v=0;o[f++]=.25*t[d][0]+u.uvOrigin[0],o[f++]=u.uvOrigin[1]-.25*t[d][1];for(let R=0;R<3;R++)u.axis[R]!==0?(s[l++]=.5*u.axis[R],i[c++]=u.axis[R]):(s[l++]=.5*b[v++],i[c++]=0)}}return{position:s,normal:i,uv:o,faces:a}}function Pt(e,n){const t=e.components[0],r=t.faces,s=_t[n],i=6*s,o=new Uint32Array(6),a=new Uint32Array(r.length-6);let l=0,c=0;for(let f=0;f<r.length;f++)f>=i&&f<i+6?o[l++]=r[f]:a[c++]=r[f];if(p(e.vertexAttributes.uv)){const f=new Float32Array(e.vertexAttributes.uv),g=4*s*2,h=[0,1,1,1,1,0,0,0];for(let u=0;u<h.length;u++)f[g+u]=h[u];e.vertexAttributes.uv=f}return e.components=[new q({faces:o,material:t.material}),new q({faces:a})],e}function It(e=0){const n=Math.round(8*2**e),t=2*n,r=(n-1)*(t+1)+2*t,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),a=new Uint32Array(3*((n-1)*t*2));let l=0,c=0,f=0,g=0;for(let h=0;h<=n;h++){const u=h/n*Math.PI+.5*Math.PI,w=Math.cos(u),O=Math.sin(u);m[2]=O;const d=h===0||h===n,b=d?t-1:t;for(let v=0;v<=b;v++){const R=v/b*2*Math.PI;m[0]=-Math.sin(R)*w,m[1]=Math.cos(R)*w;for(let L=0;L<3;L++)s[l]=.5*m[L],i[l]=m[L],++l;o[c++]=(v+(d?.5:0))/t,o[c++]=h/n,h!==0&&v!==t&&(h!==n&&(a[f++]=g,a[f++]=g+1,a[f++]=g-t),h!==1&&(a[f++]=g,a[f++]=g-t,a[f++]=g-t-1)),g++}}return{position:s,normal:i,uv:o,faces:a}}function Dt(e=0){const t=Math.round(16*2**e),r=(5-1)*(t+1)+2*t,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),a=new Uint32Array(3*(4*t));let l=0,c=0,f=0,g=0,h=0;for(let u=0;u<=5;u++){const w=u===0||u===5,O=u<=1||u>=5-1,d=u===2||u===4,b=w?t-1:t;for(let v=0;v<=b;v++){const R=v/b*2*Math.PI,L=w?0:.5;m[0]=L*Math.sin(R),m[1]=L*-Math.cos(R),m[2]=u<=2?.5:-.5;for(let C=0;C<3;C++)s[l++]=m[C],i[c++]=O?C===2?u<=1?1:-1:0:C===2?0:m[C]/L;o[f++]=(v+(w?.5:0))/t,o[f++]=u<=1?1*u/3:u<=3?1*(u-2)/3+1/3:1*(u-4)/3+2/3,d||u===0||v===t||(u!==5&&(a[g++]=h,a[g++]=h+1,a[g++]=h-t),u!==1&&(a[g++]=h,a[g++]=h-t,a[g++]=h-t-1)),h++}}return{position:s,normal:i,uv:o,faces:a}}function zt(e,n){const t=typeof n=="number"?n:n!=null?n.width:1,r=typeof n=="number"?n:n!=null?n.height:1;switch(e){case"up":case"down":return{width:t,depth:r};case"north":case"south":return{width:t,height:r};case"east":case"west":return{depth:t,height:r}}}function Ct(e){const n=B.facingAxisOrderSwap[e],t=B.position,r=B.normal,s=new Float64Array(t.length),i=new Float32Array(r.length);let o=0;for(let a=0;a<4;a++){const l=o;for(let c=0;c<3;c++){const f=n[c],g=Math.abs(f)-1,h=f>=0?1:-1;s[o]=t[l+g]*h,i[o]=r[l+g]*h,o++}}return{position:s,normal:i,uv:new Float32Array(B.uv),faces:new Uint32Array(B.faces),isPlane:!0}}const S=1,k=2,T=3,B={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[T,S,k],west:[-T,-S,k],north:[-S,T,k],south:[S,-T,k],up:[S,k,T],down:[S,-k,-T]}};function W(e,n,t){e.isPlane||St(e),kt(e,t&&t.size);const{vertexAttributes:r,transform:s}=ut(e,n,t);return{vertexAttributes:new K({...r,uv:e.uv}),transform:s,components:[new q({faces:e.faces,material:t&&t.material||null})],spatialReference:n.spatialReference}}function St(e){for(let n=0;n<e.position.length;n+=3)e.position[n+2]+=.5}function kt(e,n){if(n==null)return;const t=typeof n=="number"?[n,n,n]:[n.width!=null?n.width:1,n.depth!=null?n.depth:1,n.height!=null?n.height:1];P[0]=t[0],P[4]=t[1],P[8]=t[2];for(let r=0;r<e.position.length;r+=3){for(let s=0;s<3;s++)m[s]=e.position[r+s];Q(m,m,P);for(let s=0;s<3;s++)e.position[r+s]=m[s]}if(t[0]!==t[1]||t[1]!==t[2]){P[0]=1/t[0],P[4]=1/t[1],P[8]=1/t[2];for(let r=0;r<e.normal.length;r+=3){for(let s=0;s<3;s++)m[s]=e.normal[r+s];Q(m,m,P),Xe(m,m);for(let s=0;s<3;s++)e.normal[r+s]=m[s]}}}const Tt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},_t={south:0,east:1,north:2,west:3,up:4,down:5},m=x(),P=Ae(),Ue=V.getLogger("esri.geometry.support.meshUtils.rotate");function Ut(e,n,t){var s,i;if(!e.vertexAttributes||!e.vertexAttributes.position||n[3]===0)return;const r=e.spatialReference;if(p(e.transform)){(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&Ue.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=(s=t==null?void 0:t.origin)!=null?s:e.transform.getOriginPoint(r);Nt(e.transform,n,o)}else{const o=(i=t==null?void 0:t.origin)!=null?i:e.origin;se(e.spatialReference,t)?jt(e,n,o):qt(e,n,o)}}function Nt(e,n,t){const r=Ce(U,t.x,t.y,t.z),s=ee(U,r,e.origin);e.applyLocalInverse(s,Re),e.rotation=ce(e.rotation,n,J()),e.applyLocalInverse(s,s),ee(s,s,Re),e.translation=he(x(),e.translation,s)}function jt(e,n,t){const r=e.spatialReference,s=ge(r),i=Ne;D(t,i,s)||D(e.origin,i,s);const o=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,c=new Float64Array(o.length),f=p(a)?new Float32Array(a.length):null,g=p(l)?new Float32Array(l.length):null;Ie(s,i,ne,s),De(Fe,ne);const h=Me;Q(fe(Me),fe(n),Fe),h[3]=n[3],me(o,r,c),p(a)&&de(a,o,c,r,f),p(l)&&xe(l,o,c,r,g),j(c,h,3,i),ye(c,o,r),p(a)&&(j(f,h,3),we(f,o,c,r,a)),p(l)&&(j(g,h,4),ve(g,o,c,r,l)),e.vertexAttributesChanged()}function qt(e,n,t){const r=Ne;if(!D(t,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Ue.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}j(e.vertexAttributes.position,n,3,r),j(e.vertexAttributes.normal,n,3),j(e.vertexAttributes.tangent,n,4),e.vertexAttributesChanged()}function j(e,n,t,r=Se){if(!Z(e)){Ye(ne,lt(n),fe(n));for(let s=0;s<e.length;s+=t){for(let i=0;i<3;i++)U[i]=e[s+i]-r[i];He(U,U,ne);for(let i=0;i<3;i++)e[s+i]=U[i]+r[i]}}}const U=x(),Re=x(),Me=J(),ne=ze(),Fe=Ae(),Ne=x(),je=V.getLogger("esri.geometry.support.meshUtils.scale");function Gt(e,n,t){var s;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(p(e.transform)){(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&je.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const i=(s=t==null?void 0:t.origin)!=null?s:e.transform.getOriginPoint(r);Bt(e.transform,n,i)}else{const i=se(e.spatialReference,t),o=t&&t.origin||e.origin;i?Zt(e,n,o):Vt(e,n,o)}}function Bt(e,n,t){const r=Ce(N,t.x,t.y,t.z),s=ee(N,r,e.origin);e.applyLocalInverse(s,Ee);const i=ke(x(),e.scale,n);e.scale=i,e.applyLocalInverse(s,s),ee(s,s,Ee),e.translation=he(x(),e.translation,s)}function Zt(e,n,t){const r=e.spatialReference,s=ge(r),i=Ge;D(t,i,s)||D(e.origin,i,s);const o=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,c=new Float64Array(o.length),f=p(a)?new Float32Array(a.length):null,g=p(l)?new Float32Array(l.length):null;me(o,r,c),p(a)&&de(a,o,c,r,f),p(l)&&xe(l,o,c,r,g),qe(c,n,i),ye(c,o,r),p(a)&&we(f,o,c,r,a),p(l)&&ve(g,o,c,r,l),e.vertexAttributesChanged()}function Vt(e,n,t){const r=Ge;if(!D(t,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,je.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}qe(e.vertexAttributes.position,n,r),e.vertexAttributesChanged()}function qe(e,n,t=Se){if(e)for(let r=0;r<e.length;r+=3){for(let s=0;s<3;s++)N[s]=e[r+s]-t[s];ke(N,N,n);for(let s=0;s<3;s++)e[r+s]=N[s]+t[s]}}const N=x(),Ee=x(),Ge=x();var F;const $=V.getLogger("esri.geometry.Mesh");let y=F=class extends Qe(Ke.LoadableMixin(et(tt))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new K,this.type="mesh"}initialize(){(Z(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add(nt(()=>{var e;return{vertexAttributes:this.vertexAttributes,components:(e=this.components)==null?void 0:e.map(n=>n.clone()),transform:p(this.transform)?this.transform.clone():null}},()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&p(this.external)&&p(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,n=this.spatialReference;if(e.length===0||this.components&&this.components.length===0)return{extent:new le({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new E({x:0,y:0,z:0,spatialReference:n})};const t=p(this.transform)?this.transform.project(e,n):e;let r=1/0,s=1/0,i=1/0,o=-1/0,a=-1/0,l=-1/0,c=0,f=0,g=0;const h=t.length,u=1/(h/3);let w=0;for(;w<h;){const O=t[w++],d=t[w++],b=t[w++];r=Math.min(r,O),s=Math.min(s,d),i=Math.min(i,b),o=Math.max(o,O),a=Math.max(a,d),l=Math.max(l,b),c+=u*O,f+=u*d,g+=u*b}return{extent:new le({xmin:r,ymin:s,zmin:i,xmax:o,ymax:a,zmax:l,spatialReference:n}),center:new E({x:c,y:f,z:g,spatialReference:n})}}get anchor(){if(p(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new E({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return p(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&p(this.external)&&p(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(q.from(e)),this.notifyChange("components")):$.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const n=this.components.indexOf(e);if(n!==-1)return this.components.splice(n,1),void this.notifyChange("components")}$.error("removeComponent()","Provided component is not part of the list of components")}else $.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,n,t,r){return Y(ie.x,e,_),Y(ie.y,n,Oe),Y(ie.z,t,Le),ce(_,Oe,_),ce(_,Le,_),Ut(this,_,r),this}offset(e,n,t,r){return this.loaded?(X[0]=e,X[1]=n,X[2]=t,Rt(this,X,r),this):($.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,n){return this.loaded?(Gt(this,e,n),this):($.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,n){return this.loaded?(pt(this,e,n),this):($.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return p(this.external)&&this.addResolvingPromise(wt(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,n=this.components?new Map:null,t={components:this.components?this.components.map(r=>r.cloneWithDeduplication(e,n)):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:p(this.transform)?this.transform.clone():null,external:p(this.external)?{source:this.external.source,extent:p(this.external.extent)?this.external.extent.clone():null}:null};return new F(t)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:n}=await H(()=>import("./gltfexport.54c94db0.js"),["assets/gltfexport.54c94db0.js","assets/index.ce207a0f.js","assets/index.34e61a30.css","assets/georeference.f046a67b.js","assets/axisAngleDegrees.13d66b59.js","assets/imageutils.4c2f18d6.js"]);return n(this,e)}static createBox(e,n){if(!(e instanceof E))return $.error(".createBox()","expected location to be a Point instance"),null;const t=new F(W(Lt(),e,n));return n&&n.imageFace&&n.imageFace!=="all"?Pt(t,n.imageFace):t}static createSphere(e,n){return e instanceof E?new F(W(It(n&&n.densificationFactor||0),e,n)):($.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,n){return e instanceof E?new F(W(Dt(n&&n.densificationFactor||0),e,n)):($.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,n){var s;if(!(e instanceof E))return $.error(".createPlane()","expected location to be a Point instance"),null;const t=(s=n==null?void 0:n.facing)!=null?s:"up",r=zt(t,n==null?void 0:n.size);return new F(W(Ct(t),e,{...n,size:r}))}static createFromPolygon(e,n){if(!(e instanceof rt))return $.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const t=st(e);return new F({vertexAttributes:new K({position:t.position}),components:[new q({faces:t.faces,shading:"flat",material:n&&n.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,n,t){if(!(e instanceof E))throw $.error(".createfromGLTF()","expected location to be a Point instance"),new ae("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await pe(H(()=>import("./loadGLTFMesh.0fabd25b.js"),["assets/loadGLTFMesh.0fabd25b.js","assets/index.ce207a0f.js","assets/index.34e61a30.css","assets/georeference.f046a67b.js","assets/axisAngleDegrees.13d66b59.js"]),t);return new F(await r(e,n,t))}static createWithExternalSource(e,n,t){var o,a,l;const r=(o=t==null?void 0:t.extent)!=null?o:null,s=(a=t==null?void 0:t.transform.clone())!=null?a:new te;s.origin=[e.x,e.y,(l=e.z)!=null?l:0];const i=e.spatialReference;return new F({external:{source:n,extent:r},transform:s,spatialReference:i})}static createIncomplete(e,n){var i,o;const t=(i=n==null?void 0:n.transform.clone())!=null?i:new te;t.origin=[e.x,e.y,(o=e.z)!=null?o:0];const r=e.spatialReference,s=new F({transform:t,spatialReference:r});return s.addResolvingPromise(Promise.reject(new ae("mesh-incomplete","Mesh resources are not complete"))),s}};A([M({type:[q],json:{write:!0}})],y.prototype,"components",void 0),A([M({type:te,json:{write:!0}})],y.prototype,"transform",void 0),A([M({constructOnly:!0})],y.prototype,"external",void 0),A([M({readOnly:!0})],y.prototype,"hasExtent",null),A([M({readOnly:!0})],y.prototype,"boundingInfo",null),A([M({readOnly:!0})],y.prototype,"anchor",null),A([M({readOnly:!0})],y.prototype,"origin",null),A([M({readOnly:!0,json:{read:!1}})],y.prototype,"extent",null),A([M({readOnly:!0,json:{read:!1,write:!0,default:!0}})],y.prototype,"hasZ",void 0),A([M({readOnly:!0,json:{read:!1,write:!0,default:!1}})],y.prototype,"hasM",void 0),A([M({type:K,nonNullable:!0,json:{write:!0}})],y.prototype,"vertexAttributes",void 0),y=F=A([ot("esri.geometry.Mesh")],y);const ie={x:oe(1,0,0),y:oe(0,1,0),z:oe(0,0,1)},_=J(),Oe=J(),Le=J(),X=x(),Pe=y;var z,re;(function(e){e.featureGUID="featureGUID",e.assetName="assetName",e.hash="hash",e.type="type",e.conversionStatus="conversionStatus",e.flags="flags",e.complexity="complexity",e.size="size",e.seqNo="seqNo",e.sourceHash="sourceHash",e.assetURL="assetURL"})(z||(z={})),function(e){e.SUBMITTED="SUBMITTED",e.INPROGRESS="INPROGRESS",e.FAILED="FAILED",e.COMPLETED="COMPLETED"}(re||(re={}));function tn(e,n,t){const r=t.features;t.features=[],delete t.geometryType;const s=it.fromJSON(t);s.geometryType="mesh";const i=s.spatialReference,o=Z(e.outFields)||!e.outFields.length?()=>({}):Jt(e.outFields.includes("*")?null:new Set(e.outFields));for(const a of r){const l=Wt(a,i,n);p(l)&&s.features.push(new at({geometry:l,attributes:o(a)}))}return s}function Jt(e){return({attributes:n})=>{if(!n)return{};if(!e)return n;for(const t in n)e.has(t)||delete n[t];return n}}function Wt(e,n,t){const{status:r,source:s}=Ht(e);if(r===I.FAILED)return null;const i=Xt(e,n,t),o=le.fromJSON(e.geometry);o.spatialReference=n;const a=Yt(e,t);return r===I.PENDING?Pe.createIncomplete(i,{extent:o,transform:a}):Pe.createWithExternalSource(i,s,{extent:o,transform:a})}function Xt({attributes:e},n,{transformFieldRoles:t}){return new E({x:e[t.originX],y:e[t.originY],z:e[t.originZ],spatialReference:n})}function Yt({attributes:e,assetMappings:n},{transformFieldRoles:t}){var r;return new te({translation:[e[t.translationX],e[t.translationY],e[t.translationZ]],rotation:Y([e[t.rotationX],e[t.rotationY],e[t.rotationZ]],e[t.rotationDeg]),scale:[e[t.scaleX],e[t.scaleY],e[t.scaleZ]],geographic:!((r=n[z.flags])!=null&&r.includes("PROJECT_VERTICES"))})}function Ht(e){if(!e.assetMappings)return{status:I.FAILED};const n=[],t=new Map;for(const r of e.assetMappings){const s=r[z.seqNo],i=r[z.assetName],o=r[z.assetURL],a=r[z.conversionStatus];if(a===re.FAILED)return{status:I.FAILED};if(a!==re.COMPLETED)return{status:I.PENDING};if(s==null)n.push({name:i,source:o});else{const l=t.get(i);let c;l?c=l.multipart:(c=[],n.push({name:i,source:{multipart:c}}),t.set(i,{multipart:c})),c[s]=o}}return{status:I.COMPLETED,source:n}}var I;(function(e){e[e.FAILED=0]="FAILED",e[e.PENDING=1]="PENDING",e[e.COMPLETED=2]="COMPLETED"})(I||(I={}));export{tn as meshFeatureSetFromJSON};
